---
title: 'Novedades de C# 9.0: Guía de C#'
description: Obtenga información general sobre las nuevas características disponibles en C# 9.0.
ms.date: 09/04/2020
ms.openlocfilehash: c256c03831ac759bc45467f38e85fd3a2884dda4
ms.sourcegitcommit: 532b03d5bbab764d63356193b04cd2281bc01239
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/26/2020
ms.locfileid: "92526592"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="c80f8-103">Novedades de C# 9.0</span><span class="sxs-lookup"><span data-stu-id="c80f8-103">What's new in C# 9.0</span></span>

<span data-ttu-id="c80f8-104">C# 9.0 agrega las siguientes características y mejoras al lenguaje C#:</span><span class="sxs-lookup"><span data-stu-id="c80f8-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="c80f8-105">Registros</span><span class="sxs-lookup"><span data-stu-id="c80f8-105">Records</span></span>](#record-types)
- [<span data-ttu-id="c80f8-106">Establecedores de solo inicialización</span><span class="sxs-lookup"><span data-stu-id="c80f8-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="c80f8-107">Instrucciones de nivel superior</span><span class="sxs-lookup"><span data-stu-id="c80f8-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="c80f8-108">Mejoras de coincidencia de patrones</span><span class="sxs-lookup"><span data-stu-id="c80f8-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="c80f8-109">Enteros con tamaño nativos</span><span class="sxs-lookup"><span data-stu-id="c80f8-109">Native sized integers</span></span>
- <span data-ttu-id="c80f8-110">Punteros de función</span><span class="sxs-lookup"><span data-stu-id="c80f8-110">Function pointers</span></span>
- <span data-ttu-id="c80f8-111">Supresión de la emisión de la marca localsinit</span><span class="sxs-lookup"><span data-stu-id="c80f8-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="c80f8-112">Expresiones nuevas con tipo de destino</span><span class="sxs-lookup"><span data-stu-id="c80f8-112">Target-typed new expressions</span></span>
- <span data-ttu-id="c80f8-113">Funciones anónimas estáticas</span><span class="sxs-lookup"><span data-stu-id="c80f8-113">static anonymous functions</span></span>
- <span data-ttu-id="c80f8-114">Expresiones condicionales con tipo de destino</span><span class="sxs-lookup"><span data-stu-id="c80f8-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="c80f8-115">Tipos de valor devueltos de covariante</span><span class="sxs-lookup"><span data-stu-id="c80f8-115">Covariant return types</span></span>
- <span data-ttu-id="c80f8-116">Compatibilidad con extensiones `GetEnumerator` para bucles `foreach`</span><span class="sxs-lookup"><span data-stu-id="c80f8-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="c80f8-117">Parámetros de descarte lambda</span><span class="sxs-lookup"><span data-stu-id="c80f8-117">Lambda discard parameters</span></span>
- <span data-ttu-id="c80f8-118">Atributos en funciones locales</span><span class="sxs-lookup"><span data-stu-id="c80f8-118">Attributes on local functions</span></span>
- <span data-ttu-id="c80f8-119">Inicializadores de módulo</span><span class="sxs-lookup"><span data-stu-id="c80f8-119">Module initializers</span></span>
- <span data-ttu-id="c80f8-120">Nuevas características para métodos parciales</span><span class="sxs-lookup"><span data-stu-id="c80f8-120">New features for partial methods</span></span>

<span data-ttu-id="c80f8-121">C# 9.0 es compatible con **.NET 5** .</span><span class="sxs-lookup"><span data-stu-id="c80f8-121">C# 9.0 is supported on **.NET 5** .</span></span> <span data-ttu-id="c80f8-122">Para obtener más información, vea [Control de versiones del lenguaje C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="c80f8-123">Tipos de registro</span><span class="sxs-lookup"><span data-stu-id="c80f8-123">Record types</span></span>

<span data-ttu-id="c80f8-124">En C# 9.0 se presentan los *_tipos de registro_* , un tipo de referencia que ofrece métodos sintetizados para proporcionar semántica de valores para la igualdad.</span><span class="sxs-lookup"><span data-stu-id="c80f8-124">C# 9.0 introduces \* *_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="c80f8-125">Los registros son inmutables de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="c80f8-125">Records are immutable by default.</span></span>

<span data-ttu-id="c80f8-126">Los tipos de registro facilitan la creación de tipos de referencia inmutables en .NET.</span><span class="sxs-lookup"><span data-stu-id="c80f8-126">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="c80f8-127">Históricamente, los tipos de .NET se han clasificado principalmente como tipos de referencia (incluidas las clases y los tipos anónimos) y tipos de valor (incluidas las estructuras y tuplas).</span><span class="sxs-lookup"><span data-stu-id="c80f8-127">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="c80f8-128">Aunque se recomiendan los tipos de valor inmutables, los tipos de valor mutable no suelen generar errores.</span><span class="sxs-lookup"><span data-stu-id="c80f8-128">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="c80f8-129">Las variables de tipo de valor contienen los valores para que los cambios se realicen en una copia de los datos originales cuando los tipos de valor se pasan a los métodos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-129">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="c80f8-130">Los tipos de referencia inmutables también ofrecen muchas ventajas.</span><span class="sxs-lookup"><span data-stu-id="c80f8-130">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="c80f8-131">Estas ventajas son más evidentes en programas simultáneos con datos compartidos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-131">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="c80f8-132">Desafortunadamente, C# le ha obligado a escribir código adicional para crear tipos de referencia inmutables.</span><span class="sxs-lookup"><span data-stu-id="c80f8-132">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="c80f8-133">Los registros proporcionan una declaración de tipos para un tipo de referencia inmutable que usa la semántica de valores para la igualdad.</span><span class="sxs-lookup"><span data-stu-id="c80f8-133">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="c80f8-134">Los métodos sintetizados para los códigos de igualdad y hash consideran que dos registros son iguales si sus propiedades son iguales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-134">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="c80f8-135">Considere esta definición:</span><span class="sxs-lookup"><span data-stu-id="c80f8-135">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="c80f8-136">La definición del registro crea un tipo `Person` que contiene dos propiedades de solo lectura: `FirstName` y `LastName`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-136">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="c80f8-137">El tipo `Person` es un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="c80f8-137">The `Person` type is a reference type.</span></span> <span data-ttu-id="c80f8-138">Si ha examinado el lenguaje intermedio, es una clase.</span><span class="sxs-lookup"><span data-stu-id="c80f8-138">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="c80f8-139">Es inmutable porque ninguna de las propiedades se puede modificar una vez que se ha creado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-139">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="c80f8-140">Al definir un tipo de registro, el compilador sintetiza otros métodos de forma automática:</span><span class="sxs-lookup"><span data-stu-id="c80f8-140">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="c80f8-141">Métodos para comparaciones de igualdad basadas en valores</span><span class="sxs-lookup"><span data-stu-id="c80f8-141">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="c80f8-142">Invalidación de <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="c80f8-142">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="c80f8-143">Copiar y clonar miembros</span><span class="sxs-lookup"><span data-stu-id="c80f8-143">Copy and Clone members</span></span>
- <span data-ttu-id="c80f8-144">`PrintMembers` y <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="c80f8-144">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="c80f8-145">Los registros admiten la herencia.</span><span class="sxs-lookup"><span data-stu-id="c80f8-145">Records support inheritance.</span></span> <span data-ttu-id="c80f8-146">Puede declarar un nuevo registro derivado de `Person` como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="c80f8-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="c80f8-147">También puede sellar los registros para evitar la derivación adicional:</span><span class="sxs-lookup"><span data-stu-id="c80f8-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="c80f8-148">El compilador sintetiza versiones diferentes de los métodos anteriores.</span><span class="sxs-lookup"><span data-stu-id="c80f8-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="c80f8-149">Las signaturas de método dependen de si el tipo de registro está sellado y si la clase base directa es un objeto.</span><span class="sxs-lookup"><span data-stu-id="c80f8-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="c80f8-150">Los registros deben tener las funciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="c80f8-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="c80f8-151">La igualdad se basa en valores e incluye una comprobación de coincidencia de los tipos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="c80f8-152">Por ejemplo, `Student` no puede ser igual a `Person`, aunque los dos registros compartan el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c80f8-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="c80f8-153">Los registros tienen una representación de cadena coherente que se genera de forma automática.</span><span class="sxs-lookup"><span data-stu-id="c80f8-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="c80f8-154">Los registros admiten la construcción de copias.</span><span class="sxs-lookup"><span data-stu-id="c80f8-154">Records support copy construction.</span></span> <span data-ttu-id="c80f8-155">La construcción de copias correctas debe incluir las jerarquías de herencia y las propiedades agregadas por los desarrolladores.</span><span class="sxs-lookup"><span data-stu-id="c80f8-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="c80f8-156">Los registros se pueden copiar con modificaciones.</span><span class="sxs-lookup"><span data-stu-id="c80f8-156">Records can be copied with modification.</span></span> <span data-ttu-id="c80f8-157">Estas operaciones de copia y modificación admiten la mutación no destructiva.</span><span class="sxs-lookup"><span data-stu-id="c80f8-157">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="c80f8-158">Además de las sobrecargas de `Equals` conocidas, `operator ==` y `operator !=`, el compilador sintetiza una nueva propiedad `EqualityContract`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-158">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="c80f8-159">La propiedad devuelve un objeto `Type` que coincide con el tipo del registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-159">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="c80f8-160">Si el tipo base es `object`, la propiedad es `virtual`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-160">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="c80f8-161">Si el tipo base es otro tipo de registro, la propiedad es un `override`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-161">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="c80f8-162">Si el tipo de registro es `sealed`, la propiedad es `sealed`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-162">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="c80f8-163">El método `GetHashCode` sintetizado usa el valor `GetHashCode` de todas las propiedades y campos declarados en el tipo base y el tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-163">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="c80f8-164">Estos métodos sintetizados imponen la igualdad basada en valores en una jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="c80f8-164">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="c80f8-165">Esto significa que un registro `Student` nunca se considerará igual que un registro `Person` con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c80f8-165">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="c80f8-166">Los tipos de los dos registros deben coincidir y todas las propiedades compartidas entre los tipos de registro deben ser iguales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-166">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="c80f8-167">Los registros también tienen un constructor sintetizado y un método "clone" para crear copias.</span><span class="sxs-lookup"><span data-stu-id="c80f8-167">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="c80f8-168">El constructor sintetizado tiene un argumento del tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-168">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="c80f8-169">Genera un nuevo registro con los mismos valores para todas las propiedades del registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-169">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="c80f8-170">Este constructor es privado si el registro está sellado; de lo contrario está protegido.</span><span class="sxs-lookup"><span data-stu-id="c80f8-170">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="c80f8-171">El método "clone" sintetizado admite la construcción de copias para las jerarquías de registros.</span><span class="sxs-lookup"><span data-stu-id="c80f8-171">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="c80f8-172">El término "clone" está entre comillas porque el nombre real es el compilador generado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-172">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="c80f8-173">No se puede crear un método denominado `Clone` en un tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-173">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="c80f8-174">El método "clone" sintetizado devuelve el tipo de registro que se copia mediante el envío virtual.</span><span class="sxs-lookup"><span data-stu-id="c80f8-174">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="c80f8-175">El compilador agrega distintos modificadores para el método "clone", en función de los modificadores de acceso de `record`:</span><span class="sxs-lookup"><span data-stu-id="c80f8-175">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="c80f8-176">Si el tipo de registro es `abstract`, el método "clone" también es `abstract`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-176">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="c80f8-177">Si el tipo base no es `object`, el método también es `override`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-177">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="c80f8-178">Para los tipos de registro que no son `abstract` cuando el tipo base es `object`:</span><span class="sxs-lookup"><span data-stu-id="c80f8-178">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="c80f8-179">Si el registro es `sealed`, no se agregan modificadores adicionales al método "clone" (lo que significa que no es `virtual`).</span><span class="sxs-lookup"><span data-stu-id="c80f8-179">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="c80f8-180">Si el registro no es `sealed`, el método "clone" es `virtual`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-180">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="c80f8-181">Para los tipos de registro que no son `abstract` cuando el tipo base no es `object`:</span><span class="sxs-lookup"><span data-stu-id="c80f8-181">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="c80f8-182">Si el registro es `sealed`, el método "clone" también es `sealed`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-182">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="c80f8-183">Si el registro no es `sealed`, el método "clone" es `override`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-183">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="c80f8-184">El resultado de todas estas reglas es que la igualdad se implementa de forma coherente en cualquier jerarquía de tipos de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-184">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="c80f8-185">Dos registros son iguales entre ellos si sus propiedades son iguales y sus tipos son los mismos, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c80f8-185">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="c80f8-186">El compilador sintetiza dos métodos que admiten la salida impresa: una invalidación de <xref:System.Object.ToString> y `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-186">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="c80f8-187">`PrintMembers` toma <xref:System.Text.StringBuilder?displayProperty=nameWithType> como argumento.</span><span class="sxs-lookup"><span data-stu-id="c80f8-187">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="c80f8-188">Anexa una lista separada por comas de nombres de propiedad y valores para todas las propiedades del tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-188">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="c80f8-189">`PrintMembers` llama a la implementación base de cualquier registro derivado de otros registros.</span><span class="sxs-lookup"><span data-stu-id="c80f8-189">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="c80f8-190">La invalidación de <xref:System.Object.ToString> devuelve la cadena generada por `PrintMembers`, incluida entre `{` y `}`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-190">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="c80f8-191">Por ejemplo, el método <xref:System.Object.ToString> de `Student` devuelve un objeto `string` como en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="c80f8-191">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="c80f8-192">En los ejemplos mostrados hasta ahora se usa la sintaxis tradicional para declarar propiedades.</span><span class="sxs-lookup"><span data-stu-id="c80f8-192">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="c80f8-193">Hay una forma más concisa denominada _*_registros posicionales_*_ .</span><span class="sxs-lookup"><span data-stu-id="c80f8-193">There's a more concise form called _*_positional records_*_ .</span></span>  <span data-ttu-id="c80f8-194">Estos son los tres tipos de registro definidos anteriormente como registros posicionales:</span><span class="sxs-lookup"><span data-stu-id="c80f8-194">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="c80f8-195">Estas declaraciones crean la misma funcionalidad que la versión anterior (con un par de características adicionales que se describen en la sección siguiente).</span><span class="sxs-lookup"><span data-stu-id="c80f8-195">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="c80f8-196">Estas declaraciones finalizan con un punto y coma en lugar de corchetes, porque estos registros no agregan métodos adicionales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-196">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="c80f8-197">Puede agregar un cuerpo e incluir también otros métodos adicionales:</span><span class="sxs-lookup"><span data-stu-id="c80f8-197">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="c80f8-198">El compilador genera un método `Deconstruct` para los registros posicionales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-198">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="c80f8-199">El método `Deconstruct` tiene parámetros que coinciden con los nombres de todas las propiedades públicas del tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-199">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="c80f8-200">El método `Deconstruct` se puede usar para deconstruir el registro en sus propiedades de componente:</span><span class="sxs-lookup"><span data-stu-id="c80f8-200">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="c80f8-201">Por último, los registros admiten _*_expresiones with_*_ .</span><span class="sxs-lookup"><span data-stu-id="c80f8-201">Finally, records support _*_with-expressions_*_ .</span></span> <span data-ttu-id="c80f8-202">Una _*_expresión with_*_ indica al compilador que cree una copia de un registro, pero con propiedades especificadas modificadas:</span><span class="sxs-lookup"><span data-stu-id="c80f8-202">A _*_with-expression_*_ instructs the compiler to create a copy of a record, but _with\* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="c80f8-203">La línea anterior crea un registro `Person` en el que la propiedad `LastName` es una copia de `person` y el valor `FirstName` es "Paul".</span><span class="sxs-lookup"><span data-stu-id="c80f8-203">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="c80f8-204">Puede establecer cualquier número de propiedades en una expresión with.</span><span class="sxs-lookup"><span data-stu-id="c80f8-204">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="c80f8-205">El usuario puede escribir cualquiera de los miembros sintetizados excepto el método "clone".</span><span class="sxs-lookup"><span data-stu-id="c80f8-205">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="c80f8-206">Si un tipo de registro tiene un método que coincide con la signatura de cualquier método sintetizado, el compilador no sintetiza ese método.</span><span class="sxs-lookup"><span data-stu-id="c80f8-206">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="c80f8-207">El ejemplo de registro `Dog` anterior contiene un método <xref:System.String.ToString> codificado a mano como ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c80f8-207">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="c80f8-208">Establecedores de solo inicialización</span><span class="sxs-lookup"><span data-stu-id="c80f8-208">Init only setters</span></span>

<span data-ttu-id="c80f8-209">Los \***establecedores de solo inicialización** proporcionan una sintaxis coherente para inicializar miembros de un objeto.</span><span class="sxs-lookup"><span data-stu-id="c80f8-209">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="c80f8-210">Los inicializadores de propiedades indican con claridad qué valor establece cada propiedad.</span><span class="sxs-lookup"><span data-stu-id="c80f8-210">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="c80f8-211">El inconveniente es que esas propiedades se deben establecer.</span><span class="sxs-lookup"><span data-stu-id="c80f8-211">The downside is that those properties must be settable.</span></span> <span data-ttu-id="c80f8-212">A partir de C# 9.0, puede crear descriptores de acceso `init` en lugar de descriptores de acceso `set` para propiedades e indizadores.</span><span class="sxs-lookup"><span data-stu-id="c80f8-212">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="c80f8-213">Los autores de la llamada pueden usar la sintaxis de inicializador de propiedad para establecer estos valores en expresiones de creación, pero esas propiedades son de solo lectura una vez que se ha completado la construcción.</span><span class="sxs-lookup"><span data-stu-id="c80f8-213">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="c80f8-214">Los establecedores de solo inicialización proporcionan una ventana para cambiar el estado,</span><span class="sxs-lookup"><span data-stu-id="c80f8-214">Init only setters provide a window to change state.</span></span> <span data-ttu-id="c80f8-215">que se cierra cuando finaliza la fase de construcción.</span><span class="sxs-lookup"><span data-stu-id="c80f8-215">That window closes when the construction phase ends.</span></span> <span data-ttu-id="c80f8-216">La fase de construcción finaliza de forma eficaz después de que se complete toda la inicialización, incluidos los inicializadores de propiedades y las expresiones with.</span><span class="sxs-lookup"><span data-stu-id="c80f8-216">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="c80f8-217">Puede declarar los establecedores de solo `init` en cualquier tipo que escriba.</span><span class="sxs-lookup"><span data-stu-id="c80f8-217">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="c80f8-218">Por ejemplo, en la estructura siguiente se define una estructura de observación meteorológica:</span><span class="sxs-lookup"><span data-stu-id="c80f8-218">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="c80f8-219">Los autores de la llamada pueden usar la sintaxis de inicializador de propiedades para establecer los valores, a la vez que conservan la inmutabilidad:</span><span class="sxs-lookup"><span data-stu-id="c80f8-219">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="c80f8-220">Pero el cambio de una observación después de la inicialización es un error mediante la asignación a una propiedad de solo inicialización fuera de la inicialización:</span><span class="sxs-lookup"><span data-stu-id="c80f8-220">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="c80f8-221">Los establecedores de solo inicialización pueden ser útiles para establecer las propiedades de clase base de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="c80f8-221">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="c80f8-222">También pueden establecer propiedades derivadas mediante asistentes en una clase base.</span><span class="sxs-lookup"><span data-stu-id="c80f8-222">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="c80f8-223">Los registros posicionales declaran propiedades mediante establecedores de solo inicialización.</span><span class="sxs-lookup"><span data-stu-id="c80f8-223">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="c80f8-224">Esos establecedores se usan en expresiones with.</span><span class="sxs-lookup"><span data-stu-id="c80f8-224">Those setters are used in with-expressions.</span></span> <span data-ttu-id="c80f8-225">Puede declarar establecedores de solo inicialización para cualquier objeto `class` o `struct` que defina.</span><span class="sxs-lookup"><span data-stu-id="c80f8-225">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="c80f8-226">Instrucciones de nivel superior</span><span class="sxs-lookup"><span data-stu-id="c80f8-226">Top-level statements</span></span>

<span data-ttu-id="c80f8-227">Las _*_instrucciones de nivel superior_*_ quitan complejidad innecesaria de muchas aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="c80f8-227">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="c80f8-228">Considere el famoso programa</span><span class="sxs-lookup"><span data-stu-id="c80f8-228">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="c80f8-229">"Hola mundo":</span><span class="sxs-lookup"><span data-stu-id="c80f8-229">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="c80f8-230">Solo hay una línea de código que haga algo.</span><span class="sxs-lookup"><span data-stu-id="c80f8-230">There’s only one line of code that does anything.</span></span> <span data-ttu-id="c80f8-231">Con las instrucciones de nivel superior, puede reemplazar todo lo que sea reutilizable por la instrucción `using` y la línea única que realiza el trabajo:</span><span class="sxs-lookup"><span data-stu-id="c80f8-231">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="c80f8-232">Si quisiera un programa de una línea, podría quitar la directiva `using` y usar el nombre de tipo completo:</span><span class="sxs-lookup"><span data-stu-id="c80f8-232">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="c80f8-233">Solo un archivo de la aplicación puede usar instrucciones de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="c80f8-233">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="c80f8-234">Si el compilador encuentra instrucciones de nivel superior en varios archivos de código fuente, se trata de un error.</span><span class="sxs-lookup"><span data-stu-id="c80f8-234">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="c80f8-235">También es un error si combina instrucciones de nivel superior con un método de punto de entrada de programa declarado, normalmente `Main`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-235">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="c80f8-236">En cierto sentido, puede pensar que un archivo contiene las instrucciones que normalmente se encontrarían en el método `Main` de una clase `Program`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-236">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="c80f8-237">Uno de los usos más comunes de esta característica es la creación de materiales educativos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-237">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="c80f8-238">Los desarrolladores principiantes de C# pueden escribir el programa "Hola mundo"</span><span class="sxs-lookup"><span data-stu-id="c80f8-238">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="c80f8-239">en una o dos líneas de código.</span><span class="sxs-lookup"><span data-stu-id="c80f8-239">in one or two lines of code.</span></span> <span data-ttu-id="c80f8-240">No se necesitan pasos adicionales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-240">None of the extra ceremony is needed.</span></span> <span data-ttu-id="c80f8-241">Pero los desarrolladores veteranos también encontrarán muchas aplicaciones a esta característica.</span><span class="sxs-lookup"><span data-stu-id="c80f8-241">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="c80f8-242">Las instrucciones de nivel superior permiten una experiencia de experimentación de tipo script similar a la que proporcionan los cuadernos de Jupyter Notebook.</span><span class="sxs-lookup"><span data-stu-id="c80f8-242">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="c80f8-243">Las instrucciones de nivel superior son excelentes para programas y utilidades de consola pequeños.</span><span class="sxs-lookup"><span data-stu-id="c80f8-243">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="c80f8-244">Azure Functions es un caso de uso ideal para las instrucciones de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="c80f8-244">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="c80f8-245">Y sobre todo, las instrucciones de nivel superior no limitan el ámbito ni la complejidad de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-245">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="c80f8-246">Estas instrucciones pueden acceder a cualquier clase de .NET o usarla.</span><span class="sxs-lookup"><span data-stu-id="c80f8-246">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="c80f8-247">Tampoco limitan el uso de argumentos de línea de comandos ni de valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-247">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="c80f8-248">Las instrucciones de nivel superior pueden acceder a una matriz de cadenas denominada args.</span><span class="sxs-lookup"><span data-stu-id="c80f8-248">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="c80f8-249">Si las instrucciones de nivel superior devuelven un valor entero, ese valor se convierte en el código devuelto entero de un método `Main` sintetizado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-249">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="c80f8-250">Las instrucciones de nivel superior pueden contener expresiones asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="c80f8-250">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="c80f8-251">En ese caso, el punto de entrada sintetizado devuelve un objeto `Task`, o `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-251">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="c80f8-252">Mejoras de coincidencia de patrones</span><span class="sxs-lookup"><span data-stu-id="c80f8-252">Pattern matching enhancements</span></span>

<span data-ttu-id="c80f8-253">C# 9 incluye nuevas mejoras de coincidencia de patrones:</span><span class="sxs-lookup"><span data-stu-id="c80f8-253">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="c80f8-254">Los _*_patrones de tipo_*_ comprueban si una variable es un tipo</span><span class="sxs-lookup"><span data-stu-id="c80f8-254">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="c80f8-255">Los _*_patrones entre paréntesis_*_ aplican o resaltan la prioridad de las combinaciones de patrones</span><span class="sxs-lookup"><span data-stu-id="c80f8-255">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="c80f8-256">En los _*_patrones `and` conjuntivos_*_ es necesario que los dos patrones coincidan</span><span class="sxs-lookup"><span data-stu-id="c80f8-256">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="c80f8-257">En los _*_patrones `or` disyuntivos_*_ es necesario que alguno de los dos patrones coincida</span><span class="sxs-lookup"><span data-stu-id="c80f8-257">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="c80f8-258">En los _*_patrones `not` negados_*_ es necesario que un patrón no coincida</span><span class="sxs-lookup"><span data-stu-id="c80f8-258">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="c80f8-259">Los _*_patrones relacionales_*_ requieren que la entrada sea menor que, mayor que, menor o igual que, o mayor o igual que una constante determinada.</span><span class="sxs-lookup"><span data-stu-id="c80f8-259">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="c80f8-260">Estos patrones enriquecen la sintaxis de los patrones.</span><span class="sxs-lookup"><span data-stu-id="c80f8-260">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="c80f8-261">Tenga en cuenta estos ejemplos:</span><span class="sxs-lookup"><span data-stu-id="c80f8-261">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="c80f8-262">Como alternativa, con paréntesis opcionales para que quede claro que `and` tiene mayor precedencia que `or`:</span><span class="sxs-lookup"><span data-stu-id="c80f8-262">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="c80f8-263">Uno de los usos más comunes es una nueva sintaxis para una comprobación NULL:</span><span class="sxs-lookup"><span data-stu-id="c80f8-263">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="c80f8-264">Cualquiera de estos patrones se puede usar en cualquier contexto en el que se permitan patrones: expresiones de patrón `is`, expresiones `switch`, modelos anidados y el patrón de la etiqueta `case` de una instrucción `switch`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-264">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="c80f8-265">Rendimiento e interoperabilidad</span><span class="sxs-lookup"><span data-stu-id="c80f8-265">Performance and interop</span></span>

<span data-ttu-id="c80f8-266">Tres nuevas características mejoran la compatibilidad con la interoperabilidad nativa y las bibliotecas de bajo nivel que requieren alto rendimiento: enteros de tamaño nativo, punteros de función y la omisión de la marca `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-266">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="c80f8-267">Los enteros de tamaño nativo, `nint` y `nuint`, son tipos enteros.</span><span class="sxs-lookup"><span data-stu-id="c80f8-267">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="c80f8-268">Se expresan mediante los tipos subyacentes <xref:System.IntPtr?displayProperty=nameWithType> y <xref:System.UIntPtr?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c80f8-268">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c80f8-269">El compilador muestra las conversiones y operaciones adicionales para estos tipos como enteros nativos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-269">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="c80f8-270">Los enteros con tamaño nativo definen propiedades para `MaxValue` o `MinValue`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-270">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="c80f8-271">Estos valores no se pueden expresar como constantes en tiempo de compilación porque dependen del tamaño nativo de un entero en el equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="c80f8-271">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="c80f8-272">Estos valores son de solo lectura en el entorno de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c80f8-272">Those values are readonly at runtime.</span></span> <span data-ttu-id="c80f8-273">Puede usar valores constantes para `nint` en el intervalo [`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="c80f8-273">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="c80f8-274">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="c80f8-274">`int.MaxValue`].</span></span> <span data-ttu-id="c80f8-275">Puede usar valores constantes para `nuint` en el intervalo [`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="c80f8-275">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="c80f8-276">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="c80f8-276">`uint.MaxValue`].</span></span> <span data-ttu-id="c80f8-277">El compilador realiza un plegamiento constante para todos los operadores unarios y binarios que usan los tipos <xref:System.Int32?displayProperty=nameWithType> y <xref:System.UInt32?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c80f8-277">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="c80f8-278">Si el resultado no cabe en 32 bits, la operación se ejecuta en tiempo de ejecución y no se considera una constante.</span><span class="sxs-lookup"><span data-stu-id="c80f8-278">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="c80f8-279">Los enteros con tamaño nativo pueden aumentar el rendimiento en escenarios en los que se usa la aritmética de enteros y es necesario tener el rendimiento más rápido posible.</span><span class="sxs-lookup"><span data-stu-id="c80f8-279">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="c80f8-280">Los punteros de función proporcionan una sintaxis sencilla para acceder a los códigos de operación de lenguaje intermedio `ldftn` y `calli`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-280">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="c80f8-281">Puede declarar punteros de función con la nueva sintaxis de `delegate_`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-281">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="c80f8-282">Un tipo `delegate*` es un tipo de puntero.</span><span class="sxs-lookup"><span data-stu-id="c80f8-282">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="c80f8-283">Al invocar el tipo `delegate*` se usa `calli`, a diferencia de un delegado que usa `callvirt` en el método `Invoke()`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-283">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="c80f8-284">Sintácticamente, las invocaciones son idénticas.</span><span class="sxs-lookup"><span data-stu-id="c80f8-284">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="c80f8-285">La invocación del puntero de función usa la convención de llamada `managed`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-285">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="c80f8-286">Agregue la palabra clave `unmanaged` después de la sintaxis de `delegate*` para declarar que quiere la convención de llamada `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-286">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="c80f8-287">Se pueden especificar otras convenciones de llamada mediante atributos en la declaración de `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-287">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="c80f8-288">Por último, puede agregar <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> para indicar al compilador que no emita la marca `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-288">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="c80f8-289">Esta marca indica al CLR que inicialice en cero todas las variables locales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-289">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="c80f8-290">La marca `localsinit` ha sido el comportamiento predeterminado en C# desde la versión 1.0.</span><span class="sxs-lookup"><span data-stu-id="c80f8-290">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="c80f8-291">Pero la inicialización en cero adicional puede afectar al rendimiento en algunos escenarios.</span><span class="sxs-lookup"><span data-stu-id="c80f8-291">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="c80f8-292">En concreto, cuando se usa `stackalloc`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-292">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="c80f8-293">En esos casos, puede agregar <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c80f8-293">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="c80f8-294">Puede agregarlo a un único método o propiedad, a un objeto `class`, `struct`, `interface`, o incluso a un módulo.</span><span class="sxs-lookup"><span data-stu-id="c80f8-294">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="c80f8-295">Este atributo no afecta a los métodos `abstract`; afecta al código generado para la implementación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-295">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="c80f8-296">Estas características pueden aumentar significativamente el rendimiento en algunos escenarios.</span><span class="sxs-lookup"><span data-stu-id="c80f8-296">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="c80f8-297">Solo se deben usar después de realizar pruebas comparativas minuciosamente antes y después de la adopción.</span><span class="sxs-lookup"><span data-stu-id="c80f8-297">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="c80f8-298">El código que implica enteros con tamaño nativo se debe probar en varias plataformas de destino con distintos tamaños de enteros.</span><span class="sxs-lookup"><span data-stu-id="c80f8-298">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="c80f8-299">Las demás características requieren código no seguro.</span><span class="sxs-lookup"><span data-stu-id="c80f8-299">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="c80f8-300">Características de ajuste y finalización</span><span class="sxs-lookup"><span data-stu-id="c80f8-300">Fit and finish features</span></span>

<span data-ttu-id="c80f8-301">Muchas de las características restantes ayudan a escribir código de forma más eficaz.</span><span class="sxs-lookup"><span data-stu-id="c80f8-301">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="c80f8-302">En C# 9.0, puede omitir el tipo de una [expresión `new`](../language-reference/operators/new-operator.md) cuando ya se conoce el tipo del objeto creado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-302">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="c80f8-303">El uso más común es en las declaraciones de campo:</span><span class="sxs-lookup"><span data-stu-id="c80f8-303">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="c80f8-304">El tipo de destino `new` también se puede usar cuando es necesario crear un objeto para pasarlo como argumento a un método.</span><span class="sxs-lookup"><span data-stu-id="c80f8-304">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="c80f8-305">Considere un método `ForecastFor()` con la signatura siguiente:</span><span class="sxs-lookup"><span data-stu-id="c80f8-305">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="c80f8-306">Podría llamarlo de esta forma:</span><span class="sxs-lookup"><span data-stu-id="c80f8-306">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="c80f8-307">Otra aplicación muy útil de esta característica es para combinarla con propiedades de solo inicialización para inicializar un objeto nuevo:</span><span class="sxs-lookup"><span data-stu-id="c80f8-307">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="c80f8-308">Puede devolver una instancia creada por el constructor predeterminado mediante una declaración `return new();`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-308">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="c80f8-309">Una característica similar mejora la resolución de tipos de destino de las [expresiones condicionales](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-309">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="c80f8-310">Con este cambio, las dos expresiones no necesitan tener una conversión implícita de una a otra, pero pueden tener conversiones implícitas a un tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="c80f8-310">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="c80f8-311">Lo más probable es que no note este cambio.</span><span class="sxs-lookup"><span data-stu-id="c80f8-311">You likely won’t notice this change.</span></span> <span data-ttu-id="c80f8-312">Lo que observará es que ahora funcionan algunas expresiones condicionales para las que anteriormente se necesitan conversiones o que no se compilaban.</span><span class="sxs-lookup"><span data-stu-id="c80f8-312">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="c80f8-313">A partir de C# 9.0, puede agregar el modificador `static` a [expresiones lambda](../language-reference/operators/lambda-expressions.md) o [métodos anónimos](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-313">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="c80f8-314">Las expresiones lambda estáticas son análogas a las funciones `static` locales: un método anónimo o una expresión lambda estáticos no puede capturar variables locales ni el estado de la instancia.</span><span class="sxs-lookup"><span data-stu-id="c80f8-314">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="c80f8-315">El modificador `static` impide la captura accidental de otras variables.</span><span class="sxs-lookup"><span data-stu-id="c80f8-315">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="c80f8-316">Los tipos de valor devuelto covariantes proporcionan flexibilidad a los tipos de valor devuelto de los métodos [override](../language-reference/keywords/override.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-316">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="c80f8-317">Un método override puede devolver un tipo derivado del tipo de valor devuelto del método base invalidado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-317">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="c80f8-318">Esto puede ser útil para los registros y para otros tipos que admiten métodos de generador o clonación virtuales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-318">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="c80f8-319">Además, el bucle [`foreach` ](../language-reference/keywords/foreach-in.md) reconocerá y usará un método de extensión `GetEnumerator` que, de otro modo, satisface el patrón `foreach`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-319">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="c80f8-320">Este cambio significa que `foreach` es coherente con otras construcciones basadas en patrones, como el patrón asincrónico y la desconstrucción basada en patrones.</span><span class="sxs-lookup"><span data-stu-id="c80f8-320">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="c80f8-321">En la práctica, esto quiere decir que puede agregar compatibilidad con `foreach` a cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="c80f8-321">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="c80f8-322">Debe limitar su uso a cuando la enumeración de un objeto tiene sentido en el diseño.</span><span class="sxs-lookup"><span data-stu-id="c80f8-322">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="c80f8-323">Después, puede usar descartes como parámetros para las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="c80f8-323">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="c80f8-324">De esta forma no tiene que asignar un nombre al argumento y el compilador puede evitar usarlo.</span><span class="sxs-lookup"><span data-stu-id="c80f8-324">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="c80f8-325">Use `_` para cualquier argumento.</span><span class="sxs-lookup"><span data-stu-id="c80f8-325">You use the `_` for any argument.</span></span> <span data-ttu-id="c80f8-326">Para más información, consulte sección sobre [parámetros de entrada de una expresión lambda](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) en el artículo sobre [expresiones lambda](../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-326">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="c80f8-327">Por último, ahora puede aplicar atributos a las [funciones locales](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="c80f8-327">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="c80f8-328">Por ejemplo, puede aplicar [anotaciones de atributo que admiten un valor NULL](../language-reference/attributes/nullable-analysis.md) a las funciones locales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-328">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="c80f8-329">Compatibilidad con generadores de código</span><span class="sxs-lookup"><span data-stu-id="c80f8-329">Support for code generators</span></span>

<span data-ttu-id="c80f8-330">Dos últimas características admiten generadores de código de C#.</span><span class="sxs-lookup"><span data-stu-id="c80f8-330">Two final features support C# code generators.</span></span> <span data-ttu-id="c80f8-331">Los generadores de código de C# son un componente que se puede escribir y que es similar a una corrección de código o un analizador Roslyn.</span><span class="sxs-lookup"><span data-stu-id="c80f8-331">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="c80f8-332">La diferencia es que los generadores de código analizan el código y escriben nuevos archivos de código fuente como parte del proceso de compilación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-332">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="c80f8-333">Un generador de código típico busca atributos y otras convenciones en el código.</span><span class="sxs-lookup"><span data-stu-id="c80f8-333">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="c80f8-334">Un generador de código lee atributos u otros elementos de código mediante las API de análisis de Roslyn.</span><span class="sxs-lookup"><span data-stu-id="c80f8-334">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="c80f8-335">A partir de esa información, agrega código nuevo a la compilación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-335">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="c80f8-336">Los generadores de código fuente solo pueden agregar código; no se les permite modificar ningún código existente en la compilación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-336">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="c80f8-337">Las dos características agregadas a los generadores de código son las extensiones de la **sintaxis de métodos parciales** y los _*_inicializadores de módulos_*_ .</span><span class="sxs-lookup"><span data-stu-id="c80f8-337">The two features added for code generators are extensions to \* **partial method syntax** _, and _*_module initializers_*_ .</span></span> <span data-ttu-id="c80f8-338">En primer lugar, los cambios en los métodos parciales.</span><span class="sxs-lookup"><span data-stu-id="c80f8-338">First, the changes to partial methods.</span></span> <span data-ttu-id="c80f8-339">Antes de C# 9.0, los métodos parciales eran `private`, pero no podían especificar un modificador de acceso, tener un valor devuelto `void` ni parámetros `out`.</span><span class="sxs-lookup"><span data-stu-id="c80f8-339">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="c80f8-340">Estas restricciones implican que si no se proporciona ninguna implementación de método, el compilador quita todas las llamadas al método parcial.</span><span class="sxs-lookup"><span data-stu-id="c80f8-340">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="c80f8-341">En C# 9.0 se quitan estas restricciones, pero es necesario que las declaraciones de métodos parciales tengan una implementación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-341">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="c80f8-342">Los generadores de código pueden proporcionar esa implementación.</span><span class="sxs-lookup"><span data-stu-id="c80f8-342">Code generators can provide that implementation.</span></span> <span data-ttu-id="c80f8-343">Para evitar la introducción de un cambio importante, el compilador tiene en cuenta cualquier método parcial sin un modificador de acceso para seguir las reglas anteriores.</span><span class="sxs-lookup"><span data-stu-id="c80f8-343">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="c80f8-344">Si el método parcial incluye el modificador de acceso `private`, las nuevas reglas rigen ese método parcial.</span><span class="sxs-lookup"><span data-stu-id="c80f8-344">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="c80f8-345">La segunda característica nueva de los generadores de código son los _inicializadores de módulos_ .</span><span class="sxs-lookup"><span data-stu-id="c80f8-345">The second new feature for code generators is _\* _module initializers_ \*\*.</span></span> <span data-ttu-id="c80f8-346">Los inicializadores de módulos son métodos que tienen asociado el atributo <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c80f8-346">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="c80f8-347">El tiempo de ejecución llamará a estos métodos cuando se cargue el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c80f8-347">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="c80f8-348">Un método de inicializador de módulo:</span><span class="sxs-lookup"><span data-stu-id="c80f8-348">A module initializer method:</span></span>

- <span data-ttu-id="c80f8-349">Debe ser estático</span><span class="sxs-lookup"><span data-stu-id="c80f8-349">Must be static</span></span>
- <span data-ttu-id="c80f8-350">No debe tener parámetros</span><span class="sxs-lookup"><span data-stu-id="c80f8-350">Must be parameterless</span></span>
- <span data-ttu-id="c80f8-351">Debe devolver void</span><span class="sxs-lookup"><span data-stu-id="c80f8-351">Must return void</span></span>
- <span data-ttu-id="c80f8-352">No debe ser un método genérico</span><span class="sxs-lookup"><span data-stu-id="c80f8-352">Must not be a generic method</span></span>
- <span data-ttu-id="c80f8-353">No debe estar incluido en una clase genérica</span><span class="sxs-lookup"><span data-stu-id="c80f8-353">Must not be contained in a generic class</span></span>
- <span data-ttu-id="c80f8-354">Debe ser accesible desde el módulo contenedor</span><span class="sxs-lookup"><span data-stu-id="c80f8-354">Must be accessible from the containing module</span></span>

<span data-ttu-id="c80f8-355">Ese último punto significa en realidad que el método y su clase contenedora deben ser internos o públicos.</span><span class="sxs-lookup"><span data-stu-id="c80f8-355">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="c80f8-356">El método no puede ser una función local.</span><span class="sxs-lookup"><span data-stu-id="c80f8-356">The method can't be a local function.</span></span>
