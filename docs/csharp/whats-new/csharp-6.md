---
title: Novedades de C# 6 - Guía de C#
description: Obtenga información sobre las nuevas características de la versión 6 de C#
ms.date: 12/12/2018
ms.openlocfilehash: da40b4c9d4af0094fdd907c542e971ba55086e0f
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/20/2020
ms.locfileid: "92224238"
---
# <a name="whats-new-in-c-6"></a><span data-ttu-id="97fa0-103">Novedades de C# 6</span><span class="sxs-lookup"><span data-stu-id="97fa0-103">What's New in C# 6</span></span>

<span data-ttu-id="97fa0-104">La versión 6.0 de C# incluye muchas características que mejoran la productividad para los desarrolladores.</span><span class="sxs-lookup"><span data-stu-id="97fa0-104">The 6.0 release of C# contained many features that improve productivity for developers.</span></span> <span data-ttu-id="97fa0-105">El efecto general de estas características es que se escribe código más conciso y legible.</span><span class="sxs-lookup"><span data-stu-id="97fa0-105">The overall effect of these features is that you write more concise code that is also more readable.</span></span> <span data-ttu-id="97fa0-106">La sintaxis contiene menos complejidad para muchas de las prácticas habituales.</span><span class="sxs-lookup"><span data-stu-id="97fa0-106">The syntax contains less ceremony for many common practices.</span></span> <span data-ttu-id="97fa0-107">Es más fácil ver la intención del diseño con menos complejidad.</span><span class="sxs-lookup"><span data-stu-id="97fa0-107">It's easier to see the design intent with less ceremony.</span></span> <span data-ttu-id="97fa0-108">Si conoce bien estas características, podrá mejorar la productividad y escribir código más legible.</span><span class="sxs-lookup"><span data-stu-id="97fa0-108">Learn these features well, and you'll be more productive and write more readable code.</span></span> <span data-ttu-id="97fa0-109">Puede concentrarse más en las características que en las construcciones del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="97fa0-109">You can concentrate more on your features than on the constructs of the language.</span></span>

<span data-ttu-id="97fa0-110">El resto de este artículo proporciona información general de cada una de estas características, con un vínculo para examinar cada una.</span><span class="sxs-lookup"><span data-stu-id="97fa0-110">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span> <span data-ttu-id="97fa0-111">También puede examinar las características en una [exploración interactiva sobre C# 6](../tutorials/exploration/csharp-6.yml) en la sección de tutoriales.</span><span class="sxs-lookup"><span data-stu-id="97fa0-111">You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section.</span></span>

## <a name="read-only-auto-properties"></a><span data-ttu-id="97fa0-112">Propiedades automáticas de solo lectura</span><span class="sxs-lookup"><span data-stu-id="97fa0-112">Read-only auto-properties</span></span>

<span data-ttu-id="97fa0-113">*Las propiedades automáticas de solo lectura* proporcionan una sintaxis más concisa para crear tipos inmutables.</span><span class="sxs-lookup"><span data-stu-id="97fa0-113">*Read-only auto-properties* provide a more concise syntax to create immutable types.</span></span> <span data-ttu-id="97fa0-114">La propiedad automática se declara solo con un descriptor de acceso get:</span><span class="sxs-lookup"><span data-stu-id="97fa0-114">You declare the auto-property with only a get accessor:</span></span>

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

<span data-ttu-id="97fa0-115">Las propiedades `FirstName` y `LastName` solo se pueden establecer en el cuerpo del constructor de la misma clase:</span><span class="sxs-lookup"><span data-stu-id="97fa0-115">The `FirstName` and `LastName` properties can be set only in the body of the constructor of the same class:</span></span>

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

<span data-ttu-id="97fa0-116">Intentar establecer `LastName` en otro método genera un error de compilación `CS0200`:</span><span class="sxs-lookup"><span data-stu-id="97fa0-116">Trying to set `LastName` in another method generates a `CS0200` compilation error:</span></span>

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

<span data-ttu-id="97fa0-117">Esta característica habilita la compatibilidad de lenguaje real para crear tipos inmutables y usa la sintaxis de propiedades automáticas más concisa y cómoda.</span><span class="sxs-lookup"><span data-stu-id="97fa0-117">This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.</span></span>

<span data-ttu-id="97fa0-118">Si al agregar esta sintaxis no se quita un método accesible, se trata de un [cambio compatible con los elementos binarios](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="97fa0-118">If adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="auto-property-initializers"></a><span data-ttu-id="97fa0-119">Inicializadores de propiedades automáticas</span><span class="sxs-lookup"><span data-stu-id="97fa0-119">Auto-property initializers</span></span>

<span data-ttu-id="97fa0-120">Los *inicializadores de propiedades automáticas* permiten declarar el valor inicial de una propiedad automática como parte de la declaración de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="97fa0-120">*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration.</span></span>

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

<span data-ttu-id="97fa0-121">El miembro `Grades` se inicializa cuando se declara.</span><span class="sxs-lookup"><span data-stu-id="97fa0-121">The `Grades` member is initialized where it's declared.</span></span> <span data-ttu-id="97fa0-122">Eso hace que sea más fácil realizar la inicialización exactamente una sola vez.</span><span class="sxs-lookup"><span data-stu-id="97fa0-122">That makes it easier to perform the initialization exactly once.</span></span> <span data-ttu-id="97fa0-123">La inicialización es parte de la declaración de la propiedad, lo que facilita igualar la asignación de almacenamiento con la interfaz pública para objetos `Student`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-123">The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects.</span></span>

## <a name="expression-bodied-function-members"></a><span data-ttu-id="97fa0-124">Miembros de función con cuerpos de expresión</span><span class="sxs-lookup"><span data-stu-id="97fa0-124">Expression-bodied function members</span></span>

<span data-ttu-id="97fa0-125">Muchos de los miembros que se escriben son instrucciones únicas que podrían ser expresiones únicas.</span><span class="sxs-lookup"><span data-stu-id="97fa0-125">Many members that you write are single statements that could be single expressions.</span></span> <span data-ttu-id="97fa0-126">Escriba un miembro con forma de expresión en su lugar.</span><span class="sxs-lookup"><span data-stu-id="97fa0-126">Write an expression-bodied member instead.</span></span> <span data-ttu-id="97fa0-127">Funciona para métodos y propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="97fa0-127">It works for methods and read-only properties.</span></span> <span data-ttu-id="97fa0-128">Por ejemplo, un reemplazo de `ToString()` suele ser un excelente candidato:</span><span class="sxs-lookup"><span data-stu-id="97fa0-128">For example, an override of `ToString()` is often a great candidate:</span></span>

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

<span data-ttu-id="97fa0-129">También puede usar esta sintaxis para propiedades de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="97fa0-129">You can also use this syntax for read-only properties:</span></span>

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="97fa0-130">Cambiar un miembro existente por un miembro con cuerpo de expresión es un [cambio compatible con un elemento binario](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="97fa0-130">Changing an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="using-static"></a><span data-ttu-id="97fa0-131">uso de versión estática</span><span class="sxs-lookup"><span data-stu-id="97fa0-131">using static</span></span>

<span data-ttu-id="97fa0-132">La mejora *using static* permite importar los métodos estáticos de una sola clase.</span><span class="sxs-lookup"><span data-stu-id="97fa0-132">The *using static* enhancement enables you to import the static methods of a single class.</span></span> <span data-ttu-id="97fa0-133">Se especifica la clase que se está usando:</span><span class="sxs-lookup"><span data-stu-id="97fa0-133">You specify the class you're using:</span></span>

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

<span data-ttu-id="97fa0-134"><xref:System.Math> no contiene ningún método de instancia.</span><span class="sxs-lookup"><span data-stu-id="97fa0-134">The <xref:System.Math> does not contain any instance methods.</span></span> <span data-ttu-id="97fa0-135">También se puede usar `using static` para importar los métodos estáticos de una clase para una clase que tiene métodos estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="97fa0-135">You can also use `using static` to import a class' static methods for a class that has both static and instance methods.</span></span> <span data-ttu-id="97fa0-136">Uno de los ejemplos más útiles es <xref:System.String>:</span><span class="sxs-lookup"><span data-stu-id="97fa0-136">One of the most useful examples is <xref:System.String>:</span></span>

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> <span data-ttu-id="97fa0-137">Se debe usar el nombre de clase completo, `System.String`, en una instrucción using estática.</span><span class="sxs-lookup"><span data-stu-id="97fa0-137">You must use the fully qualified class name, `System.String`  in a static using statement.</span></span>  <span data-ttu-id="97fa0-138">No se puede usar la palabra clave `string` en su lugar.</span><span class="sxs-lookup"><span data-stu-id="97fa0-138">You cannot use the `string` keyword instead.</span></span>

<span data-ttu-id="97fa0-139">Al importar desde una instrucción `static using`, los métodos de extensión solo están en ámbito cuando se llaman mediante la sintaxis de invocación de métodos de extensión.</span><span class="sxs-lookup"><span data-stu-id="97fa0-139">When imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax.</span></span> <span data-ttu-id="97fa0-140">No están en ámbito cuando se llaman como métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="97fa0-140">They aren't in scope when called as a static method.</span></span> <span data-ttu-id="97fa0-141">A menudo verá esto en las consultas LINQ.</span><span class="sxs-lookup"><span data-stu-id="97fa0-141">You'll often see this in LINQ queries.</span></span> <span data-ttu-id="97fa0-142">Puede importar el modelo LINQ mediante la importación de <xref:System.Linq.Enumerable> o <xref:System.Linq.Queryable>.</span><span class="sxs-lookup"><span data-stu-id="97fa0-142">You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>.</span></span>

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

<span data-ttu-id="97fa0-143">Normalmente se llama a los métodos de extensión mediante expresiones de invocación de método de extensión.</span><span class="sxs-lookup"><span data-stu-id="97fa0-143">You typically call extension methods using extension method invocation expressions.</span></span> <span data-ttu-id="97fa0-144">La ambigüedad se resuelve al agregar el nombre de clase en el caso excepcional en que se llaman mediante una llamada de método estático.</span><span class="sxs-lookup"><span data-stu-id="97fa0-144">Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.</span></span>

<span data-ttu-id="97fa0-145">La directiva `static using` también importa cualquier tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="97fa0-145">The `static using` directive also imports any nested types.</span></span> <span data-ttu-id="97fa0-146">Es posible hacer referencia a los tipos anidados sin calificación.</span><span class="sxs-lookup"><span data-stu-id="97fa0-146">You can reference any nested types without qualification.</span></span>

## <a name="null-conditional-operators"></a><span data-ttu-id="97fa0-147">Operadores condicionales NULL</span><span class="sxs-lookup"><span data-stu-id="97fa0-147">Null-conditional operators</span></span>

<span data-ttu-id="97fa0-148">El *operador condicional NULL* realiza comprobaciones NULL de una forma mucho más sencilla y fluida.</span><span class="sxs-lookup"><span data-stu-id="97fa0-148">The *null conditional operator* makes null checks much easier and fluid.</span></span> <span data-ttu-id="97fa0-149">Reemplace el acceso a miembros `.` por `?.`:</span><span class="sxs-lookup"><span data-stu-id="97fa0-149">Replace the member access `.` with `?.`:</span></span>

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

<span data-ttu-id="97fa0-150">En el ejemplo anterior, se asigna `null` a la variable `first` si el objeto person es `null`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-150">In the preceding example, the variable `first` is assigned `null` if the person object is `null`.</span></span> <span data-ttu-id="97fa0-151">De lo contrario, se le asigna el valor de la propiedad `FirstName`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-151">Otherwise, it is assigned the value of the `FirstName` property.</span></span> <span data-ttu-id="97fa0-152">Y lo más importante es que `?.` significa que esta línea de código no genera una excepción `NullReferenceException` si la variable `person` es `null`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-152">Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`.</span></span> <span data-ttu-id="97fa0-153">En su lugar, se cortocircuita y devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-153">Instead, it short-circuits and returns `null`.</span></span> <span data-ttu-id="97fa0-154">También puede usar un operador condicional NULL para el acceso de matriz o indizador.</span><span class="sxs-lookup"><span data-stu-id="97fa0-154">You can also use a null conditional operator for array or indexer access.</span></span> <span data-ttu-id="97fa0-155">Reemplace `[]` por `?[]` en la expresión de índice.</span><span class="sxs-lookup"><span data-stu-id="97fa0-155">Replace `[]` with `?[]` in the index expression.</span></span>

<span data-ttu-id="97fa0-156">La siguiente expresión devuelve `string`, independientemente del valor de `person`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-156">The following expression returns a `string`, regardless of the value of `person`.</span></span> <span data-ttu-id="97fa0-157">A menudo se usa esta construcción con el operador de *fusión nula* para asignar valores predeterminados cuando una de las propiedades es `null`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-157">You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`.</span></span> <span data-ttu-id="97fa0-158">Si la expresión se cortocircuita, se asigna tipo al valor `null` devuelto para que coincida con la expresión completa.</span><span class="sxs-lookup"><span data-stu-id="97fa0-158">When the expression short-circuits, the `null` value returned is typed to match the full expression.</span></span>

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

<span data-ttu-id="97fa0-159">También se puede usar `?.` para invocar métodos de forma condicional.</span><span class="sxs-lookup"><span data-stu-id="97fa0-159">You can also use `?.` to conditionally invoke methods.</span></span> <span data-ttu-id="97fa0-160">El uso más común de las funciones miembro con el operador condicional NULL es invocar de forma segura delegados (o controladores de eventos) que puedan ser `null`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-160">The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`.</span></span>  <span data-ttu-id="97fa0-161">Se llama al método `Invoke` del delegado con el operador `?.` para acceder al miembro.</span><span class="sxs-lookup"><span data-stu-id="97fa0-161">You'll call the delegate's `Invoke` method using the `?.` operator to access the member.</span></span> <span data-ttu-id="97fa0-162">Puede ver un ejemplo en el artículo sobre [patrones de delegado](../delegates-patterns.md#handling-null-delegates).</span><span class="sxs-lookup"><span data-stu-id="97fa0-162">You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article.</span></span>

<span data-ttu-id="97fa0-163">Las reglas del operador `?.` garantizan que el lado izquierdo del operador solo se evalúa una vez.</span><span class="sxs-lookup"><span data-stu-id="97fa0-163">The rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once.</span></span> <span data-ttu-id="97fa0-164">Esto habilita muchos giros, incluido el ejemplo siguiente con controladores de eventos:</span><span class="sxs-lookup"><span data-stu-id="97fa0-164">It enables many idioms, including the following example using event handlers:</span></span>

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

<span data-ttu-id="97fa0-165">La garantía de que el lado izquierdo se evalúa solo una vez también permite usar cualquier expresión, incluidas llamadas a métodos, en el lado izquierdo de `?.`</span><span class="sxs-lookup"><span data-stu-id="97fa0-165">Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="97fa0-166">Interpolación de cadenas</span><span class="sxs-lookup"><span data-stu-id="97fa0-166">String interpolation</span></span>

<span data-ttu-id="97fa0-167">Con C# 6, la nueva característica de [interpolación de cadenas](../language-reference/tokens/interpolated.md) permite insertar expresiones en una cadena.</span><span class="sxs-lookup"><span data-stu-id="97fa0-167">With C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string.</span></span> <span data-ttu-id="97fa0-168">Solo hay que anteponer `$` a la cadena y usar expresiones entre `{` y `}` en lugar de ordinales:</span><span class="sxs-lookup"><span data-stu-id="97fa0-168">Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:</span></span>

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="97fa0-169">Este ejemplo usa propiedades para las expresiones sustituidas.</span><span class="sxs-lookup"><span data-stu-id="97fa0-169">This example uses properties for the substituted expressions.</span></span> <span data-ttu-id="97fa0-170">Se puede usar cualquier expresión.</span><span class="sxs-lookup"><span data-stu-id="97fa0-170">You can use any expression.</span></span> <span data-ttu-id="97fa0-171">Por ejemplo, se podría calcular la puntuación media de un alumno como parte de la interpolación:</span><span class="sxs-lookup"><span data-stu-id="97fa0-171">For example, you could compute a student's grade point average as part of the interpolation:</span></span>

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

<span data-ttu-id="97fa0-172">La línea de código anterior dará formato al valor de `Grades.Average()` como un número de punto flotante con dos posiciones decimales.</span><span class="sxs-lookup"><span data-stu-id="97fa0-172">The preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places.</span></span>

<span data-ttu-id="97fa0-173">A menudo puede ser necesario dar formato a la cadena generada con una referencia cultural concreta.</span><span class="sxs-lookup"><span data-stu-id="97fa0-173">Often, you may need to format the string produced using a specific culture.</span></span> <span data-ttu-id="97fa0-174">Se aprovecha el hecho de que el objeto generado por una interpolación de cadena puede convertirse implícitamente a <xref:System.FormattableString?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="97fa0-174">You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="97fa0-175">La instancia <xref:System.FormattableString> contiene la cadena de formato compuesta y los resultados de la evaluación de las expresiones antes de convertirlas en cadenas.</span><span class="sxs-lookup"><span data-stu-id="97fa0-175">The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.</span></span> <span data-ttu-id="97fa0-176">Use el método <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> para especificar la referencia cultural cuando de formato a una cadena.</span><span class="sxs-lookup"><span data-stu-id="97fa0-176">Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string.</span></span> <span data-ttu-id="97fa0-177">En el ejemplo siguiente se genera una cadena con la referencia cultural de alemán (de-DE).</span><span class="sxs-lookup"><span data-stu-id="97fa0-177">The following example produces a string using the German (de-DE) culture.</span></span> <span data-ttu-id="97fa0-178">(De forma predeterminada, la referencia cultural de alemán usa el carácter "," como separador de decimales y el carácter "." como separador de miles).</span><span class="sxs-lookup"><span data-stu-id="97fa0-178">(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)</span></span>

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = str.ToString(new System.Globalization.CultureInfo("de-DE"));
```

<span data-ttu-id="97fa0-179">Para empezar a trabajar con la interpolación de cadenas, vea el tutorial interactivo [Interpolación de cadenas en C#](../tutorials/exploration/interpolated-strings.yml), el artículo [Interpolación de cadenas](../language-reference/tokens/interpolated.md) y el tutorial [Interpolación de cadenas en C#](../tutorials/string-interpolation.md).</span><span class="sxs-lookup"><span data-stu-id="97fa0-179">To get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial.</span></span>

## <a name="exception-filters"></a><span data-ttu-id="97fa0-180">Filtros de excepciones</span><span class="sxs-lookup"><span data-stu-id="97fa0-180">Exception filters</span></span>

<span data-ttu-id="97fa0-181">Los *filtros de excepciones* son cláusulas que determinan cuándo se debe aplicar una cláusula catch determinada.</span><span class="sxs-lookup"><span data-stu-id="97fa0-181">*Exception Filters* are clauses that determine when a given catch clause should be applied.</span></span> <span data-ttu-id="97fa0-182">Si la expresión usada para un filtro de excepciones se evalúa como `true`, la cláusula catch realiza su procesamiento normal en una excepción.</span><span class="sxs-lookup"><span data-stu-id="97fa0-182">If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception.</span></span> <span data-ttu-id="97fa0-183">Si la expresión se evalúa como `false`, entonces se omite la cláusula `catch`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-183">If the expression evaluates to `false`, then the `catch` clause is skipped.</span></span> <span data-ttu-id="97fa0-184">Un uso consiste en examinar la información sobre una excepción para determinar si una cláusula `catch` puede procesar la excepción:</span><span class="sxs-lookup"><span data-stu-id="97fa0-184">One use is to examine information about an exception to determine if a `catch` clause can process the exception:</span></span>

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

## <a name="the-nameof-expression"></a><span data-ttu-id="97fa0-185">La expresión `nameof`</span><span class="sxs-lookup"><span data-stu-id="97fa0-185">The `nameof` expression</span></span>

<span data-ttu-id="97fa0-186">La expresión [nameof](../language-reference/operators/nameof.md) se evalúa como el nombre de un símbolo.</span><span class="sxs-lookup"><span data-stu-id="97fa0-186">The [nameof](../language-reference/operators/nameof.md) expression evaluates to the name of a symbol.</span></span> <span data-ttu-id="97fa0-187">Es una excelente manera de hacer que las herramientas funcionen siempre que se necesita el nombre de una variable, una propiedad o un campo de miembro.</span><span class="sxs-lookup"><span data-stu-id="97fa0-187">It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</span></span> <span data-ttu-id="97fa0-188">Uno de los usos más comunes de `nameof` es para proporcionar el nombre de un símbolo que produjo una excepción:</span><span class="sxs-lookup"><span data-stu-id="97fa0-188">One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:</span></span>

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

<span data-ttu-id="97fa0-189">Otro uso es con aplicaciones basadas en XAML que implementan la interfaz `INotifyPropertyChanged`:</span><span class="sxs-lookup"><span data-stu-id="97fa0-189">Another use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:</span></span>

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

## <a name="await-in-catch-and-finally-blocks"></a><span data-ttu-id="97fa0-190">Await en bloques Catch y Finally</span><span class="sxs-lookup"><span data-stu-id="97fa0-190">Await in Catch and Finally blocks</span></span>

<span data-ttu-id="97fa0-191">C# 5 tenía varias limitaciones en cuanto a dónde se podían colocar las expresiones `await`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-191">C# 5 had several limitations around where you could place `await` expressions.</span></span> <span data-ttu-id="97fa0-192">Con C# 6, ahora se puede usar `await` en expresiones `catch` o `finally`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-192">With C# 6, you can now use `await` in `catch` or `finally` expressions.</span></span> <span data-ttu-id="97fa0-193">Se suele usar principalmente con escenarios de registro:</span><span class="sxs-lookup"><span data-stu-id="97fa0-193">This is most often used with logging scenarios:</span></span>

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

<span data-ttu-id="97fa0-194">Los detalles de implementación para agregar compatibilidad con `await` dentro de cláusulas `catch` y `finally` garantizan que el comportamiento sea coherente con el comportamiento del código sincrónico.</span><span class="sxs-lookup"><span data-stu-id="97fa0-194">The implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code.</span></span> <span data-ttu-id="97fa0-195">Cuando el código que se ejecuta en una cláusula `catch` o `finally` produce una excepción, la ejecución busca una cláusula `catch` adecuada en el siguiente bloque adyacente.</span><span class="sxs-lookup"><span data-stu-id="97fa0-195">When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block.</span></span> <span data-ttu-id="97fa0-196">Si había una excepción actual, esa excepción se pierde.</span><span class="sxs-lookup"><span data-stu-id="97fa0-196">If there was a current exception, that exception is lost.</span></span> <span data-ttu-id="97fa0-197">Lo mismo sucede con las expresiones de await en cláusulas `catch` y `finally`: se busca una cláusula `catch` adecuada y se pierde la excepción actual, si existe.</span><span class="sxs-lookup"><span data-stu-id="97fa0-197">The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost.</span></span>  

> [!NOTE]
> <span data-ttu-id="97fa0-198">Este comportamiento es el motivo por el que se recomienda escribir cláusulas `catch` y `finally` con cuidado, para evitar la introducción de nuevas excepciones.</span><span class="sxs-lookup"><span data-stu-id="97fa0-198">This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.</span></span>

## <a name="initialize-associative-collections-using-indexers"></a><span data-ttu-id="97fa0-199">Inicialización de colecciones asociativas mediante indexadores</span><span class="sxs-lookup"><span data-stu-id="97fa0-199">Initialize associative collections using indexers</span></span>

<span data-ttu-id="97fa0-200">Los *inicializadores de índice* son una de las dos características que hacen que los inicializadores de colección sean más coherentes con el uso del índice.</span><span class="sxs-lookup"><span data-stu-id="97fa0-200">*Index Initializers* is one of two features that make collection initializers more consistent with index usage.</span></span> <span data-ttu-id="97fa0-201">En versiones anteriores de C#, se podían usar *inicializadores de colección* con colecciones de estilos de secuencia, incluido <xref:System.Collections.Generic.Dictionary%602>, al agregar llaves alrededor de los pares de clave y valor:</span><span class="sxs-lookup"><span data-stu-id="97fa0-201">In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:</span></span>

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]

<span data-ttu-id="97fa0-202">Puede usarlos con colecciones <xref:System.Collections.Generic.Dictionary%602> y otros tipos donde el método `Add` accesible acepte más de un argumento.</span><span class="sxs-lookup"><span data-stu-id="97fa0-202">You can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument.</span></span> <span data-ttu-id="97fa0-203">La nueva sintaxis admite la asignación con un índice en la colección:</span><span class="sxs-lookup"><span data-stu-id="97fa0-203">The new syntax supports assignment using an index into the collection:</span></span>

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

<span data-ttu-id="97fa0-204">Esta característica significa que los contenedores asociativos se pueden inicializar mediante una sintaxis similar a la que se lleva usando en varias versiones para los contenedores de secuencia.</span><span class="sxs-lookup"><span data-stu-id="97fa0-204">This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</span></span>

## <a name="extension-add-methods-in-collection-initializers"></a><span data-ttu-id="97fa0-205">Métodos `Add` de extensión para inicializadores de colección</span><span class="sxs-lookup"><span data-stu-id="97fa0-205">Extension `Add` methods in collection initializers</span></span>

<span data-ttu-id="97fa0-206">Otra característica que facilita la inicialización de colecciones es la capacidad de usar un *método de extensión* para el método `Add`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-206">Another feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method.</span></span> <span data-ttu-id="97fa0-207">Esta característica se agregó por motivos de paridad con Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="97fa0-207">This feature was added for parity with Visual Basic.</span></span> <span data-ttu-id="97fa0-208">La característica es más útil cuando se tiene una clase de colección personalizada que tiene un método con un nombre diferente para agregar nuevos elementos de forma semántica.</span><span class="sxs-lookup"><span data-stu-id="97fa0-208">The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</span></span>

## <a name="improved-overload-resolution"></a><span data-ttu-id="97fa0-209">Mejoras en la resolución de sobrecarga</span><span class="sxs-lookup"><span data-stu-id="97fa0-209">Improved overload resolution</span></span>

<span data-ttu-id="97fa0-210">Es probable que esta última característica no se aprecie.</span><span class="sxs-lookup"><span data-stu-id="97fa0-210">This last feature is one you probably won't notice.</span></span> <span data-ttu-id="97fa0-211">Había construcciones en las que la versión anterior del compilador de C# podía considerar ambiguas algunas llamadas a métodos con expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="97fa0-211">There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</span></span> <span data-ttu-id="97fa0-212">Considere este método:</span><span class="sxs-lookup"><span data-stu-id="97fa0-212">Consider this method:</span></span>

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

<span data-ttu-id="97fa0-213">En versiones anteriores de C#, la llamada a este método con la sintaxis de grupo de método produciría un error:</span><span class="sxs-lookup"><span data-stu-id="97fa0-213">In earlier versions of C#, calling that method using the method group syntax would fail:</span></span>

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]

<span data-ttu-id="97fa0-214">El compilador anterior no podía distinguir correctamente entre `Task.Run(Action)` y `Task.Run(Func<Task>())`.</span><span class="sxs-lookup"><span data-stu-id="97fa0-214">The earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`.</span></span> <span data-ttu-id="97fa0-215">En las versiones anteriores, era necesario usar una expresión lambda como argumento:</span><span class="sxs-lookup"><span data-stu-id="97fa0-215">In previous versions, you'd need to use a lambda expression as an argument:</span></span>

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

<span data-ttu-id="97fa0-216">El compilador de C# 6 determina correctamente que `Task.Run(Func<Task>())` es una opción mejor.</span><span class="sxs-lookup"><span data-stu-id="97fa0-216">The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice.</span></span>

### <a name="deterministic-compiler-output"></a><span data-ttu-id="97fa0-217">Resultado del compilador determinista</span><span class="sxs-lookup"><span data-stu-id="97fa0-217">Deterministic compiler output</span></span>

<span data-ttu-id="97fa0-218">La opción `-deterministic` indica al compilador que cree un ensamblado de salida idéntico byte a byte para las compilaciones sucesivas de los mismos archivos de código fuente.</span><span class="sxs-lookup"><span data-stu-id="97fa0-218">The `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.</span></span>

<span data-ttu-id="97fa0-219">De forma predeterminada, todas las compilaciones generan una salida única en cada compilación.</span><span class="sxs-lookup"><span data-stu-id="97fa0-219">By default, every compilation produces unique output on each compilation.</span></span> <span data-ttu-id="97fa0-220">El compilador agrega una marca de tiempo y genera un GUID a partir de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="97fa0-220">The compiler adds a timestamp, and a GUID generated from random numbers.</span></span> <span data-ttu-id="97fa0-221">Use esta opción si quiere comparar la salida byte a byte para garantizar la coherencia entre las compilaciones.</span><span class="sxs-lookup"><span data-stu-id="97fa0-221">You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.</span></span>

<span data-ttu-id="97fa0-222">Para obtener más información, vea el artículo [-deterministic (opción del compilador)](../language-reference/compiler-options/deterministic-compiler-option.md).</span><span class="sxs-lookup"><span data-stu-id="97fa0-222">For more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article.</span></span>
