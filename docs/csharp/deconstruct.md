---
title: Deconstruir tuplas y otros tipos
description: Obtenga información sobre cómo deconstruir tuplas y otros tipos.
ms.technology: csharp-fundamentals
ms.date: 11/23/2017
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 96168b729ae3ec11d7a38444b8c100bdbff4efbf
ms.sourcegitcommit: 30a686fd4377fe6472aa04e215c0de711bc1c322
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/10/2020
ms.locfileid: "94439708"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="caab4-103">Deconstruir tuplas y otros tipos</span><span class="sxs-lookup"><span data-stu-id="caab4-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="caab4-104">Una tupla proporciona una manera ligera de recuperar varios valores de una llamada de método.</span><span class="sxs-lookup"><span data-stu-id="caab4-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="caab4-105">Pero una vez que recupere la tupla, deberá controlar sus elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="caab4-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="caab4-106">Como se muestra en el ejemplo siguiente, es complicado hacerlo elemento a elemento.</span><span class="sxs-lookup"><span data-stu-id="caab4-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="caab4-107">El método `QueryCityData` devuelve una tupla de 3, y cada uno de sus elementos se asigna a una variable en una operación independiente.</span><span class="sxs-lookup"><span data-stu-id="caab4-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="caab4-108">También puede ser complicado recuperar varios valores de campo y propiedad de un objeto, ya que tendrá que asignar un valor de campo o propiedad a una variable miembro a miembro.</span><span class="sxs-lookup"><span data-stu-id="caab4-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="caab4-109">A partir de C# 7.0, puede recuperar varios elementos de una tupla o recuperar varios valores de campo, de propiedad y calculados de un objeto en una sola operación *deconstruct*.</span><span class="sxs-lookup"><span data-stu-id="caab4-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="caab4-110">Cuando se deconstruye una tupla, sus elementos se asignan a variables individuales.</span><span class="sxs-lookup"><span data-stu-id="caab4-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="caab4-111">Cuando se deconstruye un objeto, los valores seleccionados se asignan a variables individuales.</span><span class="sxs-lookup"><span data-stu-id="caab4-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="caab4-112">Deconstruir una tupla</span><span class="sxs-lookup"><span data-stu-id="caab4-112">Deconstructing a tuple</span></span>

<span data-ttu-id="caab4-113">C# incluye compatibilidad integrada para deconstruir tuplas, lo que permite desempaquetar todos los elementos de una tupla en una sola operación.</span><span class="sxs-lookup"><span data-stu-id="caab4-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="caab4-114">La sintaxis general para deconstruir una tupla es parecida a la sintaxis para definirla, ya que las variables a las que se va a asignar cada elemento se escriben entre paréntesis en el lado izquierdo de una instrucción de asignación.</span><span class="sxs-lookup"><span data-stu-id="caab4-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="caab4-115">Por ejemplo, la instrucción siguiente asigna los elementos de una tupla de 4 a cuatro variables independientes:</span><span class="sxs-lookup"><span data-stu-id="caab4-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="caab4-116">Hay tres formas de deconstruir una tupla:</span><span class="sxs-lookup"><span data-stu-id="caab4-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="caab4-117">Se puede declarar explícitamente el tipo de cada campo entre paréntesis.</span><span class="sxs-lookup"><span data-stu-id="caab4-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="caab4-118">En el ejemplo siguiente se usa este enfoque para deconstruir la tupla de 3 devuelta por el método `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="caab4-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="caab4-119">Puede usar la palabra clave `var` para que C# deduzca el tipo de cada variable.</span><span class="sxs-lookup"><span data-stu-id="caab4-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="caab4-120">Debe colocar la palabra clave `var` fuera de los paréntesis.</span><span class="sxs-lookup"><span data-stu-id="caab4-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="caab4-121">En el ejemplo siguiente se usa la inferencia de tipos al deconstruir la tupla de 3 devuelta por el método `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="caab4-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="caab4-122">También se puede usar la palabra clave `var` individualmente con alguna de las declaraciones de variable, o todas, dentro de los paréntesis.</span><span class="sxs-lookup"><span data-stu-id="caab4-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="caab4-123">Esto es complicado y no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="caab4-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="caab4-124">Por último, puede deconstruir la tupla en variables que ya se hayan declarado.</span><span class="sxs-lookup"><span data-stu-id="caab4-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="caab4-125">Tenga en cuenta que no se puede especificar un tipo determinado fuera de los paréntesis, aunque todos los campos de la tupla tengan el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="caab4-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="caab4-126">Esto genera el error del compilador CS8136: “El formato de desconstrucción ‘var (...)’ no permite especificar un tipo determinado para ‘var’”.</span><span class="sxs-lookup"><span data-stu-id="caab4-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="caab4-127">Tenga en cuenta que también debe asignar cada elemento de la tupla a una variable.</span><span class="sxs-lookup"><span data-stu-id="caab4-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="caab4-128">Si se omite algún elemento, el compilador genera el error CS8132: "No se puede deconstruir una tupla de 'x' elementos en 'y' variables".</span><span class="sxs-lookup"><span data-stu-id="caab4-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="caab4-129">Tenga en cuenta que no se pueden mezclar declaraciones y asignaciones en variables existentes en el lado izquierdo de una deconstrucción.</span><span class="sxs-lookup"><span data-stu-id="caab4-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="caab4-130">El compilador genera el error CS8184: "Una deconstrucción no puede mezclar declaraciones y expresiones en el lado izquierdo",</span><span class="sxs-lookup"><span data-stu-id="caab4-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="caab4-131">cuando los miembros incluyen variables existentes recién declaradas.</span><span class="sxs-lookup"><span data-stu-id="caab4-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="caab4-132">Deconstruir elementos de tupla con descartes</span><span class="sxs-lookup"><span data-stu-id="caab4-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="caab4-133">A menudo, cuando se deconstruye una tupla, solo interesan los valores de algunos elementos.</span><span class="sxs-lookup"><span data-stu-id="caab4-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="caab4-134">A partir de C# 7.0, puede aprovechar la compatibilidad de C# con los *descartes*, que son variables de solo escritura cuyos valores se decide omitir.</span><span class="sxs-lookup"><span data-stu-id="caab4-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="caab4-135">Los descartes suelen designarse mediante un carácter de guion bajo ("\_") en una asignación.</span><span class="sxs-lookup"><span data-stu-id="caab4-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="caab4-136">Puede descartar tantos valores como quiera; todos se representan mediante el descarte único `_`.</span><span class="sxs-lookup"><span data-stu-id="caab4-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="caab4-137">En el ejemplo siguiente se muestra el uso de tuplas con descartes.</span><span class="sxs-lookup"><span data-stu-id="caab4-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="caab4-138">El método `QueryCityDataForYears` devuelve una tupla de 6 con el nombre de una ciudad, su superficie, un año, la población de la ciudad en ese año, un segundo año y la población de la ciudad en ese segundo año.</span><span class="sxs-lookup"><span data-stu-id="caab4-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="caab4-139">En el ejemplo se muestra la evolución de la población entre esos dos años.</span><span class="sxs-lookup"><span data-stu-id="caab4-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="caab4-140">De los datos disponibles en la tupla, no nos interesa la superficie de la ciudad, y conocemos el nombre de la ciudad y las dos fechas en tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="caab4-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="caab4-141">Como resultado, solo nos interesan los dos valores de población almacenados en la tupla, y podemos controlar los valores restantes como descartes.</span><span class="sxs-lookup"><span data-stu-id="caab4-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="caab4-142">Deconstruir tipos definidos por el usuario</span><span class="sxs-lookup"><span data-stu-id="caab4-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="caab4-143">C# no ofrece compatibilidad integrada para deconstruir tipos que no son de tupla.</span><span class="sxs-lookup"><span data-stu-id="caab4-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="caab4-144">A pesar de ello, como autor de una clase, una estructura o una interfaz, puede permitir que las instancias del tipo se deconstruyan mediante la implementación de uno o varios métodos `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="caab4-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="caab4-145">El método no devuelve ningún valor, y cada valor que se va a deconstruir se indica mediante un parámetro [out](language-reference/keywords/out-parameter-modifier.md) en la firma del método.</span><span class="sxs-lookup"><span data-stu-id="caab4-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="caab4-146">Por ejemplo, el siguiente método `Deconstruct` de una clase `Person` devuelve el nombre de pila, el segundo nombre y los apellidos:</span><span class="sxs-lookup"><span data-stu-id="caab4-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="caab4-147">Después, puede deconstruir una instancia de la clase `Person` denominada `p` con una asignación similar a la siguiente:</span><span class="sxs-lookup"><span data-stu-id="caab4-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="caab4-148">En el ejemplo siguiente se sobrecarga el método `Deconstruct` para devolver varias combinaciones de las propiedades de un objeto `Person`.</span><span class="sxs-lookup"><span data-stu-id="caab4-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="caab4-149">Las sobrecargas individuales devuelven lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="caab4-149">Individual overloads return:</span></span>

- <span data-ttu-id="caab4-150">El nombre de pila y los apellidos.</span><span class="sxs-lookup"><span data-stu-id="caab4-150">A first and last name.</span></span>
- <span data-ttu-id="caab4-151">El nombre de pila, el segundo nombre y los apellidos.</span><span class="sxs-lookup"><span data-stu-id="caab4-151">A first, middle, and last name.</span></span>
- <span data-ttu-id="caab4-152">El nombre de pila, los apellidos, el nombre de la ciudad y el nombre del estado.</span><span class="sxs-lookup"><span data-stu-id="caab4-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="caab4-153">Dado que se puede sobrecargar el método `Deconstruct` para reflejar los grupos de datos que se suelen extraer de un objeto, debe tener cuidado y definir métodos `Deconstruct` con firmas que sean distintivas y no resulten ambiguas.</span><span class="sxs-lookup"><span data-stu-id="caab4-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="caab4-154">Puede resultar confuso usar varios métodos `Deconstruct` que tengan el mismo número de parámetros `out` o el mismo número y tipo de parámetros `out` en un orden diferente.</span><span class="sxs-lookup"><span data-stu-id="caab4-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="caab4-155">El método `Deconstruct` sobrecargado del ejemplo siguiente muestra un posible motivo de confusión.</span><span class="sxs-lookup"><span data-stu-id="caab4-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="caab4-156">La primera sobrecarga devuelve el nombre de pila, el segundo nombre, los apellidos y la edad de un objeto `Person`, en ese orden.</span><span class="sxs-lookup"><span data-stu-id="caab4-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="caab4-157">La segunda sobrecarga devuelve información sobre el nombre acompañada únicamente de los ingresos anuales, pero el nombre de pila, el segundo nombre y los apellidos están en un orden diferente.</span><span class="sxs-lookup"><span data-stu-id="caab4-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="caab4-158">Esto hace que se pueda confundir fácilmente el orden de los argumentos cuando se deconstruye una instancia `Person`.</span><span class="sxs-lookup"><span data-stu-id="caab4-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="caab4-159">Deconstruir un tipo definido por el usuario con descartes</span><span class="sxs-lookup"><span data-stu-id="caab4-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="caab4-160">Tal como haría con las [tuplas](#deconstructing-tuple-elements-with-discards), puede usar descartes para omitir los elementos seleccionados que haya devuelto un método `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="caab4-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="caab4-161">Cada descarte se define mediante una variable denominada "\_". Una operación de deconstrucción única puede incluir varios descartes.</span><span class="sxs-lookup"><span data-stu-id="caab4-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="caab4-162">En el siguiente ejemplo se deconstruye un objeto `Person` en cuatro cadenas (el nombre propio, los apellidos, la ciudad y el estado), pero se descartan los apellidos y el estado.</span><span class="sxs-lookup"><span data-stu-id="caab4-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="caab4-163">Deconstruir un tipo definido por el usuario con un método de extensión</span><span class="sxs-lookup"><span data-stu-id="caab4-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="caab4-164">Aunque no haya creado una clase, una estructura o una interfaz por sí mismo, puede igualmente deconstruir objetos de ese tipo. Para ello, implemente uno o varios [métodos de extensión](programming-guide/classes-and-structs/extension-methods.md) `Deconstruct` que devuelvan los valores que le interesen.</span><span class="sxs-lookup"><span data-stu-id="caab4-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="caab4-165">En el ejemplo siguiente se definen dos métodos de extensión `Deconstruct` para la clase <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="caab4-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="caab4-166">El primero devuelve un conjunto de valores que indican las características de la propiedad, incluido su tipo, si es estática o de instancia, si es de solo lectura y si está indexada.</span><span class="sxs-lookup"><span data-stu-id="caab4-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="caab4-167">El segundo indica la accesibilidad de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="caab4-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="caab4-168">Dado que la accesibilidad de los descriptores de acceso get y set puede diferir, los valores booleanos indican si la propiedad tiene descriptores de acceso get y set independientes y, si es así, si tienen la misma accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="caab4-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="caab4-169">Si solo hay un descriptor de acceso, o si los descriptores de acceso get y set tienen la misma accesibilidad, la variable `access` indica la accesibilidad de la propiedad en conjunto.</span><span class="sxs-lookup"><span data-stu-id="caab4-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="caab4-170">En caso contrario, la accesibilidad de los descriptores de acceso get y set se indica mediante las variables `getAccess` y `setAccess`.</span><span class="sxs-lookup"><span data-stu-id="caab4-170">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="caab4-171">Vea también</span><span class="sxs-lookup"><span data-stu-id="caab4-171">See also</span></span>

- [<span data-ttu-id="caab4-172">Descartes</span><span class="sxs-lookup"><span data-stu-id="caab4-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="caab4-173">Tipos de tupla</span><span class="sxs-lookup"><span data-stu-id="caab4-173">Tuple types</span></span>](language-reference/builtin-types/value-tuples.md)
