---
title: 'Funciones locales: Guía de programación de C#'
description: En C#, las funciones locales son métodos privados que están anidados en otro miembro y se pueden llamar desde su miembro contenedor.
ms.date: 10/09/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: a2d389c8b1c687dc4885004fcdc33e0ed7ada977
ms.sourcegitcommit: b59237ca4ec763969a0dd775a3f8f39f8c59fe24
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/12/2020
ms.locfileid: "91955686"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="f90c5-103">Funciones locales (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="f90c5-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="f90c5-104">A partir de C# 7.0, C# admite *funciones locales*.</span><span class="sxs-lookup"><span data-stu-id="f90c5-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="f90c5-105">Las funciones locales son métodos privados de un tipo que están anidados en otro miembro.</span><span class="sxs-lookup"><span data-stu-id="f90c5-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="f90c5-106">Solo se pueden llamar desde su miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="f90c5-106">They can only be called from their containing member.</span></span> <span data-ttu-id="f90c5-107">Las funciones locales se pueden declarar en y llamar desde:</span><span class="sxs-lookup"><span data-stu-id="f90c5-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="f90c5-108">Métodos, especialmente los métodos de iterador y asincrónicos</span><span class="sxs-lookup"><span data-stu-id="f90c5-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="f90c5-109">Constructores</span><span class="sxs-lookup"><span data-stu-id="f90c5-109">Constructors</span></span>
- <span data-ttu-id="f90c5-110">Descriptores de acceso de propiedad</span><span class="sxs-lookup"><span data-stu-id="f90c5-110">Property accessors</span></span>
- <span data-ttu-id="f90c5-111">Descriptores de acceso de un evento</span><span class="sxs-lookup"><span data-stu-id="f90c5-111">Event accessors</span></span>
- <span data-ttu-id="f90c5-112">Métodos anónimos</span><span class="sxs-lookup"><span data-stu-id="f90c5-112">Anonymous methods</span></span>
- <span data-ttu-id="f90c5-113">Expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="f90c5-113">Lambda expressions</span></span>
- <span data-ttu-id="f90c5-114">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="f90c5-114">Finalizers</span></span>
- <span data-ttu-id="f90c5-115">Otras funciones locales</span><span class="sxs-lookup"><span data-stu-id="f90c5-115">Other local functions</span></span>

<span data-ttu-id="f90c5-116">En cambio, las funciones locales no se pueden declarar dentro de un miembro con forma de expresión.</span><span class="sxs-lookup"><span data-stu-id="f90c5-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="f90c5-117">En algunos casos, puede usar una expresión lambda para implementar funcionalidad compatible también con una función local.</span><span class="sxs-lookup"><span data-stu-id="f90c5-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="f90c5-118">Para ver una comparación, consulte [Funciones locales frente a expresiones lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="f90c5-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="f90c5-119">Las funciones locales aclaran la intención del código.</span><span class="sxs-lookup"><span data-stu-id="f90c5-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="f90c5-120">Cualquiera que lea el código puede ver que solo el método que lo contiene puede llamar al método.</span><span class="sxs-lookup"><span data-stu-id="f90c5-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="f90c5-121">Para los proyectos de equipo, también hacen que sea imposible que otro desarrollador llame erróneamente al método de forma directa desde cualquier otro punto de la clase o estructura.</span><span class="sxs-lookup"><span data-stu-id="f90c5-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="f90c5-122">Sintaxis de función local</span><span class="sxs-lookup"><span data-stu-id="f90c5-122">Local function syntax</span></span>

<span data-ttu-id="f90c5-123">Una función local se define como un método anidado dentro de un miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="f90c5-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="f90c5-124">Su definición tiene la siguiente sintaxis:</span><span class="sxs-lookup"><span data-stu-id="f90c5-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="f90c5-125">Puede usar los siguientes modificadores con una función local:</span><span class="sxs-lookup"><span data-stu-id="f90c5-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="f90c5-126">[`static`](../../language-reference/keywords/static.md) (en C# 8.0 y posterior).</span><span class="sxs-lookup"><span data-stu-id="f90c5-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="f90c5-127">Una función local estática no puede capturar variables locales o el estado de la instancia.</span><span class="sxs-lookup"><span data-stu-id="f90c5-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="f90c5-128">[`extern`](../../language-reference/keywords/extern.md) (en C# 9.0 y posterior).</span><span class="sxs-lookup"><span data-stu-id="f90c5-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="f90c5-129">Una función local externa debe ser `static`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-129">An external local function must be `static`.</span></span>

<span data-ttu-id="f90c5-130">Todas las variables locales que se definen en el miembro contenedor, incluidos sus parámetros de método, son accesibles en la función local no estática.</span><span class="sxs-lookup"><span data-stu-id="f90c5-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="f90c5-131">A diferencia de una definición de método, una definición de función local no puede incluir el modificador de acceso de los miembros.</span><span class="sxs-lookup"><span data-stu-id="f90c5-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="f90c5-132">Dado que todas las funciones locales son privadas, incluido un modificador de acceso, como la palabra clave `private`, se genera el error del compilador CS0106, "El modificador 'private' no es válido para este elemento".</span><span class="sxs-lookup"><span data-stu-id="f90c5-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="f90c5-133">En el ejemplo siguiente, se define una función local denominada `AppendPathSeparator` que es privada a un método denominado `GetText`:</span><span class="sxs-lookup"><span data-stu-id="f90c5-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="f90c5-134">A partir de C# 9.0, puede aplicar atributos a una función local, sus parámetros y parámetros de tipo, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="f90c5-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="f90c5-135">En el ejemplo anterior se usa un [atributo especial](../../language-reference/attributes/nullable-analysis.md) para ayudar al compilador en el análisis estático en un contexto que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="f90c5-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="f90c5-136">Excepciones y funciones locales</span><span class="sxs-lookup"><span data-stu-id="f90c5-136">Local functions and exceptions</span></span>

<span data-ttu-id="f90c5-137">Una de las características útiles de las funciones locales es que pueden permitir que las excepciones aparezcan inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="f90c5-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="f90c5-138">Para los iteradores de método, las excepciones aparecen solo cuando la secuencia devuelta se enumera y no cuando se recupera el iterador.</span><span class="sxs-lookup"><span data-stu-id="f90c5-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="f90c5-139">Para los métodos asincrónicos, las excepciones producidas en un método asincrónico se observan cuando se espera la tarea devuelta.</span><span class="sxs-lookup"><span data-stu-id="f90c5-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="f90c5-140">En el ejemplo siguiente se define un método `OddSequence` que enumera los números impares de un intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="f90c5-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="f90c5-141">Dado que pasa un número mayor de 100 al método de enumerador `OddSequence`, el método produce una excepción <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="f90c5-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="f90c5-142">Como se muestra en el resultado del ejemplo, la excepción aparece solo cuando itera los números, y no al recuperar el enumerador.</span><span class="sxs-lookup"><span data-stu-id="f90c5-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="f90c5-143">Si coloca la lógica de iterador en una función local, se iniciarán excepciones de validación de argumentos al recuperar el enumerador, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="f90c5-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="f90c5-144">Puede usar funciones locales de una manera similar con las operaciones asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="f90c5-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="f90c5-145">Las excepciones iniciadas en un método asincrónico aparecen cuando se espera por la tarea correspondiente.</span><span class="sxs-lookup"><span data-stu-id="f90c5-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="f90c5-146">Las funciones locales permiten que el código genere un error inmediato y permiten que la excepción se produzca y observe de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="f90c5-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="f90c5-147">En el ejemplo siguiente, se usa un método asincrónico denominado `GetMultipleAsync` para pausar durante un número especificado de segundos y se devuelve un valor que es un múltiplo aleatorio de ese número de segundos.</span><span class="sxs-lookup"><span data-stu-id="f90c5-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="f90c5-148">El retraso máximo es de 5 segundos; se produce una excepción <xref:System.ArgumentOutOfRangeException> si el valor es mayor que 5.</span><span class="sxs-lookup"><span data-stu-id="f90c5-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="f90c5-149">Como se muestra en el ejemplo siguiente, la excepción que se inicia cuando se pasa un valor de 6 al método `GetMultipleAsync` solo se observa cuando se espera por la tarea.</span><span class="sxs-lookup"><span data-stu-id="f90c5-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="f90c5-150">Como sucede con el método de iterador, puede refactorizar el ejemplo anterior y colocar el código de la operación asincrónica en una función local.</span><span class="sxs-lookup"><span data-stu-id="f90c5-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="f90c5-151">Como se muestra en la salida del ejemplo siguiente, al llamar al método `GetMultiple` se inicia la excepción <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="f90c5-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="f90c5-152">Funciones locales frente a expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="f90c5-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="f90c5-153">A primera vista, las funciones locales y las [expresiones lambda](../../language-reference/operators/lambda-expressions.md) son muy similares.</span><span class="sxs-lookup"><span data-stu-id="f90c5-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="f90c5-154">En muchos casos, la elección entre usar expresiones lambda y funciones locales es una cuestión de estilo y de preferencia personal,</span><span class="sxs-lookup"><span data-stu-id="f90c5-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="f90c5-155">aunque hay diferencias que debe tener en cuenta acerca de dónde puede usar una u otra.</span><span class="sxs-lookup"><span data-stu-id="f90c5-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="f90c5-156">Vamos a examinar las diferencias entre las implementaciones de la función local y la expresión lambda del algoritmo factorial.</span><span class="sxs-lookup"><span data-stu-id="f90c5-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="f90c5-157">Primero la versión que usa una función local:</span><span class="sxs-lookup"><span data-stu-id="f90c5-157">First the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="f90c5-158">Compare esa implementación con una versión que use expresiones lambda:</span><span class="sxs-lookup"><span data-stu-id="f90c5-158">Contrast that implementation with a version that uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

<span data-ttu-id="f90c5-159">Las funciones locales tienen nombres,</span><span class="sxs-lookup"><span data-stu-id="f90c5-159">The local functions have names.</span></span> <span data-ttu-id="f90c5-160">mientras que las expresiones lambda son métodos anónimos que se asignan a variables que son tipos `Func` o `Action`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-160">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="f90c5-161">Cuando se declara una función local, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de función.</span><span class="sxs-lookup"><span data-stu-id="f90c5-161">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="f90c5-162">En lugar de formar parte del cuerpo de la expresión lambda, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de tipo de variable de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-162">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="f90c5-163">Estas dos diferencias pueden hacer que el código sea más claro.</span><span class="sxs-lookup"><span data-stu-id="f90c5-163">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="f90c5-164">Las funciones locales tienen reglas diferentes de las expresiones lambda para la asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="f90c5-164">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="f90c5-165">Se puede hacer referencia a una declaración de función local desde cualquier ubicación del código que esté dentro del ámbito.</span><span class="sxs-lookup"><span data-stu-id="f90c5-165">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="f90c5-166">Las expresiones lambda se deben asignar a una variable de delegado para poder acceder a ellas (o para poder llamarlas mediante el delegado que hace referencia a ellas).</span><span class="sxs-lookup"><span data-stu-id="f90c5-166">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="f90c5-167">Observe que la versión con la expresión lambda debe declarar e inicializar la expresión lambda, `nthFactorial`, antes de definirla.</span><span class="sxs-lookup"><span data-stu-id="f90c5-167">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="f90c5-168">De no hacerlo, se produce un error en tiempo de compilación por hacer referencia a `nthFactorial` antes de asignarlo.</span><span class="sxs-lookup"><span data-stu-id="f90c5-168">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="f90c5-169">Estas diferencias implican que los algoritmos recursivos son más fáciles de crear usando funciones locales.</span><span class="sxs-lookup"><span data-stu-id="f90c5-169">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="f90c5-170">Puede declarar y definir una función local que se llama a sí misma.</span><span class="sxs-lookup"><span data-stu-id="f90c5-170">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="f90c5-171">Las expresiones lambda se deben declarar y se les debe asignar un valor predeterminado para que se les pueda volver a asignar un cuerpo que haga referencia a la misma expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-171">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="f90c5-172">Las reglas de asignación definitiva también afectan a las variables que se capturan con la función local o la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-172">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="f90c5-173">Tanto las funciones locales como las reglas de expresiones lambda exigen que las variables capturadas se asignen definitivamente en el momento en que la función local o la expresión lambda se convierta en un delegado.</span><span class="sxs-lookup"><span data-stu-id="f90c5-173">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="f90c5-174">La diferencia está en que las expresiones lambda se convierten en delegados en el momento en que se declaran,</span><span class="sxs-lookup"><span data-stu-id="f90c5-174">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="f90c5-175">mientras que las funciones locales se convierten en delegados solo cuando se usan como delegados.</span><span class="sxs-lookup"><span data-stu-id="f90c5-175">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="f90c5-176">Si se declara una función local y solo se hace referencia a ella llamándola como un método, no se convertirá en un delegado.</span><span class="sxs-lookup"><span data-stu-id="f90c5-176">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="f90c5-177">Esta regla le permite declarar una función local en cualquier ubicación adecuada de su ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="f90c5-177">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="f90c5-178">Es habitual declarar funciones locales al final del método principal, después de cualquier instrucción "return".</span><span class="sxs-lookup"><span data-stu-id="f90c5-178">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="f90c5-179">En tercer lugar, el compilador puede efectuar un análisis estático que permita que las funciones locales asignen definitivamente variables capturadas en el ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="f90c5-179">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="f90c5-180">Considere este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="f90c5-180">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="f90c5-181">El compilador puede determinar que `LocalFunction` asigna `y` definitivamente cuando se le llama.</span><span class="sxs-lookup"><span data-stu-id="f90c5-181">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="f90c5-182">Como se llama a `LocalFunction` antes de la instrucción `return`, `y` se asigna definitivamente en la instrucción `return`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-182">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="f90c5-183">El análisis que proporciona el análisis de ejemplo posibilita la cuarta diferencia.</span><span class="sxs-lookup"><span data-stu-id="f90c5-183">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="f90c5-184">Dependiendo de su uso, las funciones locales pueden evitar las asignaciones de montón que siempre son necesarias para las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-184">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="f90c5-185">Si una función local no se convierte nunca en un delegado y ninguna de las variables capturadas con la función local se captura con otras expresiones lambda o funciones locales que se han convertido en delegados, el compilador puede evitar las asignaciones de montón.</span><span class="sxs-lookup"><span data-stu-id="f90c5-185">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="f90c5-186">Considere este ejemplo asincrónico:</span><span class="sxs-lookup"><span data-stu-id="f90c5-186">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="f90c5-187">La clausura de esta expresión lambda contiene las variables `address`, `index` y `name`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-187">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="f90c5-188">En el caso de las funciones locales, el objeto que implementa el cierre puede ser un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-188">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="f90c5-189">Luego, ese tipo de estructura se pasaría por referencia a la función local.</span><span class="sxs-lookup"><span data-stu-id="f90c5-189">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="f90c5-190">Esta diferencia de implementación supondría un ahorro en una asignación.</span><span class="sxs-lookup"><span data-stu-id="f90c5-190">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="f90c5-191">La creación de instancias necesaria para las expresiones lambda significa asignaciones de memoria adicionales, lo que puede ser un factor de rendimiento en rutas de acceso de código crítico en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="f90c5-191">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="f90c5-192">Las funciones locales no suponen esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="f90c5-192">Local functions do not incur this overhead.</span></span> <span data-ttu-id="f90c5-193">En el ejemplo anterior, la versión de las funciones locales tiene dos asignaciones menos que la versión de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-193">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="f90c5-194">La función local equivalente de este método también usa una clase para el cierre.</span><span class="sxs-lookup"><span data-stu-id="f90c5-194">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="f90c5-195">Si el cierre de una función local se implementa como `class` o `struct` es un detalle de implementación.</span><span class="sxs-lookup"><span data-stu-id="f90c5-195">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="f90c5-196">Una función local puede usar `struct` mientras una expresión lambda siempre usará `class`.</span><span class="sxs-lookup"><span data-stu-id="f90c5-196">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

<span data-ttu-id="f90c5-197">Una ventaja final que no se muestra en este ejemplo es que las funciones locales pueden implementarse como iteradores, con la sintaxis `yield return` para producir una secuencia de valores.</span><span class="sxs-lookup"><span data-stu-id="f90c5-197">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="f90c5-198">La instrucción `yield return` no está permitida en las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="f90c5-198">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="f90c5-199">Aunque las funciones locales pueden parecer redundantes con respecto a las expresiones lambda, en realidad tienen finalidades y usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="f90c5-199">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="f90c5-200">Las funciones locales son más eficaces si se quiere escribir una función a la que solo se llame desde el contexto de otro método.</span><span class="sxs-lookup"><span data-stu-id="f90c5-200">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="f90c5-201">Vea también</span><span class="sxs-lookup"><span data-stu-id="f90c5-201">See also</span></span>

- [<span data-ttu-id="f90c5-202">Métodos</span><span class="sxs-lookup"><span data-stu-id="f90c5-202">Methods</span></span>](methods.md)
