---
title: MDA de releaseHandleFailed
description: Revise el Asistente para la depuración administrada (MDA) de releaseHandleFailed, que puede activarse debido a pérdidas de recursos o de memoria en .NET.
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: b337a7283e961d0fae2b51d92a21fa77f7249250
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96267135"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="e6de8-103">MDA de releaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="e6de8-103">releaseHandleFailed MDA</span></span>

<span data-ttu-id="e6de8-104">El Asistente para depuración administrada (MDA) de `releaseHandleFailed` se activa para notificar a los desarrolladores cuando el método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> de una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="e6de8-104">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="e6de8-105">Síntomas</span><span class="sxs-lookup"><span data-stu-id="e6de8-105">Symptoms</span></span>  

 <span data-ttu-id="e6de8-106">Pérdidas de recursos o de memoria.</span><span class="sxs-lookup"><span data-stu-id="e6de8-106">Resource or memory leaks.</span></span>  <span data-ttu-id="e6de8-107">Si se produce un error en el método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> de la clase que deriva de <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle>, es posible que el recurso encapsulado por la clase no se haya liberado o limpiado.</span><span class="sxs-lookup"><span data-stu-id="e6de8-107">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="e6de8-108">Causa</span><span class="sxs-lookup"><span data-stu-id="e6de8-108">Cause</span></span>  

 <span data-ttu-id="e6de8-109">Los usuarios deben proporcionar la implementación del método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> si crean clases que deriven de <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle>. Por lo tanto, las circunstancias son específicas de cada recurso.</span><span class="sxs-lookup"><span data-stu-id="e6de8-109">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="e6de8-110">Sin embargo, los requisitos son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="e6de8-110">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="e6de8-111">Los tipos <xref:System.Runtime.InteropServices.SafeHandle> y <xref:System.Runtime.InteropServices.CriticalHandle> representan contenedores que contienen recursos de procesos fundamentales.</span><span class="sxs-lookup"><span data-stu-id="e6de8-111"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="e6de8-112">Si se produce una pérdida de memoria, con el tiempo, esto puede inutilizar el proceso.</span><span class="sxs-lookup"><span data-stu-id="e6de8-112">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="e6de8-113">Para que el método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> realice su función, no debe haber errores en él.</span><span class="sxs-lookup"><span data-stu-id="e6de8-113">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="e6de8-114">Una vez que el proceso adquiere este tipo de recurso, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> es la única manera de liberarlo.</span><span class="sxs-lookup"><span data-stu-id="e6de8-114">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="e6de8-115">Por lo tanto, los errores conllevan pérdidas de recursos.</span><span class="sxs-lookup"><span data-stu-id="e6de8-115">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="e6de8-116">Todos los errores que se producen durante la ejecución de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> y que impiden que se libere el recurso, son errores en la implementación del propio método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6de8-116">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="e6de8-117">Es responsabilidad del programador asegurarse de que se cumpla el contrato, aunque ese código, para realizar su función, llame a un código creado por otra persona.</span><span class="sxs-lookup"><span data-stu-id="e6de8-117">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="e6de8-118">Solución</span><span class="sxs-lookup"><span data-stu-id="e6de8-118">Resolution</span></span>  

 <span data-ttu-id="e6de8-119">El código que utiliza el tipo específico <xref:System.Runtime.InteropServices.SafeHandle> (o <xref:System.Runtime.InteropServices.CriticalHandle>) que generó la notificación del MDA se debe revisar, para buscar los lugares donde se extrae el valor de identificador sin formato de <xref:System.Runtime.InteropServices.SafeHandle> y se copia a otro lugar.</span><span class="sxs-lookup"><span data-stu-id="e6de8-119">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="e6de8-120">Esta es la causa habitual de errores dentro de las implementaciones de <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle>, porque el tiempo de ejecución deja de realizar un seguimiento del uso del valor de identificador sin formato.</span><span class="sxs-lookup"><span data-stu-id="e6de8-120">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="e6de8-121">Si más tarde se cierra la copia del identificador sin formato, es posible que se produzca un error en una llamada a <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> posterior, porque se trate de realizar el cierre en el mismo identificador, que ahora no es válido.</span><span class="sxs-lookup"><span data-stu-id="e6de8-121">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="e6de8-122">Hay varias maneras en que puede producirse la duplicación incorrecta del identificador:</span><span class="sxs-lookup"><span data-stu-id="e6de8-122">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="e6de8-123">Busque las llamadas al método <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6de8-123">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="e6de8-124">Las llamadas a este método deben ser sumamente infrecuentes, y las que encuentre deben estar entre las llamadas a los métodos <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> y <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6de8-124">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="e6de8-125">Estos métodos especifican la región de código en la que el valor de identificador sin formato se puede utilizar de forma segura.</span><span class="sxs-lookup"><span data-stu-id="e6de8-125">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="e6de8-126">Fuera de esta región o si, de entrada, el número de referencias no se incrementa nunca, el valor de identificador se puede invalidar en cualquier momento con una llamada a <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> en otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="e6de8-126">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="e6de8-127">Después de encontrar todos los usos de <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>, debe seguir la ruta de acceso que toma el identificador sin formato, para comprobar que no se entregue a otro componente que podría terminar llamando a `CloseHandle` o a otro método nativo de bajo nivel que libere el identificador.</span><span class="sxs-lookup"><span data-stu-id="e6de8-127">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="e6de8-128">Asegúrese de que el código que se usa para inicializar <xref:System.Runtime.InteropServices.SafeHandle> con un valor de identificador sin procesar válido posee el identificador.</span><span class="sxs-lookup"><span data-stu-id="e6de8-128">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="e6de8-129">Si crea un <xref:System.Runtime.InteropServices.SafeHandle> alrededor de un identificador que no es propiedad del código sin establecer el parámetro `ownsHandle` como `false` en el constructor base, tanto el <xref:System.Runtime.InteropServices.SafeHandle> como el propietario del identificador real pueden tratar de cerrar el identificador. Esto provocará un error en <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> si el <xref:System.Runtime.InteropServices.SafeHandle> llega más tarde.</span><span class="sxs-lookup"><span data-stu-id="e6de8-129">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="e6de8-130">Cuando se calculen las referencias de <xref:System.Runtime.InteropServices.SafeHandle> entre los dominios de aplicación, confirme que la derivación de <xref:System.Runtime.InteropServices.SafeHandle> que se usa se marcó como serializable.</span><span class="sxs-lookup"><span data-stu-id="e6de8-130">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="e6de8-131">En los casos poco frecuentes en que una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> se hizo serializable, esta debería implementar la interfaz de <xref:System.Runtime.Serialization.ISerializable> o utilizar una de las otras técnicas para controlar los procesos de serialización y deserialización manualmente.</span><span class="sxs-lookup"><span data-stu-id="e6de8-131">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="e6de8-132">Es necesario hacer esto porque la acción de serialización predeterminada consiste en crear un clon bit a bit del valor de identificador sin formato delimitado, lo que genera dos instancias de <xref:System.Runtime.InteropServices.SafeHandle> que creen que poseen el mismo identificador.</span><span class="sxs-lookup"><span data-stu-id="e6de8-132">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="e6de8-133">Ambas tratarán de llamar a <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> en el mismo identificador en algún momento.</span><span class="sxs-lookup"><span data-stu-id="e6de8-133">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="e6de8-134">En la segunda <xref:System.Runtime.InteropServices.SafeHandle> que lo haga, se producirá un error.</span><span class="sxs-lookup"><span data-stu-id="e6de8-134">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="e6de8-135">El procedimiento que se debe seguir al serializar un <xref:System.Runtime.InteropServices.SafeHandle> es llamar a la función `DuplicateHandle` o a una función similar del tipo de identificador nativo para crear una copia del identificador legal y distintiva.</span><span class="sxs-lookup"><span data-stu-id="e6de8-135">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="e6de8-136">Si su tipo de identificador no admite esto, el tipo de <xref:System.Runtime.InteropServices.SafeHandle> que lo contiene no se puede hacer serializable.</span><span class="sxs-lookup"><span data-stu-id="e6de8-136">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="e6de8-137">Se puede realizar un seguimiento de las ocasiones en que un identificador se cierra pronto, lo que produce un error al llamar finalmente al método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Para ello, se debe colocar un punto de interrupción del depurador en la rutina nativa que se usa para liberar el identificador como, por ejemplo, la función `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="e6de8-137">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="e6de8-138">Esto puede no ser posible en los escenarios de esfuerzo o, incluso, en las pruebas funcionales de tamaño medio, debido a la intensidad del tráfico que suelen afrontar esas rutinas.</span><span class="sxs-lookup"><span data-stu-id="e6de8-138">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="e6de8-139">Puede ser útil para instrumentar el código que llama al método de liberación nativo, con el fin de capturar la identidad del llamador o, posiblemente, un seguimiento completo de la pila, y el valor del identificador que se libera.</span><span class="sxs-lookup"><span data-stu-id="e6de8-139">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="e6de8-140">El valor del identificador puede compararse con el valor indicado por este MDA.</span><span class="sxs-lookup"><span data-stu-id="e6de8-140">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="e6de8-141">Tenga en cuenta que algunos tipos de identificador nativo como, por ejemplo, todos los identificadores de Win32 que se pueden liberar con la función `CloseHandle`, comparten el mismo espacio de nombres de identificador.</span><span class="sxs-lookup"><span data-stu-id="e6de8-141">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="e6de8-142">Si un tipo de identificador se libera por error, puede producir problemas con otro.</span><span class="sxs-lookup"><span data-stu-id="e6de8-142">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="e6de8-143">Por ejemplo, si un identificador de evento de Win32 se cierra accidentalmente dos veces, puede hacer que un identificador de archivos aparentemente no relacionado se cierre de forma prematura.</span><span class="sxs-lookup"><span data-stu-id="e6de8-143">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="e6de8-144">Esto ocurre cuando se libera el identificador y el valor del identificador pasa a estar disponible para realizar el seguimiento de otro recurso, que puede ser de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="e6de8-144">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="e6de8-145">Si esto sucede y se produce otra liberación errónea, es posible que se invalide el identificador de un subproceso no relacionado.</span><span class="sxs-lookup"><span data-stu-id="e6de8-145">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="e6de8-146">Efecto en el Runtime</span><span class="sxs-lookup"><span data-stu-id="e6de8-146">Effect on the Runtime</span></span>  

 <span data-ttu-id="e6de8-147">Este MDA no tiene ningún efecto en el CLR.</span><span class="sxs-lookup"><span data-stu-id="e6de8-147">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="e6de8-148">Resultados</span><span class="sxs-lookup"><span data-stu-id="e6de8-148">Output</span></span>  

 <span data-ttu-id="e6de8-149">Un mensaje que indica que un <xref:System.Runtime.InteropServices.SafeHandle> o un <xref:System.Runtime.InteropServices.CriticalHandle> no pudieron liberar correctamente el identificador.</span><span class="sxs-lookup"><span data-stu-id="e6de8-149">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="e6de8-150">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="e6de8-150">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="e6de8-151">Configuración</span><span class="sxs-lookup"><span data-stu-id="e6de8-151">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="e6de8-152">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="e6de8-152">Example</span></span>  

 <span data-ttu-id="e6de8-153">A continuación, se muestra un ejemplo de código que puede activar el MDA de `releaseHandleFailed`.</span><span class="sxs-lookup"><span data-stu-id="e6de8-153">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="e6de8-154">Vea también</span><span class="sxs-lookup"><span data-stu-id="e6de8-154">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="e6de8-155">Diagnóstico de errores con asistentes de depuraciones administradas</span><span class="sxs-lookup"><span data-stu-id="e6de8-155">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="e6de8-156">Serialización de interoperabilidad</span><span class="sxs-lookup"><span data-stu-id="e6de8-156">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
