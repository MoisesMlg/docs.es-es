---
title: Cargar y utilizar tipos dinámicamente
description: Cargue y use tipos de forma dinámica en .NET. Use la reflexión, que facilita la infraestructura que usan los compiladores de lenguaje, para implementar el enlace en tiempo de ejecución implícito.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266797"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="36abf-104">Cargar y utilizar tipos dinámicamente</span><span class="sxs-lookup"><span data-stu-id="36abf-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="36abf-105">La reflexión facilita la infraestructura que utilizan los compiladores de lenguaje para implementar el enlace en tiempo de ejecución implícito.</span><span class="sxs-lookup"><span data-stu-id="36abf-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="36abf-106">El enlace es el proceso de buscar la declaración (es decir, la implementación) que corresponde a un tipo especificado de manera exclusiva.</span><span class="sxs-lookup"><span data-stu-id="36abf-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="36abf-107">Cuando este proceso se produce en tiempo de ejecución, en lugar de en tiempo de compilación, se denomina enlace en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="36abf-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="36abf-108">Visual Basic le permite usar el enlace en tiempo de ejecución implícito en el código; el compilador de Visual Basic llama a un método auxiliar que usa la reflexión para obtener el tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="36abf-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="36abf-109">Los argumentos pasados al método del asistente hacen que se invoque el método adecuado en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="36abf-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="36abf-110">Estos argumentos son la instancia (un objeto) en la que se invoca el método, el nombre del método invocado (una cadena) y los argumentos pasados al método invocado (una matriz de objetos).</span><span class="sxs-lookup"><span data-stu-id="36abf-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="36abf-111">En el ejemplo siguiente, el compilador de Visual Basic usa implícitamente la reflexión para llamar a un método en un objeto cuyo tipo se desconoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="36abf-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="36abf-112">Una clase **HelloWorld** tiene un método **PrintHello** que imprime "Hello World" de forma concatenada con texto que se pasa al método **PrintHello**.</span><span class="sxs-lookup"><span data-stu-id="36abf-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="36abf-113">El método **PrintHello** llamado en este ejemplo es en realidad <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; el código de Visual Basic permite invocar el método **PrintHello** como si se conociera el tipo del objeto (helloObj) en tiempo de compilación (enlace anticipado), y no en tiempo de ejecución (enlace en tiempo de ejecución).</span><span class="sxs-lookup"><span data-stu-id="36abf-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="36abf-114">Enlace personalizado</span><span class="sxs-lookup"><span data-stu-id="36abf-114">Custom Binding</span></span>  

 <span data-ttu-id="36abf-115">Además de usarla implícitamente los compiladores para el enlace en tiempo de ejecución, la reflexión puede usarse explícitamente en el código para realizar el enlace en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="36abf-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="36abf-116">[Common Language Runtime](../../standard/clr.md) admite varios lenguajes de programación, y las reglas de enlace de estos lenguajes son diferentes.</span><span class="sxs-lookup"><span data-stu-id="36abf-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="36abf-117">En el caso del enlace anticipado, los generadores de código pueden controlar completamente este enlace.</span><span class="sxs-lookup"><span data-stu-id="36abf-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="36abf-118">Pero en el caso del enlace en tiempo de ejecución mediante reflexión, es necesario controlarlo mediante un enlace personalizado.</span><span class="sxs-lookup"><span data-stu-id="36abf-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="36abf-119">La clase <xref:System.Reflection.Binder> proporciona un control personalizado de la selección e invocación de miembros.</span><span class="sxs-lookup"><span data-stu-id="36abf-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="36abf-120">Mediante el enlace personalizado, puede cargar un ensamblado en tiempo de ejecución, obtener información sobre los tipos del ensamblado, especificar el tipo que quiera y, después, invocar métodos u obtener acceso a campos o propiedades de dicho tipo.</span><span class="sxs-lookup"><span data-stu-id="36abf-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="36abf-121">Esta técnica es útil si no conoce el tipo de un objeto en tiempo de compilación, como cuando el tipo de objeto depende de la entrada del usuario.</span><span class="sxs-lookup"><span data-stu-id="36abf-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="36abf-122">En el ejemplo siguiente se muestra un enlazador simple personalizado que no proporciona conversión de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="36abf-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="36abf-123">El ejemplo principal va precedido del código de `Simple_Type.dll`.</span><span class="sxs-lookup"><span data-stu-id="36abf-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="36abf-124">Asegúrese de compilar `Simple_Type.dll` y, después, incluir una referencia a él en el proyecto en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="36abf-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="36abf-125">InvokeMember y CreateInstance</span><span class="sxs-lookup"><span data-stu-id="36abf-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="36abf-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> para invocar un miembro de un tipo.</span><span class="sxs-lookup"><span data-stu-id="36abf-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="36abf-127">Los métodos **CreateInstance** de diversas clases, como <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> y <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, son formas especializadas de **InvokeMember** que crean nuevas instancias del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="36abf-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="36abf-128">La clase **Binder** se usa para la resolución de sobrecarga y la conversión de argumentos en estos métodos.</span><span class="sxs-lookup"><span data-stu-id="36abf-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="36abf-129">En el ejemplo siguiente se muestran las tres posibles combinaciones de conversión de argumentos (conversión de tipos) y selección de miembros.</span><span class="sxs-lookup"><span data-stu-id="36abf-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="36abf-130">En el caso 1, no se necesita ni conversión de argumentos ni selección de miembros.</span><span class="sxs-lookup"><span data-stu-id="36abf-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="36abf-131">En el caso 2, solo se necesita la selección de miembros.</span><span class="sxs-lookup"><span data-stu-id="36abf-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="36abf-132">En el caso 3, solo se necesita la conversión de argumentos.</span><span class="sxs-lookup"><span data-stu-id="36abf-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="36abf-133">Se necesita la resolución de sobrecarga cuando hay más de un miembro con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="36abf-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="36abf-134">Los métodos <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> se usan para resolver el enlace en un solo miembro.</span><span class="sxs-lookup"><span data-stu-id="36abf-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="36abf-135">**Binder.BindToMethod** también proporciona resolución de propiedades mediante los descriptores de acceso de propiedades **get** y **set**.</span><span class="sxs-lookup"><span data-stu-id="36abf-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="36abf-136">**BindToMethod** devuelve el <xref:System.Reflection.MethodBase> que se va a invocar o una referencia nula (**Nothing** en Visual Basic) si la invocación no es posible.</span><span class="sxs-lookup"><span data-stu-id="36abf-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="36abf-137">No es necesario que el valor devuelto de **MethodBase** sea uno de los contenidos en el parámetro *match*, aunque esto es lo habitual.</span><span class="sxs-lookup"><span data-stu-id="36abf-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="36abf-138">Cuando hay argumentos ByRef, el llamador podría querer recuperarlos.</span><span class="sxs-lookup"><span data-stu-id="36abf-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="36abf-139">Por lo tanto, **Binder** permite que un cliente asigne la matriz de argumentos de nuevo a su forma original si **BindToMethod** ha manipulado la matriz de argumentos.</span><span class="sxs-lookup"><span data-stu-id="36abf-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="36abf-140">Para ello, debe garantizarse al llamador que el orden de los argumentos no se ha modificado.</span><span class="sxs-lookup"><span data-stu-id="36abf-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="36abf-141">Cuando los argumentos se pasan por nombre, **Binder** reordena la matriz de argumentos, y esto es lo que ve el llamador.</span><span class="sxs-lookup"><span data-stu-id="36abf-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="36abf-142">Para obtener más información, vea <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="36abf-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="36abf-143">El conjunto de miembros disponibles está integrado por los miembros definidos en el tipo o en cualquier tipo base.</span><span class="sxs-lookup"><span data-stu-id="36abf-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="36abf-144">Si se especifica <xref:System.Reflection.BindingFlags>, se devolverán en el conjunto miembros de cualquier tipo de accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="36abf-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="36abf-145">Si no se especifica **BindingFlags.NonPublic**, el enlazador deberá imponer reglas de accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="36abf-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="36abf-146">Cuando especifique la marca de enlace **Public** o **NonPublic**, también debe especificar la marca de enlace **Instance** o **Static**. En caso contrario, no se devolverá ningún miembro.</span><span class="sxs-lookup"><span data-stu-id="36abf-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="36abf-147">Si solo hay un miembro con el nombre especificado, no es necesaria la devolución de la llamada y el enlace se realiza en dicho método.</span><span class="sxs-lookup"><span data-stu-id="36abf-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="36abf-148">En el caso 1 del ejemplo de código se ilustra este punto: solo hay disponible un método **PrintBob** y, por tanto, no es necesaria la devolución de la llamada.</span><span class="sxs-lookup"><span data-stu-id="36abf-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="36abf-149">Si hay más de un miembro en el conjunto disponible, todos estos métodos se pasan a **BindToMethod**, que selecciona el método apropiado y lo devuelve.</span><span class="sxs-lookup"><span data-stu-id="36abf-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="36abf-150">En el caso 2 del ejemplo de código, hay dos métodos denominados **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="36abf-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="36abf-151">Mediante una llamada a **BindToMethod**, se selecciona el método apropiado.</span><span class="sxs-lookup"><span data-stu-id="36abf-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="36abf-152"><xref:System.Reflection.Binder.ChangeType%2A> realiza la conversión de argumentos (conversión de tipos), que convierte los argumentos reales al tipo de los argumentos formales del método seleccionado.</span><span class="sxs-lookup"><span data-stu-id="36abf-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="36abf-153">Se llama a **ChangeType** para cada argumento incluso si los tipos coinciden exactamente.</span><span class="sxs-lookup"><span data-stu-id="36abf-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="36abf-154">En el caso 3 del ejemplo de código, se pasa un argumento real de tipo **String** con un valor de "5.5" a un método con un argumento formal de tipo **Double**.</span><span class="sxs-lookup"><span data-stu-id="36abf-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="36abf-155">Para que la invocación se realice correctamente, el valor de cadena "5.5" se debe convertir a un valor doble.</span><span class="sxs-lookup"><span data-stu-id="36abf-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="36abf-156">**ChangeType** realiza esta conversión.</span><span class="sxs-lookup"><span data-stu-id="36abf-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="36abf-157">**ChangeType** solo realiza [conversiones de ampliación](../../standard/base-types/type-conversion.md) o sin pérdida de información, como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="36abf-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="36abf-158">Tipo de origen</span><span class="sxs-lookup"><span data-stu-id="36abf-158">Source type</span></span>|<span data-ttu-id="36abf-159">Tipo de destino</span><span class="sxs-lookup"><span data-stu-id="36abf-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="36abf-160">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="36abf-160">Any type</span></span>|<span data-ttu-id="36abf-161">Su tipo base</span><span class="sxs-lookup"><span data-stu-id="36abf-161">Its base type</span></span>|  
|<span data-ttu-id="36abf-162">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="36abf-162">Any type</span></span>|<span data-ttu-id="36abf-163">La interfaz que implementa</span><span class="sxs-lookup"><span data-stu-id="36abf-163">Interface it implements</span></span>|  
|<span data-ttu-id="36abf-164">Char</span><span class="sxs-lookup"><span data-stu-id="36abf-164">Char</span></span>|<span data-ttu-id="36abf-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-166">Byte</span><span class="sxs-lookup"><span data-stu-id="36abf-166">Byte</span></span>|<span data-ttu-id="36abf-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-168">SByte</span><span class="sxs-lookup"><span data-stu-id="36abf-168">SByte</span></span>|<span data-ttu-id="36abf-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="36abf-170">UInt16</span></span>|<span data-ttu-id="36abf-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-172">Int16</span><span class="sxs-lookup"><span data-stu-id="36abf-172">Int16</span></span>|<span data-ttu-id="36abf-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="36abf-174">UInt32</span></span>|<span data-ttu-id="36abf-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-176">Int32</span><span class="sxs-lookup"><span data-stu-id="36abf-176">Int32</span></span>|<span data-ttu-id="36abf-177">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="36abf-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="36abf-178">UInt64</span></span>|<span data-ttu-id="36abf-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-179">Single, Double</span></span>|  
|<span data-ttu-id="36abf-180">Int64</span><span class="sxs-lookup"><span data-stu-id="36abf-180">Int64</span></span>|<span data-ttu-id="36abf-181">Single, Double</span><span class="sxs-lookup"><span data-stu-id="36abf-181">Single, Double</span></span>|  
|<span data-ttu-id="36abf-182">Single</span><span class="sxs-lookup"><span data-stu-id="36abf-182">Single</span></span>|<span data-ttu-id="36abf-183">Doble</span><span class="sxs-lookup"><span data-stu-id="36abf-183">Double</span></span>|  
|<span data-ttu-id="36abf-184">Tipo sin referencia</span><span class="sxs-lookup"><span data-stu-id="36abf-184">Nonreference type</span></span>|<span data-ttu-id="36abf-185">Tipo de referencia</span><span class="sxs-lookup"><span data-stu-id="36abf-185">Reference type</span></span>|  
  
 <span data-ttu-id="36abf-186">La clase <xref:System.Type> tiene métodos **Get** que usan parámetros de tipo **Binder** para resolver las referencias a un miembro concreto.</span><span class="sxs-lookup"><span data-stu-id="36abf-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="36abf-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> y <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> buscan un miembro determinado del tipo actual, para lo que proporcionan información de firma de ese miembro.</span><span class="sxs-lookup"><span data-stu-id="36abf-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="36abf-188">Se vuelve a llamar a <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> para seleccionar la información de firma especificada de los métodos apropiados.</span><span class="sxs-lookup"><span data-stu-id="36abf-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="36abf-189">Vea también</span><span class="sxs-lookup"><span data-stu-id="36abf-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="36abf-190">Ver información tipos</span><span class="sxs-lookup"><span data-stu-id="36abf-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="36abf-191">Conversión de tipos en .NET Framework</span><span class="sxs-lookup"><span data-stu-id="36abf-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
