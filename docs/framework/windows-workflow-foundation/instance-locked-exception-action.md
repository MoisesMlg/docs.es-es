---
title: Acción de excepción de instancia bloqueada
ms.date: 03/30/2017
ms.assetid: 164a5419-315c-4987-ad72-54cbdb88d402
ms.openlocfilehash: 3554975589bb6d55cef3611320d25687d1ee9ba6
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96279862"
---
# <a name="instance-locked-exception-action"></a><span data-ttu-id="828e4-102">Acción de excepción de instancia bloqueada</span><span class="sxs-lookup"><span data-stu-id="828e4-102">Instance Locked Exception Action</span></span>

<span data-ttu-id="828e4-103">La propiedad <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> del almacén de instancias de flujo de trabajo de SQL le permite especificar qué acción debe realizar el proveedor de persistencia de SQL cuando recibe <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span><span class="sxs-lookup"><span data-stu-id="828e4-103">The <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> property of the SQL Workflow Instance Store lets you specify what action the SQL persistence provider should take when it receives an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="828e4-104">El proveedor de persistencia recibe esta excepción cuando intenta bloquear una instancia de servicio del flujo de trabajo que ya está bloqueada actualmente por otro host del servicio.</span><span class="sxs-lookup"><span data-stu-id="828e4-104">The persistence provider receives this exception when it tries to lock a workflow service instance that is currently locked by another service host.</span></span> <span data-ttu-id="828e4-105">Los valores de esta propiedad son <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> y <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-105">The values for this property are <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>, and <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="828e4-106">El valor predeterminado es <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-106">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="828e4-107">En la lista siguiente se describen las tres opciones:</span><span class="sxs-lookup"><span data-stu-id="828e4-107">The following list describes the three options:</span></span>  
  
- <span data-ttu-id="828e4-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="828e4-109">El host de servicio no intenta bloquear la instancia de servicio de flujo de trabajo y pasa <xref:System.Runtime.DurableInstancing.InstanceLockedException> al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="828e4-109">The service host does not attempt to lock the workflow service instance and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller.</span></span>  <span data-ttu-id="828e4-110">Si el flujo de trabajo permanece en memoria durante un período superior a 60 segundos, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> como reintento.</span><span class="sxs-lookup"><span data-stu-id="828e4-110">If your workflow stays in memory for a period exceeding 60 seconds, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> as the retry.</span></span> <span data-ttu-id="828e4-111">El valor predeterminado es <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-111">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span>  
  
- <span data-ttu-id="828e4-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span></span> <span data-ttu-id="828e4-113">El host del servicio vuelve a intentar bloquear la instancia de servicio de flujo de trabajo con un intervalo lineal entre los reintentos y pasa <xref:System.Runtime.DurableInstancing.InstanceLockedException> al autor de llamada al final de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="828e4-113">The service host reattempts to lock the workflow service instance with a linear interval between retry attempts and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller at the end of the sequence.</span></span> <span data-ttu-id="828e4-114">Si el flujo de trabajo permanece en memoria aproximadamente entre 5 y 60 segundos, y llegan mensajes en lotes donde es más probable que los mensajes se envíen a la misma instancia del mismo host para procesar todos los mensajes antes de descargar el flujo de trabajo, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> para lograr la mejor latencia sin desperdiciar recursos.</span><span class="sxs-lookup"><span data-stu-id="828e4-114">If you workflow stays in memory approximately between 5-60 seconds, and messages arrive in batches where it is more likely for messages being sent to the same instance on the same host to process all messages before unloading the workflow, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> to achieve the best latency without wasting resources.</span></span>  
  
- <span data-ttu-id="828e4-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="828e4-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="828e4-116">El host del servicio vuelve a intentar bloquear la instancia de servicio de flujo de trabajo con un intervalo de interrupción exponencial entre los reintentos y pasa la excepción al autor de llamada al final de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="828e4-116">The service host reattempts to lock the workflow service instance with an exponential backoff interval between retry attempts, and passes the exception to the caller at the end of the sequence.</span></span> <span data-ttu-id="828e4-117">Si el flujo de trabajo permanece en memoria durante un tiempo muy corto (menos de 5 segundos), o una granja de servidores web es grande y la posibilidad de que se entregue otro mensaje al mismo host no es muy alta, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> para lograr la mejor latencia.</span><span class="sxs-lookup"><span data-stu-id="828e4-117">If your workflow stays in memory for a very short time (less than 5 seconds), or a Web farm is large and the chance of another message being delivered to the same host is not very high, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> to achieve the best latency.</span></span>  
  
 <span data-ttu-id="828e4-118">La característica Acción de excepción bloqueada de instancia admite los siguientes escenarios.</span><span class="sxs-lookup"><span data-stu-id="828e4-118">The Instance Locked Exception Action feature supports the following scenarios.</span></span> <span data-ttu-id="828e4-119">En todos los escenarios, si la propiedad instanceLockedExceptionAction de SqlWorkflowInstanceStore está establecida en <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> o <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, el host reintenta adquirir el bloqueo en instancias periódicamente de forma transparente.</span><span class="sxs-lookup"><span data-stu-id="828e4-119">In all scenarios, if the instanceLockedExceptionAction property of the SqlWorkflowInstanceStore is set to <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> or <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, the host transparently retries to acquire the lock on instances periodically.</span></span>  
  
1. <span data-ttu-id="828e4-120">**Permitir el apagado estable y el reciclaje superpuesto de dominios de aplicación.**</span><span class="sxs-lookup"><span data-stu-id="828e4-120">**Enabling graceful shutdown and overlapped recycling of application domains.**</span></span> <span data-ttu-id="828e4-121">Supongamos que se está reciclando un **AppDomain** con un host de servicio que ejecuta instancias de servicio de flujo de trabajo y un nuevo **AppDomain** para administrar las nuevas solicitudes en paralelo mientras el **AppDomain** anterior se deja sin problemas.</span><span class="sxs-lookup"><span data-stu-id="828e4-121">Suppose an **AppDomain** with a service host running workflow service instances is being recycled and a new **AppDomain** is brought up to handle new requests in parallel while the old **AppDomain** is brought down gracefully.</span></span> <span data-ttu-id="828e4-122">El apagado espera hasta que las instancias de servicio del flujo de trabajo estén inactivas, y, a continuación, conserva y descarga las instancias.</span><span class="sxs-lookup"><span data-stu-id="828e4-122">The shutdown waits until workflow service instances are idle, and then persists and unloads the instances.</span></span> <span data-ttu-id="828e4-123">Cualquier intento por parte de los hosts en el nuevo **AppDomain** para bloquear una instancia producirá una <xref:System.Runtime.DurableInstancing.InstanceLockedException> .</span><span class="sxs-lookup"><span data-stu-id="828e4-123">Any attempts by hosts in the new **AppDomain** to lock an instance will cause an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span>  
  
2. <span data-ttu-id="828e4-124">**Escalado horizontal de flujos de trabajo de duración en una granja homogénea de servidores.**</span><span class="sxs-lookup"><span data-stu-id="828e4-124">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span> <span data-ttu-id="828e4-125">Supongamos que hay un nodo de una granja de servidores en el que una instancia de flujo de trabajo está ejecutando bloqueos y el host del flujo de trabajo no puede quitar los bloqueos en la instancia que está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="828e4-125">Suppose a node of a server farm on which a workflow instance is running crashes and the workflow host cannot remove locks on the instance it is running.</span></span> <span data-ttu-id="828e4-126">Cuando un host del servicio que se ejecuta en otro nodo de la granja recibe un mensaje para esa instancia de flujo de trabajo, intenta adquirir los bloqueos en estas instancias y recibirá <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span><span class="sxs-lookup"><span data-stu-id="828e4-126">When a service host running on another node of the farm receives a message for that workflow instance, it tries to acquire locks on these instances it will receive the <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="828e4-127">Los bloqueos expirarán después de algún tiempo porque el host que se suponía que iba a renovar el bloqueo ya no existe.</span><span class="sxs-lookup"><span data-stu-id="828e4-127">The locks will expire after some time because the host that was supposed to renew the lock no longer exists.</span></span>  
  
     <span data-ttu-id="828e4-128">**Escalado horizontal de flujos de trabajo de duración en una granja homogénea de servidores.**</span><span class="sxs-lookup"><span data-stu-id="828e4-128">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span>  <span data-ttu-id="828e4-129"> Supongamos que desea escalar un flujo de trabajo de duración de manera horizontal usando varios hosts detrás de un NLB (equilibrador de carga de red). El host del flujo de trabajo que se ejecuta en un nodo de la granja carga una instancia de flujo de trabajo y está procesando un mensaje, y el mensaje siguiente a la instancia se enruta hacia el host que se está ejecutando en otro nodo porque el NLB no tiene el algoritmo de enrutamiento para entregar los mensajes al host que ya está ejecutando la instancia.</span><span class="sxs-lookup"><span data-stu-id="828e4-129">Suppose you want to horizontally scale a durable workflow using multiple hosts behind a NLB (Network Load Balancer), the workflow host running on one node of the farm loads a workflow instance and is processing a message, and the next message to the instance is routed to the host that is running on another node because the NLB does not have routing algorithm to deliver messages to the host that is already running the instance.</span></span> <span data-ttu-id="828e4-130">Al recibir el mensaje, el segundo host intenta cargar la instancia de flujo de trabajo y recibe <xref:System.Runtime.DurableInstancing.InstanceLockedException> porque el primer host tiene un bloqueo en la instancia.</span><span class="sxs-lookup"><span data-stu-id="828e4-130">Upon receiving the message, the second host attempts to load the workflow instance and receives the <xref:System.Runtime.DurableInstancing.InstanceLockedException> because the first host has a lock on the instance.</span></span> <span data-ttu-id="828e4-131">El primer host desbloqueará la instancia cuando haya terminado de procesar el primer mensaje y el segundo host adquirirá el bloqueo cuando lo vuelva a intentar la próxima vez, cargue la instancia y procese el segundo mensaje.</span><span class="sxs-lookup"><span data-stu-id="828e4-131">The first host unlocks the instance when it is finished with processing the first message and the second host acquires the lock when it retries the next time, loads the instance, and processes the second message.</span></span>
