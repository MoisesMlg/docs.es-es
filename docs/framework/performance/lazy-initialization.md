---
title: Inicialización diferida
description: Explore la inicialización diferida en .NET, una mejora del rendimiento que significa que la creación de un objeto se aplaza hasta que el objeto se use por primera vez.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 6cbda2bd45f2cdc5085ca30af878824069fb019a
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96242180"
---
# <a name="lazy-initialization"></a><span data-ttu-id="55a72-103">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="55a72-103">Lazy Initialization</span></span>

<span data-ttu-id="55a72-104">La *inicialización diferida* de un objeto implica que su creación se aplaza hasta que se usa por primera vez.</span><span class="sxs-lookup"><span data-stu-id="55a72-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="55a72-105">(En este tema, los términos *inicialización diferida* y *creación de instancias diferidas* son sinónimos). La inicialización diferida se utiliza principalmente para mejorar el rendimiento, evitar el cálculo excesivo y reducir los requisitos de memoria del programa.</span><span class="sxs-lookup"><span data-stu-id="55a72-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="55a72-106">Estos son los escenarios más comunes:</span><span class="sxs-lookup"><span data-stu-id="55a72-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="55a72-107">Cuando hay un objeto costoso de crear y es posible que el programa no lo use.</span><span class="sxs-lookup"><span data-stu-id="55a72-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="55a72-108">Por ejemplo, supongamos que tiene en memoria un objeto `Customer` con una propiedad `Orders` que contiene una matriz grande de objetos `Order` que, para inicializarse, requieren una conexión de base de datos.</span><span class="sxs-lookup"><span data-stu-id="55a72-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="55a72-109">Si el usuario nunca solicita que se muestre Orders y nunca usa los datos en un cálculo, no hay ninguna razón para usar la memoria del sistema o ciclos de cálculos para crearlo.</span><span class="sxs-lookup"><span data-stu-id="55a72-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="55a72-110">Mediante el uso de `Lazy<Orders>` para declarar el objeto `Orders` para la inicialización diferida, puede evitar desperdiciar recursos del sistema si no se usa el objeto.</span><span class="sxs-lookup"><span data-stu-id="55a72-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="55a72-111">Cuando hay un objeto costoso de crear y quiere diferir su creación hasta después de que se hayan completado otras operaciones costosas.</span><span class="sxs-lookup"><span data-stu-id="55a72-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="55a72-112">Por ejemplo, supongamos que el programa carga varias instancias de objeto cuando se inicia, pero solo se necesitan de inmediato algunas de ellas.</span><span class="sxs-lookup"><span data-stu-id="55a72-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="55a72-113">Puede mejorar el rendimiento de inicio del programa si difiere la inicialización de los objetos que no son necesarios hasta que se hayan creado los objetos necesarios.</span><span class="sxs-lookup"><span data-stu-id="55a72-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="55a72-114">Aunque puede escribir su propio código para llevar a cabo la inicialización diferida, recomendamos que use <xref:System.Lazy%601> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="55a72-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="55a72-115"><xref:System.Lazy%601> y sus tipos relacionados también admiten la seguridad para subprocesos y ofrecen una directiva coherente de propagación de excepciones.</span><span class="sxs-lookup"><span data-stu-id="55a72-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="55a72-116">En la tabla siguiente se muestran los tipos que .NET Framework versión 4 proporciona para habilitar la inicialización diferida en distintos escenarios.</span><span class="sxs-lookup"><span data-stu-id="55a72-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="55a72-117">Tipo</span><span class="sxs-lookup"><span data-stu-id="55a72-117">Type</span></span>|<span data-ttu-id="55a72-118">Descripción</span><span class="sxs-lookup"><span data-stu-id="55a72-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="55a72-119">Clase contenedora que proporciona semántica de inicialización diferida para cualquier biblioteca de clases o tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="55a72-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="55a72-120">Se parece a <xref:System.Lazy%601>, con la diferencia de que proporciona semántica de inicialización diferida para cada subproceso local.</span><span class="sxs-lookup"><span data-stu-id="55a72-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="55a72-121">Cada subproceso tiene acceso a su propio valor único.</span><span class="sxs-lookup"><span data-stu-id="55a72-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="55a72-122">Proporciona métodos `static` avanzados (`Shared` en Visual Basic) para la inicialización diferida de objetos sin la sobrecarga de una clase.</span><span class="sxs-lookup"><span data-stu-id="55a72-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="55a72-123">Inicialización diferida básica</span><span class="sxs-lookup"><span data-stu-id="55a72-123">Basic Lazy Initialization</span></span>  

 <span data-ttu-id="55a72-124">Para definir un tipo con inicialización diferida, como `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` en Visual Basic), como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="55a72-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="55a72-125">Si no se pasa ningún delegado en el constructor <xref:System.Lazy%601>, el tipo contenedor se crea mediante <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> cuando se tiene acceso por primera vez a la propiedad de valor.</span><span class="sxs-lookup"><span data-stu-id="55a72-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="55a72-126">Si el tipo no tiene un constructor sin parámetros, se produce una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="55a72-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="55a72-127">En el ejemplo siguiente, supongamos que `Orders` es una clase que contiene una matriz de objetos `Order` recuperados de una base de datos.</span><span class="sxs-lookup"><span data-stu-id="55a72-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="55a72-128">Un objeto `Customer` contiene una instancia de `Orders`, pero en función de las acciones del usuario, los datos del objeto `Orders` podrían no ser necesarios.</span><span class="sxs-lookup"><span data-stu-id="55a72-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="55a72-129">También se puede pasar un delegado en el constructor <xref:System.Lazy%601> que invoca una sobrecarga de constructor específica en el tipo ajustado en tiempo de creación y realizar los pasos de inicialización que se requieran, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="55a72-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="55a72-130">Una vez que se ha creado el objeto diferido, no se crea ninguna instancia de `Orders` mientras no se tenga acceso por primera vez a la propiedad <xref:System.Lazy%601.Value%2A> de la variable Lazy.</span><span class="sxs-lookup"><span data-stu-id="55a72-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="55a72-131">En el primer acceso, el tipo encapsulado se crea y se devuelve, y se almacena para cualquier acceso futuro.</span><span class="sxs-lookup"><span data-stu-id="55a72-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="55a72-132">Un objeto <xref:System.Lazy%601> siempre devuelve el mismo objeto o valor con el que se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="55a72-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="55a72-133">Por lo tanto, la propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55a72-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="55a72-134">Si <xref:System.Lazy%601.Value%2A> almacena un tipo de referencia, no se le puede asignar un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="55a72-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="55a72-135">(Sin embargo, puede cambiar el valor de sus propiedades y campos públicos configurables). Si <xref:System.Lazy%601.Value%2A> almacena un tipo de valor, no se puede modificar su valor.</span><span class="sxs-lookup"><span data-stu-id="55a72-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="55a72-136">Aun así, puede crear una variable si invoca de nuevo el constructor de la variable con argumentos nuevos.</span><span class="sxs-lookup"><span data-stu-id="55a72-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="55a72-137">La nueva instancia diferida, al igual que la anterior, no crea instancias de `Orders` mientras no se tenga acceso por primera vez a su propiedad <xref:System.Lazy%601.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="55a72-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="55a72-138">Inicialización segura para subprocesos</span><span class="sxs-lookup"><span data-stu-id="55a72-138">Thread-Safe Initialization</span></span>  

 <span data-ttu-id="55a72-139">De forma predeterminada, los objetos <xref:System.Lazy%601> son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="55a72-140">Es decir, si el constructor no especifica el tipo de seguridad para subprocesos, los objetos <xref:System.Lazy%601> que crea son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="55a72-141">En escenarios multiproceso, el primer subproceso que tiene acceso a la propiedad <xref:System.Lazy%601.Value%2A> de un objeto <xref:System.Lazy%601> seguro para subprocesos lo inicializa para todos los accesos siguientes en todos los subprocesos, y todos los subprocesos comparten los mismos datos.</span><span class="sxs-lookup"><span data-stu-id="55a72-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="55a72-142">Por lo tanto, no importa qué subproceso inicializa el objeto y las condiciones de carrera son benignas.</span><span class="sxs-lookup"><span data-stu-id="55a72-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="55a72-143">Puede ampliar esta coherencia a las condiciones de error mediante el uso del almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="55a72-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="55a72-144">Para obtener más información, vea la próxima sección titulada [Excepciones en objetos diferidos](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="55a72-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="55a72-145">En el ejemplo siguiente se muestra que la instancia `Lazy<int>` tiene el mismo valor para tres subprocesos independientes.</span><span class="sxs-lookup"><span data-stu-id="55a72-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="55a72-146">Si necesita datos independientes en cada subproceso, use el tipo <xref:System.Threading.ThreadLocal%601>, como se describe más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="55a72-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="55a72-147">Algunos constructores <xref:System.Lazy%601> tienen un parámetro booleano denominado `isThreadSafe` que se usa para especificar si se obtendrá acceso a la propiedad <xref:System.Lazy%601.Value%2A> desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="55a72-148">Si piensa tener acceso a la propiedad desde un solo subproceso, pase `false` para obtener una pequeña mejora en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="55a72-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="55a72-149">Si piensa tener acceso a la propiedad desde varios subprocesos, pase `true` para indicarle a la instancia <xref:System.Lazy%601> que controle correctamente las condiciones de carrera en las que un subproceso produce una excepción durante la inicialización.</span><span class="sxs-lookup"><span data-stu-id="55a72-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="55a72-150">Algunos constructores <xref:System.Lazy%601> tienen un parámetro <xref:System.Threading.LazyThreadSafetyMode> denominado `mode`.</span><span class="sxs-lookup"><span data-stu-id="55a72-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="55a72-151">Estos constructores proporcionan un modo adicional de seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="55a72-152">En la tabla siguiente se muestra la manera en que la seguridad para subprocesos de un objeto <xref:System.Lazy%601> se ve afectada por los parámetros del constructor que especifican la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="55a72-153">Cada constructor tiene como máximo un parámetro de este tipo.</span><span class="sxs-lookup"><span data-stu-id="55a72-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="55a72-154">Seguridad para subprocesos del objeto</span><span class="sxs-lookup"><span data-stu-id="55a72-154">Thread safety of the object</span></span>|<span data-ttu-id="55a72-155">`LazyThreadSafetyMode``mode`parámetro de</span><span class="sxs-lookup"><span data-stu-id="55a72-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="55a72-156">Parámetro booleano `isThreadSafe`</span><span class="sxs-lookup"><span data-stu-id="55a72-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="55a72-157">Sin parámetros de seguridad para subprocesos</span><span class="sxs-lookup"><span data-stu-id="55a72-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="55a72-158">Totalmente seguro para subprocesos; solo intenta inicializar el valor un subproceso de cada vez.</span><span class="sxs-lookup"><span data-stu-id="55a72-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="55a72-159">Sí.</span><span class="sxs-lookup"><span data-stu-id="55a72-159">Yes.</span></span>|  
|<span data-ttu-id="55a72-160">No es seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="55a72-161">No es aplicable.</span><span class="sxs-lookup"><span data-stu-id="55a72-161">Not applicable.</span></span>|  
|<span data-ttu-id="55a72-162">Totalmente seguro para subprocesos; los subprocesos se apresuran a inicializar el valor.</span><span class="sxs-lookup"><span data-stu-id="55a72-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="55a72-163">No es aplicable.</span><span class="sxs-lookup"><span data-stu-id="55a72-163">Not applicable.</span></span>|<span data-ttu-id="55a72-164">No es aplicable.</span><span class="sxs-lookup"><span data-stu-id="55a72-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="55a72-165">Como se muestra en la tabla, especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para el parámetro `mode` equivale a especificar `true` para el parámetro `isThreadSafe`, y especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> equivale a especificar `false`.</span><span class="sxs-lookup"><span data-stu-id="55a72-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="55a72-166">Si se especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, varios subprocesos pueden intentar inicializar la instancia <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="55a72-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="55a72-167">Solo un subproceso puede ganar esta carrera, y los demás subprocesos recibirán el valor que haya inicializado el subproceso ganador.</span><span class="sxs-lookup"><span data-stu-id="55a72-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="55a72-168">Si se produce una excepción en un subproceso durante la inicialización, dicho subproceso no recibe el valor establecido por el subproceso ganador.</span><span class="sxs-lookup"><span data-stu-id="55a72-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="55a72-169">Las excepciones no se almacenan en caché, por lo que un intento posterior para tener acceso a la propiedad <xref:System.Lazy%601.Value%2A> puede dar lugar a un inicialización correcta.</span><span class="sxs-lookup"><span data-stu-id="55a72-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="55a72-170">Esto difiere de la manera en que se tratan las excepciones en otros modos, como se describe en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="55a72-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="55a72-171">Para obtener más información, vea la enumeración <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="55a72-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>

## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="55a72-172">Excepciones en objetos diferidos</span><span class="sxs-lookup"><span data-stu-id="55a72-172">Exceptions in Lazy Objects</span></span>  

 <span data-ttu-id="55a72-173">Como ya se ha indicado, un objeto <xref:System.Lazy%601> siempre devuelve el mismo objeto o valor con el que se ha inicializado y, por tanto, la propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55a72-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="55a72-174">Si habilita el almacenamiento en caché de excepciones, esta inmutabilidad también se aplica al comportamiento de las excepciones.</span><span class="sxs-lookup"><span data-stu-id="55a72-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="55a72-175">Si un objeto con inicialización diferida tiene habilitado el almacenamiento en caché de excepciones y produce una excepción desde su método de inicialización cuando <xref:System.Lazy%601.Value%2A> se obtiene acceso por primera vez a la propiedad, se produce la misma excepción en cada intento posterior de acceder a la <xref:System.Lazy%601.Value%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="55a72-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="55a72-176">En otras palabras, el constructor del tipo encapsulado nunca se vuelve a invocar, ni siquiera en escenarios multiproceso.</span><span class="sxs-lookup"><span data-stu-id="55a72-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="55a72-177">Por lo tanto, el objeto <xref:System.Lazy%601> no puede producir una excepción en un acceso y devolver un valor en un acceso posterior.</span><span class="sxs-lookup"><span data-stu-id="55a72-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="55a72-178">El almacenamiento en caché de excepciones se habilita cuando se usa cualquier constructor <xref:System.Lazy%601?displayProperty=nameWithType> que toma un método de inicialización (un parámetro `valueFactory`); por ejemplo, se habilita cuando se usa el constructor `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="55a72-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="55a72-179">Si el constructor también toma un valor <xref:System.Threading.LazyThreadSafetyMode> (un parámetro `mode`), especifique <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> o <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="55a72-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="55a72-180">Al especificar un método de inicialización, se permite el almacenamiento en caché de excepciones para estos dos modos.</span><span class="sxs-lookup"><span data-stu-id="55a72-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="55a72-181">El método de inicialización puede ser muy simple.</span><span class="sxs-lookup"><span data-stu-id="55a72-181">The initialization method can be very simple.</span></span> <span data-ttu-id="55a72-182">Por ejemplo, podría llamar al constructor sin parámetros para `T` : `new Lazy<Contents>(() => new Contents(), mode)` en C# o `New Lazy(Of Contents)(Function() New Contents())` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="55a72-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="55a72-183">Si usa un constructor <xref:System.Lazy%601?displayProperty=nameWithType> que no especifica un método de inicialización, las excepciones que inicie el constructor sin parámetros para `T` no se almacenarán en caché.</span><span class="sxs-lookup"><span data-stu-id="55a72-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="55a72-184">Para obtener más información, vea la enumeración <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="55a72-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="55a72-185">Si crea un objeto <xref:System.Lazy%601> con el parámetro de constructor `isThreadSafe` establecido en `false` o el parámetro de constructor `mode` establecido en <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, debe tener acceso al objeto <xref:System.Lazy%601> desde un subproceso o proporcionar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="55a72-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="55a72-186">Esto se aplica a todos los aspectos del objeto, incluido el almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="55a72-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="55a72-187">Como ya se ha indicado en la sección anterior, los objetos <xref:System.Lazy%601> creados al especificar <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> tratan las excepciones de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="55a72-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="55a72-188">Con <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, varios subprocesos pueden competir para inicializar la instancia <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="55a72-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="55a72-189">En este caso, las excepciones no se almacenan en caché y los intentos para obtener acceso a la propiedad <xref:System.Lazy%601.Value%2A> pueden continuar hasta que se complete la inicialización.</span><span class="sxs-lookup"><span data-stu-id="55a72-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="55a72-190">En la tabla siguiente se resume la forma en que los constructores <xref:System.Lazy%601> controlan el almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="55a72-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="55a72-191">Constructor</span><span class="sxs-lookup"><span data-stu-id="55a72-191">Constructor</span></span>|<span data-ttu-id="55a72-192">Modo de seguridad para subprocesos</span><span class="sxs-lookup"><span data-stu-id="55a72-192">Thread safety mode</span></span>|<span data-ttu-id="55a72-193">Usa método de inicialización</span><span class="sxs-lookup"><span data-stu-id="55a72-193">Uses initialization method</span></span>|<span data-ttu-id="55a72-194">Las excepciones se almacenan en caché</span><span class="sxs-lookup"><span data-stu-id="55a72-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="55a72-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="55a72-195">Lazy(T)()</span></span>|<span data-ttu-id="55a72-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="55a72-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="55a72-197">No</span><span class="sxs-lookup"><span data-stu-id="55a72-197">No</span></span>|<span data-ttu-id="55a72-198">No</span><span class="sxs-lookup"><span data-stu-id="55a72-198">No</span></span>|  
|<span data-ttu-id="55a72-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="55a72-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="55a72-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="55a72-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="55a72-201">Sí</span><span class="sxs-lookup"><span data-stu-id="55a72-201">Yes</span></span>|<span data-ttu-id="55a72-202">Sí</span><span class="sxs-lookup"><span data-stu-id="55a72-202">Yes</span></span>|  
|<span data-ttu-id="55a72-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="55a72-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="55a72-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="55a72-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="55a72-205">No</span><span class="sxs-lookup"><span data-stu-id="55a72-205">No</span></span>|<span data-ttu-id="55a72-206">No</span><span class="sxs-lookup"><span data-stu-id="55a72-206">No</span></span>|  
|<span data-ttu-id="55a72-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="55a72-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="55a72-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="55a72-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="55a72-209">Sí</span><span class="sxs-lookup"><span data-stu-id="55a72-209">Yes</span></span>|<span data-ttu-id="55a72-210">Sí</span><span class="sxs-lookup"><span data-stu-id="55a72-210">Yes</span></span>|  
|<span data-ttu-id="55a72-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="55a72-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="55a72-212">Especificado por el usuario</span><span class="sxs-lookup"><span data-stu-id="55a72-212">User-specified</span></span>|<span data-ttu-id="55a72-213">No</span><span class="sxs-lookup"><span data-stu-id="55a72-213">No</span></span>|<span data-ttu-id="55a72-214">No</span><span class="sxs-lookup"><span data-stu-id="55a72-214">No</span></span>|  
|<span data-ttu-id="55a72-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="55a72-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="55a72-216">Especificado por el usuario</span><span class="sxs-lookup"><span data-stu-id="55a72-216">User-specified</span></span>|<span data-ttu-id="55a72-217">Yes</span><span class="sxs-lookup"><span data-stu-id="55a72-217">Yes</span></span>|<span data-ttu-id="55a72-218">No si el usuario especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; en caso contrario, sí.</span><span class="sxs-lookup"><span data-stu-id="55a72-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="55a72-219">Implementar una propiedad con inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="55a72-219">Implementing a Lazy-Initialized Property</span></span>  

 <span data-ttu-id="55a72-220">Para implementar una propiedad pública mediante la inicialización diferida, defina el campo de respaldo de la propiedad como <xref:System.Lazy%601> y devuelva la propiedad <xref:System.Lazy%601.Value%2A> desde el descriptor de acceso `get` de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="55a72-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="55a72-221">La propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura; por lo tanto, la propiedad que la expone no tiene ningún descriptor de acceso `set`.</span><span class="sxs-lookup"><span data-stu-id="55a72-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="55a72-222">Si necesita una propiedad de lectura/escritura respaldada por un objeto <xref:System.Lazy%601>, el descriptor de acceso `set` debe crear un objeto <xref:System.Lazy%601> y asignarlo a la memoria auxiliar.</span><span class="sxs-lookup"><span data-stu-id="55a72-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="55a72-223">El descriptor de acceso `set` debe crear una expresión lambda que devuelva el nuevo valor de propiedad que se ha pasado al descriptor de acceso `set` y pasar dicha expresión lambda al constructor para el nuevo objeto <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="55a72-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="55a72-224">El siguiente acceso de la propiedad <xref:System.Lazy%601.Value%2A> provocará la inicialización del nuevo objeto <xref:System.Lazy%601>, y su propiedad <xref:System.Lazy%601.Value%2A> devolverá a partir de entonces el nuevo valor que se ha asignado a la propiedad.</span><span class="sxs-lookup"><span data-stu-id="55a72-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="55a72-225">El objetivo de este complicado proceso consiste en conservar las protecciones multiproceso integradas en <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="55a72-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="55a72-226">De lo contrario, los descriptores de acceso de propiedad tendrían que almacenar en caché el primer valor devuelto por la propiedad <xref:System.Lazy%601.Value%2A> y modificar solo el valor almacenado en caché, y usted tendría que escribir su propio código seguro para subprocesos para hacerlo.</span><span class="sxs-lookup"><span data-stu-id="55a72-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="55a72-227">Debido a las inicializaciones adicionales que requiere una propiedad de lectura/escritura respaldada por un objeto <xref:System.Lazy%601>, el rendimiento podría no ser aceptable.</span><span class="sxs-lookup"><span data-stu-id="55a72-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="55a72-228">Además, en función del escenario, podría ser necesaria una coordinación adicional para evitar condiciones de carrera entre los establecedores y los captadores.</span><span class="sxs-lookup"><span data-stu-id="55a72-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="55a72-229">Inicialización diferida local de subprocesos</span><span class="sxs-lookup"><span data-stu-id="55a72-229">Thread-Local Lazy Initialization</span></span>  

 <span data-ttu-id="55a72-230">En algunos escenarios multiproceso, podría interesarle asignarle a cada subproceso sus propios datos privados.</span><span class="sxs-lookup"><span data-stu-id="55a72-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="55a72-231">Estos datos se denominan *datos locales de subproceso*.</span><span class="sxs-lookup"><span data-stu-id="55a72-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="55a72-232">En .NET Framework versión 3.5 y anteriores, se podía aplicar el atributo `ThreadStatic` a una variable estática para convertirla en una variable local de subproceso.</span><span class="sxs-lookup"><span data-stu-id="55a72-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="55a72-233">Pero el uso del atributo `ThreadStatic` puede producir pequeños errores.</span><span class="sxs-lookup"><span data-stu-id="55a72-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="55a72-234">Por ejemplo, incluso las instrucciones de inicialización básicas harán que la variable solo se inicialice en el primer subproceso que tenga acceso a ella, tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="55a72-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="55a72-235">En todos los demás subprocesos, la variable se inicializará mediante su valor predeterminado (cero).</span><span class="sxs-lookup"><span data-stu-id="55a72-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="55a72-236">Como alternativa en .NET Framework versión 4, puede usar el tipo <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> para crear una variable local de subproceso basada en instancias que se inicialice en todos los subprocesos mediante el delegado <xref:System.Action%601> que proporcione.</span><span class="sxs-lookup"><span data-stu-id="55a72-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="55a72-237">En el ejemplo siguiente, todos los subprocesos que tienen acceso a `counter` tendrán 1 como valor inicial.</span><span class="sxs-lookup"><span data-stu-id="55a72-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="55a72-238"><xref:System.Threading.ThreadLocal%601> encapsula el objeto de la misma manera que <xref:System.Lazy%601>, pero con estas diferencias básicas:</span><span class="sxs-lookup"><span data-stu-id="55a72-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="55a72-239">Cada subproceso inicializa la variable local de subproceso mediante sus propios datos privados, que no son accesibles desde otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="55a72-240">La propiedad <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> es de lectura y escritura y se puede modificar todas las veces que se quiera.</span><span class="sxs-lookup"><span data-stu-id="55a72-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="55a72-241">Esto puede afectar a la propagación de excepciones; por ejemplo, una operación `get` puede producir una excepción, pero la siguiente puede inicializar correctamente el valor.</span><span class="sxs-lookup"><span data-stu-id="55a72-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="55a72-242">Si no se proporciona ningún delegado de inicialización, <xref:System.Threading.ThreadLocal%601> inicializará su tipo encapsulado mediante el valor predeterminado del tipo.</span><span class="sxs-lookup"><span data-stu-id="55a72-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="55a72-243">En este sentido, <xref:System.Threading.ThreadLocal%601> es coherente con el atributo <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="55a72-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="55a72-244">En el ejemplo siguiente se muestra que cada subproceso que tiene acceso a la instancia `ThreadLocal<int>` obtiene su propia copia única de los datos.</span><span class="sxs-lookup"><span data-stu-id="55a72-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="55a72-245">Variables locales de subproceso en Parallel.For y ForEach</span><span class="sxs-lookup"><span data-stu-id="55a72-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  

 <span data-ttu-id="55a72-246">Cuando se usa el método <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> para iterar en los orígenes de datos en paralelo, puede usar las sobrecargas que tienen compatibilidad integrada con datos locales de subproceso.</span><span class="sxs-lookup"><span data-stu-id="55a72-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="55a72-247">En estos métodos, la localidad del subproceso se logra mediante el uso de delegados locales para crear los datos, obtener acceso a ellos y limpiarlos.</span><span class="sxs-lookup"><span data-stu-id="55a72-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="55a72-248">Para obtener más información, vea [Cómo: Escribir un bucle Parallel.For con variables locales de subproceso](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) y [Cómo: Escribir un bucle Parallel.ForEach con variables locales de partición](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="55a72-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="55a72-249">Usar la inicialización diferida para escenarios con poca sobrecarga</span><span class="sxs-lookup"><span data-stu-id="55a72-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  

 <span data-ttu-id="55a72-250">En los escenarios en los que tiene que inicializar de forma diferida un gran número de objetos, podría decidir que el proceso de encapsular cada objeto en un objeto <xref:System.Lazy%601> requiere demasiada memoria o demasiados recursos informáticos.</span><span class="sxs-lookup"><span data-stu-id="55a72-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="55a72-251">O bien, es posible que tenga requisitos estrictos sobre cómo se expone la inicialización diferida.</span><span class="sxs-lookup"><span data-stu-id="55a72-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="55a72-252">En tales casos, puede usar los métodos `static` (`Shared` en Visual Basic) de la clase <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> para inicializar de forma diferida cada objeto sin encapsularlo en una instancia de <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="55a72-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="55a72-253">En el ejemplo siguiente se da por supuesto que, en lugar de encapsular todo un objeto `Orders` en un objeto <xref:System.Lazy%601>, solo se inicializan de forma diferida los objetos `Order` individuales si son necesarios.</span><span class="sxs-lookup"><span data-stu-id="55a72-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="55a72-254">En este ejemplo, observe que el procedimiento de inicialización se invoca en cada iteración del bucle.</span><span class="sxs-lookup"><span data-stu-id="55a72-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="55a72-255">En escenarios multiproceso, el primer subproceso que invoca el procedimiento de inicialización es aquel cuyo valor ven todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="55a72-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="55a72-256">Los subprocesos posteriores también invocan el procedimiento de inicialización, pero sus resultados no se usan.</span><span class="sxs-lookup"><span data-stu-id="55a72-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="55a72-257">Si este tipo de condición de carrera potencial no es aceptable, use la sobrecarga de <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> que toma un argumento booleano y un objeto de sincronización.</span><span class="sxs-lookup"><span data-stu-id="55a72-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="55a72-258">Vea también</span><span class="sxs-lookup"><span data-stu-id="55a72-258">See also</span></span>

- [<span data-ttu-id="55a72-259">Principios básicos del subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="55a72-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="55a72-260">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="55a72-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="55a72-261">Biblioteca TPL</span><span class="sxs-lookup"><span data-stu-id="55a72-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="55a72-262">Procedimiento para realizar la inicialización diferida de objetos</span><span class="sxs-lookup"><span data-stu-id="55a72-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
