---
title: regiones de ejecución restringidas
description: Introducción a las regiones de ejecución restringidas (CER), que forman parte de un mecanismo para la creación de código administrado confiable.
ms.date: 03/30/2017
helpviewer_keywords:
- constrained execution regions
- CERs
ms.assetid: 99354547-39c1-4b0b-8553-938e8f8d1808
ms.openlocfilehash: 5014885e186b1fff16543c09d5652958f2463e3d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266862"
---
# <a name="constrained-execution-regions"></a><span data-ttu-id="a5812-103">regiones de ejecución restringidas</span><span class="sxs-lookup"><span data-stu-id="a5812-103">Constrained Execution Regions</span></span>

<span data-ttu-id="a5812-104">Una región de ejecución restringida (CER) es parte de un mecanismo para crear código administrado de confianza.</span><span class="sxs-lookup"><span data-stu-id="a5812-104">A constrained execution region (CER) is part of a mechanism for authoring reliable managed code.</span></span> <span data-ttu-id="a5812-105">Una CER define un área en la que Common Language Runtime (CLR) no puede producir excepciones fuera de banda que eviten que el código del área se ejecute en su totalidad.</span><span class="sxs-lookup"><span data-stu-id="a5812-105">A CER defines an area in which the common language runtime (CLR) is constrained from throwing out-of-band exceptions that would prevent the code in the area from executing in its entirety.</span></span> <span data-ttu-id="a5812-106">Dentro de esa región, el código de usuario no puede ejecutar código que pueda producir excepciones fuera de banda.</span><span class="sxs-lookup"><span data-stu-id="a5812-106">Within that region, user code is constrained from executing code that would result in the throwing of out-of-band exceptions.</span></span> <span data-ttu-id="a5812-107">El método <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> debe ir inmediatamente antes del bloque `try` y marca los bloques `catch`, `finally` y `fault` como regiones de ejecución restringidas.</span><span class="sxs-lookup"><span data-stu-id="a5812-107">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method must immediately precede a `try` block and marks `catch`, `finally`, and `fault` blocks as constrained execution regions.</span></span> <span data-ttu-id="a5812-108">Una vez marcada como región restringida, el código solo debe llamar a otro código con contratos de fiabilidad estables y no debe asignar ni realizar llamadas virtuales a métodos no preparados o no confiables a menos que esté preparado para controlar errores.</span><span class="sxs-lookup"><span data-stu-id="a5812-108">Once marked as a constrained region, code must only call other code with strong reliability contracts, and code should not allocate or make virtual calls to unprepared or unreliable methods unless the code is prepared to handle failures.</span></span> <span data-ttu-id="a5812-109">CLR retrasa las anulaciones de subprocesos del código que se está ejecutando en una CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-109">The CLR delays thread aborts for code that is executing in a CER.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="a5812-110">CER solo se admite en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a5812-110">CER is only supported in .NET Framework.</span></span> <span data-ttu-id="a5812-111">Este artículo no se aplica a .NET Core o .NET 5 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="a5812-111">This article doesn't apply to .NET Core or .NET 5 and above.</span></span>

 <span data-ttu-id="a5812-112">Las regiones de ejecución restringidas se usan de diferentes formas en CLR además de en un bloque anotado `try`, en concreto, finalizadores críticos que se ejecutan en clases derivadas de la clase <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> y código ejecutado mediante el método <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="a5812-112">Constrained execution regions are used in different forms in the CLR in addition to an annotated `try` block, notably critical finalizers executing in classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class and code executed using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
## <a name="cer-advance-preparation"></a><span data-ttu-id="a5812-113">Preparación anticipada de CER</span><span class="sxs-lookup"><span data-stu-id="a5812-113">CER Advance Preparation</span></span>  

 <span data-ttu-id="a5812-114">CLR prepara las CER de antemano para evitar situaciones de memoria insuficiente.</span><span class="sxs-lookup"><span data-stu-id="a5812-114">The CLR prepares CERs in advance to avoid out-of-memory conditions.</span></span> <span data-ttu-id="a5812-115">La preparación anticipada es necesaria para que CLR no provoque una situación de memoria insuficiente durante la compilación Just-In-Time o la carga de tipos.</span><span class="sxs-lookup"><span data-stu-id="a5812-115">Advance preparation is required so the CLR does not cause an out of memory condition during just-in-time compilation or type loading.</span></span>  
  
 <span data-ttu-id="a5812-116">Es necesario que el desarrollador indique que una región de código es una CER:</span><span class="sxs-lookup"><span data-stu-id="a5812-116">The developer is required to indicate that a code region is a CER:</span></span>  
  
- <span data-ttu-id="a5812-117">La región CER de nivel superior y los métodos del gráfico de llamadas completo que tienen el atributo <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> aplicado se preparan de antemano.</span><span class="sxs-lookup"><span data-stu-id="a5812-117">The top level CER region and methods in the full call graph that have the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute applied are prepared in advance.</span></span> <span data-ttu-id="a5812-118"><xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> solo puede declarar garantías de <xref:System.Runtime.ConstrainedExecution.Cer.Success> o <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span><span class="sxs-lookup"><span data-stu-id="a5812-118">The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> can only state guarantees of <xref:System.Runtime.ConstrainedExecution.Cer.Success> or <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span></span>  
  
- <span data-ttu-id="a5812-119">No es posible realizar la preparación anticipada de las llamadas que no se pueden determinar de forma estática, como la distribución virtual.</span><span class="sxs-lookup"><span data-stu-id="a5812-119">Advance preparation cannot be performed for calls that cannot be statically determined, such as virtual dispatch.</span></span> <span data-ttu-id="a5812-120">En estos casos use el método <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="a5812-120">Use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A> method in these cases.</span></span> <span data-ttu-id="a5812-121">Cuando se usa el método <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>, se debe aplicar el atributo <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> al código de limpieza.</span><span class="sxs-lookup"><span data-stu-id="a5812-121">When using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method, the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute should be applied to the clean up code.</span></span>  
  
## <a name="constraints"></a><span data-ttu-id="a5812-122">Restricciones</span><span class="sxs-lookup"><span data-stu-id="a5812-122">Constraints</span></span>  

 <span data-ttu-id="a5812-123">Los usuarios están limitados con respecto al tipo de código que pueden escribir en una CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-123">Users are constrained in the type of code they can write in a CER.</span></span> <span data-ttu-id="a5812-124">El código no puede producir una excepción fuera de banda, como la que podrían ocasionar las siguientes operaciones:</span><span class="sxs-lookup"><span data-stu-id="a5812-124">The code cannot cause an out-of-band exception, such as might result from the following operations:</span></span>  
  
- <span data-ttu-id="a5812-125">Asignación explícita.</span><span class="sxs-lookup"><span data-stu-id="a5812-125">Explicit allocation.</span></span>  
  
- <span data-ttu-id="a5812-126">Conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="a5812-126">Boxing.</span></span>  
  
- <span data-ttu-id="a5812-127">Adquisición de un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="a5812-127">Acquiring a lock.</span></span>  
  
- <span data-ttu-id="a5812-128">Llamada a métodos no preparados de forma virtual.</span><span class="sxs-lookup"><span data-stu-id="a5812-128">Calling unprepared methods virtually.</span></span>  
  
- <span data-ttu-id="a5812-129">Llamada a métodos con un contrato de fiabilidad débil o inexistente.</span><span class="sxs-lookup"><span data-stu-id="a5812-129">Calling methods with a weak or nonexistent reliability contract.</span></span>  
  
 <span data-ttu-id="a5812-130">En la versión 2.0 de .NET Framework, estas restricciones son directrices.</span><span class="sxs-lookup"><span data-stu-id="a5812-130">In the .NET Framework version 2.0, these constraints are guidelines.</span></span> <span data-ttu-id="a5812-131">Los diagnósticos se proporcionan a través de herramientas de análisis de código.</span><span class="sxs-lookup"><span data-stu-id="a5812-131">Diagnostics are provided through code analysis tools.</span></span>  
  
## <a name="reliability-contracts"></a><span data-ttu-id="a5812-132">Contratos de fiabilidad</span><span class="sxs-lookup"><span data-stu-id="a5812-132">Reliability Contracts</span></span>  

 <span data-ttu-id="a5812-133"><xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> es un atributo personalizado que documenta las garantías de fiabilidad y el estado de daños de un método determinado.</span><span class="sxs-lookup"><span data-stu-id="a5812-133">The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> is a custom attribute that documents the reliability guarantees and the corruption state of a given method.</span></span>  
  
### <a name="reliability-guarantees"></a><span data-ttu-id="a5812-134">Garantías de fiabilidad</span><span class="sxs-lookup"><span data-stu-id="a5812-134">Reliability Guarantees</span></span>  

 <span data-ttu-id="a5812-135">Las garantías de fiabilidad, representadas por valores de enumeración <xref:System.Runtime.ConstrainedExecution.Cer>, indican el grado de fiabilidad de un método determinado:</span><span class="sxs-lookup"><span data-stu-id="a5812-135">Reliability guarantees, represented by <xref:System.Runtime.ConstrainedExecution.Cer> enumeration values, indicate the degree of reliability of a given method:</span></span>  
  
- <span data-ttu-id="a5812-136"><xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span><span class="sxs-lookup"><span data-stu-id="a5812-136"><xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.</span></span> <span data-ttu-id="a5812-137">En condiciones excepcionales, se puede producir un error en el método.</span><span class="sxs-lookup"><span data-stu-id="a5812-137">Under exceptional conditions, the method might fail.</span></span> <span data-ttu-id="a5812-138">En este caso, el método informa al método de la llamada de si esta se ha realizado correctamente o no.</span><span class="sxs-lookup"><span data-stu-id="a5812-138">In this case, the method reports back to the calling method whether it succeeded or failed.</span></span> <span data-ttu-id="a5812-139">El método debe estar incluido en una CER para garantizar que puede notificar el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="a5812-139">The method must be contained in a CER to ensure that it can report the return value.</span></span>  
  
- <span data-ttu-id="a5812-140"><xref:System.Runtime.ConstrainedExecution.Cer.None>.</span><span class="sxs-lookup"><span data-stu-id="a5812-140"><xref:System.Runtime.ConstrainedExecution.Cer.None>.</span></span> <span data-ttu-id="a5812-141">El método, tipo o ensamblado no tiene ningún concepto de una CER y lo más probable es que no sea seguro llamar desde dentro de una CER sin mitigación significativa de daños de estado.</span><span class="sxs-lookup"><span data-stu-id="a5812-141">The method, type, or assembly has no concept of a CER and is most likely not safe to call within a CER without substantial mitigation from state corruption.</span></span> <span data-ttu-id="a5812-142">No se aprovecha de las garantías de la CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-142">It does not take advantage of CER guarantees.</span></span> <span data-ttu-id="a5812-143">Esto implica lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a5812-143">This implies the following:</span></span>  
  
    1. <span data-ttu-id="a5812-144">En condiciones excepcionales, se puede producir un error en el método.</span><span class="sxs-lookup"><span data-stu-id="a5812-144">Under exceptional conditions the method might fail.</span></span>  
  
    2. <span data-ttu-id="a5812-145">El método podría o no informar de que se ha producido un error.</span><span class="sxs-lookup"><span data-stu-id="a5812-145">The method might or might not report that it failed.</span></span>  
  
    3. <span data-ttu-id="a5812-146">El método no se escribe para usar una CER, el escenario más probable.</span><span class="sxs-lookup"><span data-stu-id="a5812-146">The method is not written to use a CER, the most likely scenario.</span></span>  
  
    4. <span data-ttu-id="a5812-147">Si un método, tipo o ensamblado no se identifica explícitamente como correcto, se identifica implícitamente como <xref:System.Runtime.ConstrainedExecution.Cer.None>.</span><span class="sxs-lookup"><span data-stu-id="a5812-147">If a method, type, or assembly is not explicitly identified to succeed, it is implicitly identified as <xref:System.Runtime.ConstrainedExecution.Cer.None>.</span></span>  
  
- <span data-ttu-id="a5812-148"><xref:System.Runtime.ConstrainedExecution.Cer.Success>.</span><span class="sxs-lookup"><span data-stu-id="a5812-148"><xref:System.Runtime.ConstrainedExecution.Cer.Success>.</span></span> <span data-ttu-id="a5812-149">En condiciones excepcionales, se garantiza que el método será correcto.</span><span class="sxs-lookup"><span data-stu-id="a5812-149">Under exceptional conditions, the method is guaranteed to succeed.</span></span> <span data-ttu-id="a5812-150">Para lograr este nivel de fiabilidad, siempre debería crear una CER alrededor del método al que se llama, incluso cuando se llama desde dentro de una región no CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-150">To achieve this level of reliability you should always construct a CER around the method that is called, even when it is called from within a non-CER region.</span></span> <span data-ttu-id="a5812-151">Un método es correcto si logra lo que pretendía, aunque la corrección se puede ver de forma subjetiva.</span><span class="sxs-lookup"><span data-stu-id="a5812-151">A method is successful if it accomplishes what is intended, although success can be viewed subjectively.</span></span> <span data-ttu-id="a5812-152">Por ejemplo, marcar Count con `ReliabilityContractAttribute(Cer.Success)` implica que cuando se ejecuta en una CER, siempre devuelve un recuento del número de elementos de <xref:System.Collections.ArrayList> y que nunca puede dejar los campos internos en un estado indeterminado.</span><span class="sxs-lookup"><span data-stu-id="a5812-152">For example, marking Count with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref:System.Collections.ArrayList> and it can never leave the internal fields in an undetermined state.</span></span>  <span data-ttu-id="a5812-153">Pero el método <xref:System.Threading.Interlocked.CompareExchange%2A> también está marcado como correcto, con la asunción de que correcto puede significar que el valor no se ha podido reemplazar por un nuevo valor a causa de una condición de carrera.</span><span class="sxs-lookup"><span data-stu-id="a5812-153">However, the <xref:System.Threading.Interlocked.CompareExchange%2A> method is marked as success as well, with the understanding that success may mean the value could not be replaced with a new value due to a race condition.</span></span>  <span data-ttu-id="a5812-154">El punto clave es que el método se comporta de la manera en que se ha documentado que lo hará y no es necesario escribir código de la CER para esperar ningún comportamiento inusual más allá del aspecto que tendría un código correcto pero no confiable.</span><span class="sxs-lookup"><span data-stu-id="a5812-154">The key point is that the method behaves in the way it is documented to behave, and CER code does not need to be written to expect any unusual behavior beyond what correct but unreliable code would look like.</span></span>  
  
### <a name="corruption-levels"></a><span data-ttu-id="a5812-155">Niveles de daños</span><span class="sxs-lookup"><span data-stu-id="a5812-155">Corruption levels</span></span>  

 <span data-ttu-id="a5812-156">Los niveles de daños, representados por valores de enumeración <xref:System.Runtime.ConstrainedExecution.Consistency>, indican cuánto podría estar dañado en un entorno determinado:</span><span class="sxs-lookup"><span data-stu-id="a5812-156">Corruption levels, represented by <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration values, indicate how much state may be corrupted in a given environment:</span></span>  
  
- <span data-ttu-id="a5812-157"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a5812-157"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>.</span></span> <span data-ttu-id="a5812-158">En condiciones excepcionales, Common Language Runtime (CLR) no ofrece ninguna garantía con respecto a la coherencia del estado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a5812-158">Under exceptional conditions, the common language runtime (CLR) makes no guarantees regarding state consistency in the current application domain.</span></span>  
  
- <span data-ttu-id="a5812-159"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>.</span><span class="sxs-lookup"><span data-stu-id="a5812-159"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>.</span></span> <span data-ttu-id="a5812-160">En condiciones excepcionales, se garantiza que el método limita los daños de estado a la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="a5812-160">Under exceptional conditions, the method is guaranteed to limit state corruption to the current instance.</span></span>  
  
- <span data-ttu-id="a5812-161"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>. En condiciones excepcionales, CLR no ofrece ninguna garantía con respecto a la coherencia del estado; es decir, la condición podría dañar el proceso.</span><span class="sxs-lookup"><span data-stu-id="a5812-161"><xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>, Under exceptional conditions, the CLR makes no guarantees regarding state consistency; that is, the condition might corrupt the process.</span></span>  
  
- <span data-ttu-id="a5812-162"><xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>.</span><span class="sxs-lookup"><span data-stu-id="a5812-162"><xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>.</span></span> <span data-ttu-id="a5812-163">En condiciones excepcionales, se garantiza que el método no dañe el estado.</span><span class="sxs-lookup"><span data-stu-id="a5812-163">Under exceptional conditions, the method is guaranteed not to corrupt state.</span></span>  
  
## <a name="reliability-trycatchfinally"></a><span data-ttu-id="a5812-164">try/catch/finally de fiabilidad</span><span class="sxs-lookup"><span data-stu-id="a5812-164">Reliability try/catch/finally</span></span>  

 <span data-ttu-id="a5812-165">`try/catch/finally` de fiabilidad es un mecanismo de control de excepciones con el mismo nivel de garantías de previsibilidad que la versión no administrada.</span><span class="sxs-lookup"><span data-stu-id="a5812-165">The reliability `try/catch/finally` is an exception handling mechanism with the same level of predictability guarantees as the unmanaged version.</span></span> <span data-ttu-id="a5812-166">El bloque `catch/finally` es la CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-166">The `catch/finally` block is the CER.</span></span> <span data-ttu-id="a5812-167">Los métodos del bloque necesitan preparación anticipada y deben ser no interrumpibles.</span><span class="sxs-lookup"><span data-stu-id="a5812-167">Methods in the block require advance preparation and must be noninterruptible.</span></span>  
  
 <span data-ttu-id="a5812-168">En la versión 2.0 de .NET Framework, el código informa al tiempo de ejecución de que un elemento try es de confianza mediante una llamada al elemento <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> inmediatamente anterior a un bloque try.</span><span class="sxs-lookup"><span data-stu-id="a5812-168">In the .NET Framework version 2.0, code informs the runtime that a try is reliable by calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> immediately preceding a try block.</span></span> <span data-ttu-id="a5812-169"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> es miembro de <xref:System.Runtime.CompilerServices.RuntimeHelpers>, una clase de soporte del compilador.</span><span class="sxs-lookup"><span data-stu-id="a5812-169"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> is a member of <xref:System.Runtime.CompilerServices.RuntimeHelpers>, a compiler support class.</span></span> <span data-ttu-id="a5812-170">Llame a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directamente pendiente de disponibilidad mediante compiladores.</span><span class="sxs-lookup"><span data-stu-id="a5812-170">Call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directly pending its availability through compilers.</span></span>  
  
## <a name="noninterruptible-regions"></a><span data-ttu-id="a5812-171">Regiones no interrumpibles</span><span class="sxs-lookup"><span data-stu-id="a5812-171">Noninterruptible Regions</span></span>  

 <span data-ttu-id="a5812-172">Una región no interrumpible agrupa un conjunto de instrucciones en una CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-172">A noninterruptible region groups a set of instructions into a CER.</span></span>  
  
 <span data-ttu-id="a5812-173">En .NET Framework versión 2.0, pendiente de disponibilidad mediante compatibilidad del compilador, el código de usuario crea regiones no interrumpibles con un elemento try/catch/finally de confianza que contiene un bloque try/catch vacío precedido por una llamada al método <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="a5812-173">In .NET Framework version 2.0, pending availability through compiler support, user code creates non-interruptible regions with a reliable try/catch/finally that contains an empty try/catch block preceded by a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method call.</span></span>  
  
## <a name="critical-finalizer-object"></a><span data-ttu-id="a5812-174">Critical Finalizer Object</span><span class="sxs-lookup"><span data-stu-id="a5812-174">Critical Finalizer Object</span></span>  

 <span data-ttu-id="a5812-175">Un elemento <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> garantiza que la recolección de elementos no utilizados va a ejecutar el finalizador.</span><span class="sxs-lookup"><span data-stu-id="a5812-175">A <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> guarantees that garbage collection will execute the finalizer.</span></span> <span data-ttu-id="a5812-176">Tras la asignación, el finalizador y su gráfico de llamadas se preparan de antemano.</span><span class="sxs-lookup"><span data-stu-id="a5812-176">Upon allocation, the finalizer and its call graph are prepared in advance.</span></span> <span data-ttu-id="a5812-177">El método finalizador se ejecuta en una CER y debe obedecer todas las restricciones de las CER y los finalizadores.</span><span class="sxs-lookup"><span data-stu-id="a5812-177">The finalizer method executes in a CER, and must obey all the constraints on CERs and finalizers.</span></span>  
  
 <span data-ttu-id="a5812-178">Se garantiza que el finalizador de todos los tipos que heredan de <xref:System.Runtime.InteropServices.SafeHandle> y <xref:System.Runtime.InteropServices.CriticalHandle> se ejecuta dentro de una CER.</span><span class="sxs-lookup"><span data-stu-id="a5812-178">Any types inheriting from <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> are guaranteed to have their finalizer execute within a CER.</span></span> <span data-ttu-id="a5812-179">Implemente <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> en clases derivadas <xref:System.Runtime.InteropServices.SafeHandle> para ejecutar cualquier código necesario para liberar el controlador.</span><span class="sxs-lookup"><span data-stu-id="a5812-179">Implement <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> in <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span>  
  
## <a name="code-not-permitted-in-cers"></a><span data-ttu-id="a5812-180">Código no permitido en las CER</span><span class="sxs-lookup"><span data-stu-id="a5812-180">Code Not Permitted in CERs</span></span>  

 <span data-ttu-id="a5812-181">En las CER no se permiten las operaciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="a5812-181">The following operations are not permitted in CERs:</span></span>  
  
- <span data-ttu-id="a5812-182">Asignaciones explícitas.</span><span class="sxs-lookup"><span data-stu-id="a5812-182">Explicit allocations.</span></span>  
  
- <span data-ttu-id="a5812-183">Adquisición de un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="a5812-183">Acquiring a lock.</span></span>  
  
- <span data-ttu-id="a5812-184">Conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="a5812-184">Boxing.</span></span>  
  
- <span data-ttu-id="a5812-185">Acceso a una matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="a5812-185">Multidimensional array access.</span></span>  
  
- <span data-ttu-id="a5812-186">Llamadas a métodos mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="a5812-186">Method calls through reflection.</span></span>  
  
- <span data-ttu-id="a5812-187"><xref:System.Threading.Monitor.Enter%2A> o <xref:System.IO.FileStream.Lock%2A>.</span><span class="sxs-lookup"><span data-stu-id="a5812-187"><xref:System.Threading.Monitor.Enter%2A> or <xref:System.IO.FileStream.Lock%2A>.</span></span>  
  
- <span data-ttu-id="a5812-188">Comprobaciones de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a5812-188">Security checks.</span></span> <span data-ttu-id="a5812-189">No se realizan peticiones, solo peticiones de vínculos.</span><span class="sxs-lookup"><span data-stu-id="a5812-189">Do not perform demands, only link demands.</span></span>  
  
- <span data-ttu-id="a5812-190"><xref:System.Reflection.Emit.OpCodes.Isinst> y <xref:System.Reflection.Emit.OpCodes.Castclass> para objetos COM y servidores proxy</span><span class="sxs-lookup"><span data-stu-id="a5812-190"><xref:System.Reflection.Emit.OpCodes.Isinst> and <xref:System.Reflection.Emit.OpCodes.Castclass> for COM objects and proxies</span></span>  
  
- <span data-ttu-id="a5812-191">Obtención o establecimiento de campos en un servidor proxy transparente.</span><span class="sxs-lookup"><span data-stu-id="a5812-191">Getting or setting fields on a transparent proxy.</span></span>  
  
- <span data-ttu-id="a5812-192">Serialización.</span><span class="sxs-lookup"><span data-stu-id="a5812-192">Serialization.</span></span>  
  
- <span data-ttu-id="a5812-193">Punteros de función y delegados.</span><span class="sxs-lookup"><span data-stu-id="a5812-193">Function pointers and delegates.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a5812-194">Vea también</span><span class="sxs-lookup"><span data-stu-id="a5812-194">See also</span></span>

- [<span data-ttu-id="a5812-195">Procedimientos recomendados para la confiabilidad</span><span class="sxs-lookup"><span data-stu-id="a5812-195">Reliability Best Practices</span></span>](reliability-best-practices.md)
