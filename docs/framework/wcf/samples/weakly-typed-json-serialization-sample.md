---
title: Ejemplo de serialización JSON débilmente tipada
ms.date: 03/30/2017
ms.assetid: 0b30e501-4ef5-474d-9fad-a9d559cf9c52
ms.openlocfilehash: 65330e77622920f02b12bd69348aa635529e030e
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96244436"
---
# <a name="weakly-typed-json-serialization-sample"></a><span data-ttu-id="e5122-102">Ejemplo de serialización JSON débilmente tipada</span><span class="sxs-lookup"><span data-stu-id="e5122-102">Weakly-typed JSON Serialization Sample</span></span>

<span data-ttu-id="e5122-103">Al serializar un tipo definido por el usuario en un formato de conexión determinado o deserializar un formato de conexión en un tipo definido por el usuario, el tipo definido por el usuario determinado debe estar disponible en el servicio y en el cliente.</span><span class="sxs-lookup"><span data-stu-id="e5122-103">When serializing a user-defined type to a given wire format, or deserializing a wire format back into a user-defined type, the given user-defined type must be available on both the service and the client.</span></span> <span data-ttu-id="e5122-104">Normalmente, para lograr esto, se aplica el atributo <xref:System.Runtime.Serialization.DataContractAttribute> a estos tipos definidos por el usuario y el atributo <xref:System.Runtime.Serialization.DataMemberAttribute> se aplica a sus miembros.</span><span class="sxs-lookup"><span data-stu-id="e5122-104">Usually to accomplish this, the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to these user-defined types and the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute is applied to their members.</span></span> <span data-ttu-id="e5122-105">Este mecanismo también se aplica al trabajar con los objetos JSON (JavaScript Object Notation), tal y como se describe en el tema [How to: Serialize and Deserialize JSON Data](../feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="e5122-105">This mechanism also applies when working with JavaScript Object Notation (JSON) objects, as described in the topic [How to: Serialize and Deserialize JSON Data](../feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="e5122-106">En algunos escenarios, un servicio o cliente Windows Communication Foundation (WCF) debe tener acceso a los objetos JSON generados por un servicio o cliente que está fuera del control del desarrollador.</span><span class="sxs-lookup"><span data-stu-id="e5122-106">In some scenarios, a Windows Communication Foundation (WCF) service or client must access JSON objects generated by a service or client that is outside of the control of the developer.</span></span> <span data-ttu-id="e5122-107">A medida que más servicios web exponen públicamente las API JSON, puede resultar poco práctico para que el desarrollador de WCF construya tipos locales definidos por el usuario en los que deserializar objetos JSON arbitrarios.</span><span class="sxs-lookup"><span data-stu-id="e5122-107">As more Web services publicly expose JSON APIs, it can become impractical for the WCF developer to construct local user-defined types into which to deserialize arbitrary JSON objects.</span></span> <span data-ttu-id="e5122-108">Este ejemplo proporciona un mecanismo que permite a los desarrolladores de WCF trabajar con objetos JSON deserializados e arbitrarios sin crear tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="e5122-108">This sample provides a mechanism that enables WCF developers to work with deserialized, arbitrary JSON objects, without creating user-defined types.</span></span> <span data-ttu-id="e5122-109">Esto se conoce como *serialización débilmente tipada* de objetos JSON, porque no se conoce el tipo en el que un objeto JSON se deserializa en el momento de la compilación.</span><span class="sxs-lookup"><span data-stu-id="e5122-109">This is known as *weakly-typed serialization* of JSON objects, because the type into which a JSON object deserializes is not known at compile time.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e5122-110">El procedimiento de instalación y las instrucciones de compilación de este ejemplo se encuentran al final de este tema.</span><span class="sxs-lookup"><span data-stu-id="e5122-110">The setup procedure and build instructions for this sample are located at the end of this topic.</span></span>  
  
 <span data-ttu-id="e5122-111">Por ejemplo, una API pública de servicio Web devuelve el siguiente objeto JSON, que describe información sobre un usuario del servicio.</span><span class="sxs-lookup"><span data-stu-id="e5122-111">For example, a public Web service API returns the following JSON object, which describes some information about a user of the service.</span></span>  
  
```json  
{"personal": {"name": "Paul", "age": 23, "height": 1.7, "isSingle": true, "luckyNumbers": [5,17,21]}, "favoriteBands": ["Band ABC", "Band XYZ"]}  
```  
  
 <span data-ttu-id="e5122-112">Para deserializar este objeto, un cliente de WCF debe implementar los siguientes tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="e5122-112">To deserialize this object, a WCF client must implement the following user-defined types.</span></span>  
  
```csharp  
[DataContract]  
 public class MemberProfile  
 {  
     [DataMember]  
     public PersonalInfo personal;  
  
     [DataMember]  
     public string[] favoriteBands;  
 }  
  
 [DataContract]  
 public class PersonalInfo  
 {  
     [DataMember]  
     public string name;  
  
     [DataMember]  
     public int age;  
  
     [DataMember]  
     public double height;  
  
     [DataMember]  
     public bool isSingle;  
  
     [DataMember]  
     public int[] luckyNumbers;  
 }  
```  
  
 <span data-ttu-id="e5122-113">Esto puede ser embarazoso, sobre todo si el cliente tiene que administrar más de un tipo de objeto JSON.</span><span class="sxs-lookup"><span data-stu-id="e5122-113">This can be cumbersome, especially if the client has to handle more than one type of JSON object.</span></span>  
  
 <span data-ttu-id="e5122-114">El tipo `JsonObject` proporcionado por este ejemplo presenta una representación débilmente tipada del objeto JSON deserializado.</span><span class="sxs-lookup"><span data-stu-id="e5122-114">The `JsonObject` type provided by this sample introduces a weakly-typed representation of the deserialized JSON object.</span></span> <span data-ttu-id="e5122-115">`JsonObject` se basa en la asignación natural entre los objetos JSON y .NET Framework diccionarios, y la asignación entre las matrices JSON y .NET Framework matrices.</span><span class="sxs-lookup"><span data-stu-id="e5122-115">`JsonObject` relies on the natural mapping between JSON objects and .NET Framework dictionaries, and the mapping between JSON arrays and .NET Framework arrays.</span></span> <span data-ttu-id="e5122-116">En el código siguiente se muestra el tipo `JsonObject` :</span><span class="sxs-lookup"><span data-stu-id="e5122-116">The following code shows the `JsonObject` type.</span></span>  
  
```csharp  
// Instantiation of JsonObject json omitted  
  
string name = json["root"]["personal"]["name"];  
int age = json["root"]["personal"]["age"];  
double height = json["root"]["personal"]["height"];  
bool isSingle = json["root"]["personal"]["isSingle"];  
int[] luckyNumbers = {  
                                     json["root"]["personal"]["luckyNumbers"][0],  
                                     json["root"]["personal"]["luckyNumbers"][1],  
                                     json["root"]["personal"]["luckyNumbers"][2]
                                 };  
string[] favoriteBands = {  
                                        json["root"]["favoriteBands"][0],  
                                        json["root"]["favoriteBands"][1]  
                                    };  
```  
  
 <span data-ttu-id="e5122-117">Observe que puede examinar los objetos y matrices JSON sin necesidad de declarar el tipo en el momento de la compilación.</span><span class="sxs-lookup"><span data-stu-id="e5122-117">Note that you can "browse" JSON objects and arrays without the need to declare their type at compile time.</span></span> <span data-ttu-id="e5122-118">Para acceder a una explicación del requisito del objeto `["root"]` de nivel superior, consulte el tema [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="e5122-118">For an explanation of the requirement for the top-level `["root"]` object, see the topic [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e5122-119">La clase `JsonObject` solo se proporciona como un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e5122-119">The `JsonObject` class is provided as an example only.</span></span> <span data-ttu-id="e5122-120">No se ha probado en profundidad y no debería usarse en entornos de producción.</span><span class="sxs-lookup"><span data-stu-id="e5122-120">It has not been thoroughly tested, and should not be used in production environments.</span></span> <span data-ttu-id="e5122-121">Una implicación obvia de serialización de JSON débilmente tipada es la falta de seguridad de tipos al trabajar con `JsonObject`.</span><span class="sxs-lookup"><span data-stu-id="e5122-121">An obvious implication of weakly-typed JSON serialization is the lack of type-safety when working with `JsonObject`.</span></span>  
  
 <span data-ttu-id="e5122-122">Para utilizar el tipo `JsonObject` , el contrato de operación del cliente debe utilizar <xref:System.ServiceModel.Channels.Message> como su tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="e5122-122">To use the `JsonObject` type, the client operation contract must use <xref:System.ServiceModel.Channels.Message> as its return type.</span></span>  
  
```csharp  
[ServiceContract]  
    interface IClientSideProfileService  
    {  
        // There is no need to write a DataContract for the complex type returned by the service.  
        // The client will use a JsonObject to browse the JSON in the received message.  
  
        [OperationContract]  
        [WebGet(ResponseFormat = WebMessageFormat.Json)]  
        Message GetMemberProfile();  
    }  
```  
  
 <span data-ttu-id="e5122-123">Se crean instancias de `JsonObject` a continuación tal y como se muestran en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="e5122-123">The `JsonObject` is then instantiated as shown in the following code.</span></span>  
  
```csharp  
// Code to instantiate IClientSideProfileService channel omitted…  
  
// Make a request to the service and obtain the Json response  
XmlDictionaryReader reader = channel.GetMemberProfile().GetReaderAtBodyContents();  
  
// Go through the Json as though it is a dictionary. There is no need to map it to a .NET CLR type.  
JsonObject json = new JsonObject(reader);  
```  
  
 <span data-ttu-id="e5122-124">El constructor `JsonObject` toma un <xref:System.Xml.XmlDictionaryReader>, que se obtiene a través del método <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="e5122-124">The `JsonObject` constructor takes a <xref:System.Xml.XmlDictionaryReader>, which is obtained through the <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> method.</span></span> <span data-ttu-id="e5122-125">El lector contiene una representación XML del mensaje de JSON recibida por el cliente.</span><span class="sxs-lookup"><span data-stu-id="e5122-125">The reader contains an XML representation of the JSON message received by the client.</span></span> <span data-ttu-id="e5122-126">Para obtener más información, vea el tema sobre la [asignación entre JSON y XML](../feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="e5122-126">For more information, see the topic [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md).</span></span>  
  
 <span data-ttu-id="e5122-127">El programa produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="e5122-127">The program produces the following output:</span></span>  
  
```console  
Service listening at http://localhost:8000/.  
To view the JSON output from the sample, navigate to http://localhost:8000/GetMemberProfile  
This is Paul's page. I am 23 years old and I am 1.7 meters tall.  
I am single.  
My lucky numbers are 5, 17, and 21.  
My favorite bands are Band ABC and Band XYZ.  
```  
  
### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="e5122-128">Configurar, compilar y ejecutar el ejemplo</span><span class="sxs-lookup"><span data-stu-id="e5122-128">To set up, build, and run the sample</span></span>  
  
1. <span data-ttu-id="e5122-129">Asegúrese de que ha realizado el [procedimiento de instalación única para los ejemplos de Windows Communication Foundation](one-time-setup-procedure-for-the-wcf-samples.md).</span><span class="sxs-lookup"><span data-stu-id="e5122-129">Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](one-time-setup-procedure-for-the-wcf-samples.md).</span></span>  
  
2. <span data-ttu-id="e5122-130">Compile la solución WeaklyTypedJson.sln tal y como se describe en [Building the Windows Communication Foundation Samples](building-the-samples.md).</span><span class="sxs-lookup"><span data-stu-id="e5122-130">Build the solution WeaklyTypedJson.sln as described in [Building the Windows Communication Foundation Samples](building-the-samples.md).</span></span>  
  
3. <span data-ttu-id="e5122-131">Ejecute la solución.</span><span class="sxs-lookup"><span data-stu-id="e5122-131">Run the solution.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="e5122-132">Puede que los ejemplos ya estén instalados en su equipo.</span><span class="sxs-lookup"><span data-stu-id="e5122-132">The samples may already be installed on your machine.</span></span> <span data-ttu-id="e5122-133">Compruebe el siguiente directorio (predeterminado) antes de continuar.</span><span class="sxs-lookup"><span data-stu-id="e5122-133">Check for the following (default) directory before continuing.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples`  
>
> <span data-ttu-id="e5122-134">Si este directorio no existe, vaya a [ejemplos de Windows Communication Foundation (WCF) y Windows Workflow Foundation (WF) para .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=21459) para descargar todos los Windows Communication Foundation (WCF) y [!INCLUDE[wf1](../../../../includes/wf1-md.md)] ejemplos.</span><span class="sxs-lookup"><span data-stu-id="e5122-134">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=21459) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="e5122-135">Este ejemplo se encuentra en el siguiente directorio.</span><span class="sxs-lookup"><span data-stu-id="e5122-135">This sample is located in the following directory.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples\WCF\Scenario\Ajax\WeaklyTypedJson`  
