---
title: Datos de gran tamaño y secuencias
description: Obtenga información sobre las consideraciones para la comunicación basada en XML de WCF, codificadores y datos de streaming, incluida la transferencia de datos binarios.
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 09e020801486c09c027883fca3d67a6c2e2fe8d7
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "96234705"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="9a5ce-103">Datos de gran tamaño y secuencias</span><span class="sxs-lookup"><span data-stu-id="9a5ce-103">Large Data and Streaming</span></span>

<span data-ttu-id="9a5ce-104">Windows Communication Foundation (WCF) es una infraestructura de comunicaciones basada en XML.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-104">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="9a5ce-105">Dado que los datos XML se codifican normalmente en el formato de texto estándar definido en la [especificación de xml 1,0](https://www.w3.org/TR/REC-xml/), los desarrolladores y arquitectos de sistemas conectados suelen preocuparse por la superficie de conexión (o el tamaño) de los mensajes enviados a través de la red, y la codificación basada en texto de XML plantea desafíos especiales para la transferencia eficaz de datos binarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-105">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="9a5ce-106">Consideraciones básicas</span><span class="sxs-lookup"><span data-stu-id="9a5ce-106">Basic Considerations</span></span>  

 <span data-ttu-id="9a5ce-107">Para proporcionar información general acerca de la siguiente información para WCF, en esta sección se destacan algunos aspectos generales y consideraciones sobre las codificaciones, los datos binarios y la transmisión por secuencias que generalmente se aplican a las infraestructuras de sistemas conectados.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-107">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="9a5ce-108">Codificar datos: Texto y Binario</span><span class="sxs-lookup"><span data-stu-id="9a5ce-108">Encoding Data: Text vs. Binary</span></span>  

 <span data-ttu-id="9a5ce-109">Entre las preocupaciones que suelen expresar los programadores se incluyen la percepción de que XML supone un exceso de trabajo significativo en comparación con los formatos binarios debido a la naturaleza repetitiva de las etiquetas de inicio y de cierre, que la codificación de los valores numéricos es significativamente más larga porque se expresan en valores de texto y que esos datos binarios no se pueden expresar eficazmente porque deben codificarse de forma especial para incrustarse en un formato de texto.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-109">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="9a5ce-110">Aunque muchos de estos aspectos y otros similares son válidos, la diferencia real entre los mensajes codificados en texto XML en un entorno de servicios Web XML y los mensajes con codificación binaria en un entorno de llamada a procedimiento remoto (RPC) heredado es, a menudo, mucho menos significativa que la consideración inicial podría sugerir.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-110">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="9a5ce-111">Mientras que los mensajes codificados en texto XML son transparentes y legibles, en comparación, los mensajes binarios son, a menudo, bastante oscuros y difíciles de descifrar sin herramientas.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-111">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="9a5ce-112">Esta diferencia de legibilidad hace que nos olvidemos de que los mensajes binarios, a menudo, también llevan metadatos insertados en la carga útil, lo cual agrega sobrecarga, como ocurre con los mensajes de texto XML.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-112">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="9a5ce-113">Esto es específicamente verdadero para los formatos binarios que pretenden proporcionar correspondencia imprecisa y funciones de invocación dinámicas.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-113">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="9a5ce-114">Sin embargo, normalmente los formatos binarios llevan esta información descriptiva de los metadatos en un "encabezado", que también declara el diseño de datos para los registros de datos siguientes.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-114">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="9a5ce-115">A continuación, la carga útil sigue esta declaración de bloque de metadatos comunes con sobrecarga mínima.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-115">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="9a5ce-116">En cambio, XML incluye cada elemento de datos en un elemento o atributo para que los metadatos envolventes estén incluidos repetidamente en cada objeto de carga útil serializado.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-116">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="9a5ce-117">Como resultado, el tamaño de un objeto de carga útil serializado único es similar si se comparan las representaciones binaria y de texto cuando es necesario expresar metadatos descriptivos para ambos. Sin embargo, el formato binario se beneficia de la descripción de metadatos compartida con cada objeto de carga útil adicional que se transfiere, ya que la sobrecarga total es más baja.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-117">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="9a5ce-118">No obstante, para ciertos tipos de datos, como números, podría haber un inconveniente al utilizar representaciones numéricas binarias de tamaño fijo, como un tipo decimal de 128 bits en lugar de texto sin formato, ya que la representación de texto sin formato podría ser varios bytes menor.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-118">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="9a5ce-119">Los datos de texto también podrían tener ventajas de tamaño por las opciones de codificación de texto XML normalmente más flexibles, mientras que algunos formatos binarios podrían establecerse como valor predeterminado a 16 bits o incluso Unicode de 32 bits, lo cual no se aplica a Binario .NET y Formato XML.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-119">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="9a5ce-120">Por lo tanto, la decisión entre el formato de texto y el binario no consiste solamente en suponer que los mensajes binarios son siempre más pequeños que los mensajes de texto XML.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-120">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="9a5ce-121">Una ventaja clara de los mensajes de texto XML es que están basados en estándares y proporcionan la opción más completa en cuanto a interoperabilidad y compatibilidad de plataforma.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-121">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="9a5ce-122">Para obtener más información, vea la sección "codificaciones" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-122">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="9a5ce-123">Contenido binario</span><span class="sxs-lookup"><span data-stu-id="9a5ce-123">Binary Content</span></span>  

 <span data-ttu-id="9a5ce-124">Un área en la cual las codificaciones binarias son superiores a las codificaciones basadas en texto con respecto al tamaño del mensaje resultante es elementos de datos binarios de gran tamaño como imágenes, vídeos, secuencias de sonido o cualquier otra forma de datos opacos y binarios que se deben intercambiar entre los servicios y sus consumidores.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-124">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="9a5ce-125">Para ajustar estos tipos de datos en el texto XML, el enfoque común es codificarlos utilizando la codificación de Base64.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-125">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="9a5ce-126">En una cadena codificada con Base64, cada carácter representa 6 bits de los datos originales de 8 bits, que producen una proporción de sobrecarga de codificación de 4:3 para Base64, sin contar caracteres de formato adicionales (retorno de carro/salto de línea) que se agregan normalmente por convención.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-126">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="9a5ce-127">Aunque la trascendencia de las diferencias entre la codificación XML y binaria depende normalmente del escenario, un aumento de tamaño superior al 33% cuando se transmite una carga útil de 500 MB no suele ser aceptable.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-127">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="9a5ce-128">Para evitar esta sobrecarga de codificación, la norma del Mecanismo de optimización de transmisión del mensaje (MTOM) permite exteriorizar elementos de datos de gran tamaño contenidos en un mensaje y llevarlos con el mensaje como datos binarios sin ninguna codificación especial.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-128">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="9a5ce-129">Con MTOM, los mensajes se intercambian de manera similar a los mensajes de correo electrónico de Protocolo simple de transferencia de correo (SMTP) con datos adjuntos o contenido incrustado (imágenes y otro contenido incrustado). Los mensajes MTOM se empaquetan como secuencias MIME de varias partes o relacionadas con la parte raíz que es el mensaje SOAP real.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-129">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="9a5ce-130">Un mensaje SOAP de MTOM se modifica a partir de su versión descodificada para que las etiquetas de elementos especiales que hacen referencia a las correspondientes partes MIME sustituyan a los elementos originales que contenían datos binarios en el mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-130">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="9a5ce-131">Como resultado, el mensaje SOAP hace referencia al contenido binario señalando las partes MIME enviadas con él, pero, de lo contrario, solo lleva datos de texto XML.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-131">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="9a5ce-132">Dado que este modelo está alineado estrechamente con el modelo de SMTP bien establecido, hay una gran compatibilidad con las herramientas para codificar y descodificar los mensajes MTOM en muchas plataformas, lo cual lo convierte en una opción sumamente interoperable.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-132">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="9a5ce-133">No obstante, como con Base64, MTOM viene también con alguna sobrecarga necesaria para el formato MIME, para que solamente se vean las ventajas de utilizar MTOM cuando el tamaño de un elemento de datos binarios supera aproximadamente 1 KB.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-133">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="9a5ce-134">Debido a la sobrecarga, los mensajes codificados por MTOM podrían ser mayores que los mensajes que usan la codificación Base64 para datos binarios, si la carga binaria permanece bajo ese umbral.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-134">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="9a5ce-135">Para obtener más información, vea la sección "codificaciones" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-135">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="9a5ce-136">Contenido de datos de gran tamaño</span><span class="sxs-lookup"><span data-stu-id="9a5ce-136">Large Data Content</span></span>  

 <span data-ttu-id="9a5ce-137">Superficie de la conexión a parte, la carga útil de 500 MB previamente mencionada también supone un gran desafío local para el servicio y para el cliente.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-137">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="9a5ce-138">De forma predeterminada, WCF procesa los mensajes en *modo almacenado en búfer*.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-138">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="9a5ce-139">Esto significa que todo el contenido de un mensaje está presente en la memoria antes de enviarse o una vez recibido.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-139">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="9a5ce-140">Aunque es una estrategia acertada para la mayoría de los escenarios y necesaria para el uso de características de mensajería tales como las firmas digitales y la entrega confiable, los mensajes grandes podrían agotar los recursos del sistema.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-140">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="9a5ce-141">La estrategia para tratar con cargas útiles de gran tamaño es usar secuencias.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-141">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="9a5ce-142">Aunque se suele considerar que los mensajes, en especial aquellos que se expresan en XML, son paquetes de datos relativamente compactos, un mensaje podría tener un tamaño de varios gigabytes y parecerse más a un flujo de datos continuo que a un paquete de datos.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-142">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="9a5ce-143">Cuando los datos se transfieren en modo de transmisión por secuencias en lugar de en modo de almacenamiento en búfer, el remitente hace que el contenido del cuerpo del mensaje esté disponible para el destinatario en forma de secuencia y la infraestructura del mensaje reenvía continuamente los datos del remitente al receptor a medida que están disponibles.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-143">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="9a5ce-144">El escenario más común en el que se producen estas transferencias de contenido de datos de gran tamaño son transferencias de objetos de datos binarios que:</span><span class="sxs-lookup"><span data-stu-id="9a5ce-144">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="9a5ce-145">No se pueden dividir con facilidad en una secuencia del mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-145">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="9a5ce-146">Se deben entregar de forma puntual.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-146">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="9a5ce-147">No están disponibles en su totalidad cuando se inicia la transferencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-147">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="9a5ce-148">Para los datos que no tienen estas restricciones, normalmente es mejor enviar secuencias de mensajes dentro del ámbito de una sesión que un mensaje de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-148">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="9a5ce-149">Para obtener más información, vea la sección "datos de streaming" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-149">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="9a5ce-150">Cuando envíe grandes cantidades de datos, tendrá que establecer la `maxAllowedContentLength` configuración de IIS (para obtener más información, consulte Configuración de los [límites de solicitudes de IIS](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) y la `maxReceivedMessageSize` configuración de enlace (por ejemplo, [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) o <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> ).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-150">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="9a5ce-151">La `maxAllowedContentLength` propiedad tiene como valor predeterminado 28,6 MB y el `maxReceivedMessageSize` valor predeterminado de la propiedad es 64 KB.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-151">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="9a5ce-152">Codificaciones</span><span class="sxs-lookup"><span data-stu-id="9a5ce-152">Encodings</span></span>  

 <span data-ttu-id="9a5ce-153">Una *codificación* define un conjunto de reglas sobre cómo presentar los mensajes en la conexión.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-153">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="9a5ce-154">Un *codificador* implementa este tipo de codificación y es responsable, en el lado del remitente, de convertir una en memoria en <xref:System.ServiceModel.Channels.Message> una secuencia de bytes o en un búfer de bytes que se puede enviar a través de la red.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-154">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="9a5ce-155">En el lado del receptor, el codificador convierte una secuencia de bytes en un mensaje en memoria.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-155">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="9a5ce-156">WCF incluye tres codificadores y permite escribir y conectar sus propios codificadores, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-156">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="9a5ce-157">Cada uno de los enlaces estándar incluyen un codificador preconfigurado, por medio del cual los enlaces con el prefijo Net\* utilizan el codificador binario (incluyendo la clase <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>) mientras que <xref:System.ServiceModel.BasicHttpBinding> y las clases <xref:System.ServiceModel.WSHttpBinding> utilizan de forma predeterminada el codificador del mensaje de texto (por medio de la clase <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-157">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="9a5ce-158">Elemento de enlace del codificador.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-158">Encoder binding element</span></span>|<span data-ttu-id="9a5ce-159">Descripción</span><span class="sxs-lookup"><span data-stu-id="9a5ce-159">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="9a5ce-160">El codificador del mensaje de texto es el codificador predeterminado para todos los enlaces basados en HTTP y la opción adecuada para todos los enlaces personalizados donde la interoperabilidad es la preocupación superior.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-160">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="9a5ce-161">Este codificador lee y escribe los mensajes de texto SOAP 1.1/SOAP 1.2 estándar sin control especial para los datos binarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-161">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="9a5ce-162">Si la <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> propiedad de un mensaje se establece en <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> , el contenedor de envoltura SOAP se omite de la salida y solo se serializa el contenido del cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-162">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="9a5ce-163">El codificador del mensaje MTOM es un codificador de texto que implementa el control especial para los datos binarios y no se utiliza de forma predeterminada en ninguno de los enlaces estándar porque es estrictamente una utilidad de optimización caso por caso.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-163">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="9a5ce-164">Si el mensaje contiene datos binarios que superan un umbral donde la codificación MTOM produce una ventaja, los datos se exteriorizan en una parte MIME que sigue a la envoltura del mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-164">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="9a5ce-165">Vea "Habilitar MTOM" más adelante en esta sección.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-165">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="9a5ce-166">El codificador de mensajes binarios es el codificador predeterminado para los enlaces net \* y la opción adecuada siempre que ambas partes de la comunicación se basan en WCF.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-166">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="9a5ce-167">El codificador del mensaje binario utiliza el Formato XML Binario .NET, una representación binaria específica de Microsoft para conjuntos de información XML (Infosets) que generalmente produce una superficie menor que la representación equivalente XML 1.0 y codifica los datos binarios como una secuencia de bytes.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-167">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="9a5ce-168">La codificación de mensajes de texto es normalmente la mejor opción para cualquier ruta de comunicación que requiere interoperabilidad, mientras que la codificación de mensajes binaria es la mejor opción para cualquier otra ruta de comunicación.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-168">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="9a5ce-169">La codificación de mensajes binarios produce normalmente tamaños de mensaje menores comparados con el texto para un mensaje único e, incluso, tamaños de mensaje progresivamente menores durante la duración de una sesión de comunicación.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-169">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="9a5ce-170">A diferencia de la codificación de texto, la codificación binaria no tiene que utilizar control especial para los datos binarios, como cuando se utiliza Base64, pero representa los bytes como bytes.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-170">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="9a5ce-171">Si su solución no requiere interoperabilidad, pero todavía quiere utilizar el transporte HTTP, puede crear <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> en un enlace personalizado que utiliza la clase <xref:System.ServiceModel.Channels.HttpTransportBindingElement> para el transporte.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-171">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="9a5ce-172">Si varios clientes en su servicio requieren interoperabilidad, se recomienda que exponga puntos de conexión paralelos que tengan el transporte adecuado y las opciones de codificación para los respectivos clientes habilitadas.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-172">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="9a5ce-173">Habilitar MTOM</span><span class="sxs-lookup"><span data-stu-id="9a5ce-173">Enabling MTOM</span></span>  

 <span data-ttu-id="9a5ce-174">Cuando la interoperabilidad es un requisito y se deben enviar datos binarios de gran tamaño, a continuación, la codificación de mensajes MTOM es la estrategia alternativa de codificación que puede habilitar en los <xref:System.ServiceModel.BasicHttpBinding> estándar o enlaces <xref:System.ServiceModel.WSHttpBinding> estableciendo la propiedad `MessageEncoding` respectiva a <xref:System.ServiceModel.WSMessageEncoding.Mtom> o creando <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> en <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-174">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="9a5ce-175">En el ejemplo de código siguiente, extraído del ejemplo de [codificación MTOM](../samples/mtom-encoding.md) , se muestra cómo habilitar MTOM en la configuración.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-175">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="9a5ce-176">Tal y como se ha mencionado anteriormente, la decisión de utilizar la codificación MTOM depende del volumen de datos que está enviando.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-176">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="9a5ce-177">Además, como MTOM está habilitado en el nivel de enlace, habilitar MTOM afecta a todas las operaciones en un punto de conexión determinado.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-177">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="9a5ce-178">Dado que el codificador MTOM siempre emite un mensaje MIME/de varias partes codificado con MTOM sin tener en cuenta si los datos binarios acaban exteriorizándose, generalmente se debería habilitar MTOM solo para los puntos de conexión que intercambian los mensajes con más de 1 KB de datos binarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-178">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="9a5ce-179">Asimismo, los contratos de servicios diseñados para el uso con puntos de conexión habilitados por MTOM deben, cuando sea posible, ser restringidos a especificar tales operaciones de transferencia de datos.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-179">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="9a5ce-180">La funcionalidad de control relacionada debería residir en un contrato independiente.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-180">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="9a5ce-181">Esta norma "solo MTOM" se aplica solamente a los mensajes enviados a través de un punto de conexión habilitado por MTOM; el codificador MTOM puede descodificar y analizar también los mensajes de entrada no MTOM.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-181">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="9a5ce-182">El codificador MTOM se ajusta a todas las demás características de WCF.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-182">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="9a5ce-183">Tenga en cuenta que tal vez no sea posible respetar esta regla en todos los casos, por ejemplo, cuando se requiere la compatibilidad de la sesión.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-183">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="9a5ce-184">Modelo de programación</span><span class="sxs-lookup"><span data-stu-id="9a5ce-184">Programming Model</span></span>  

 <span data-ttu-id="9a5ce-185">Independientemente de cuál de los tres codificadores integrados utiliza en su aplicación, la experiencia de programación es idéntica con respecto a la transferencia de datos binarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-185">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="9a5ce-186">La diferencia radica en cómo WCF controla los datos en función de sus tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-186">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="9a5ce-187">Al utilizar MTOM, el contrato de datos anterior se serializa según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="9a5ce-187">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="9a5ce-188">Si `binaryBuffer` no es `null` y contiene individualmente bastantes datos para justificar la sobrecarga de externalización de MTOM (encabezados MIME, etc.) cuando se compara con codificación Base64, los datos se exteriorizan y se llevan con el mensaje como una parte binaria de MIME.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-188">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="9a5ce-189">Si no se supera el umbral, se codifican los datos como Base64.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-189">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="9a5ce-190">La cadena (y todos los otros tipos no binarios) se representa siempre como una cadena dentro del cuerpo del mensaje, sin tener en cuenta el tamaño.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-190">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="9a5ce-191">El efecto en la codificación MTOM es el mismo con independencia de si se usa un contrato de datos explícito, como se muestra en el ejemplo anterior, si se usa una lista de parámetros en una operación, si se tienen contratos de datos anidados o si se transfiere un objeto de contrato de datos dentro de una colección.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-191">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="9a5ce-192">Las matrices de bytes son siempre candidatas para la optimización y se optimizan si se cumplen los umbrales de optimización.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-192">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a5ce-193">No debería estar utilizando tipos derivados <xref:System.IO.Stream?displayProperty=nameWithType> dentro de los contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-193">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="9a5ce-194">Los datos de la secuencia se deberían comunicar utilizando el modelo de secuencias, explicado en la sección "Transmisión por secuencias de datos".</span><span class="sxs-lookup"><span data-stu-id="9a5ce-194">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="9a5ce-195">Transmisión por secuencias de datos</span><span class="sxs-lookup"><span data-stu-id="9a5ce-195">Streaming Data</span></span>  

 <span data-ttu-id="9a5ce-196">Si tiene una gran cantidad de datos para transferir, el modo de transferencia de streaming en WCF es una alternativa factible al comportamiento predeterminado de almacenar en búfer y procesar los mensajes en memoria en su totalidad.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-196">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="9a5ce-197">Como se ha mencionado anteriormente, habilite la transmisión por secuencias solo para los mensajes de gran tamaño (con contenido de texto o binario) si no se pueden segmentar los datos, si el mensaje debe entregarse puntualmente o si los datos no están todavía totalmente disponibles cuando se inicia la transferencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-197">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="9a5ce-198">Restricciones</span><span class="sxs-lookup"><span data-stu-id="9a5ce-198">Restrictions</span></span>  

 <span data-ttu-id="9a5ce-199">No se puede usar un número significativo de características de WCF cuando está habilitada la transmisión por secuencias:</span><span class="sxs-lookup"><span data-stu-id="9a5ce-199">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="9a5ce-200">No se pueden utilizar firmas digitales para el cuerpo del mensaje porque requieren calcular un hash sobre el contenido completo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-200">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="9a5ce-201">Con transmisión por secuencias, el contenido no está totalmente disponible cuando los encabezados del mensaje se construyen y envían y, por consiguiente, no se puede calcular una firma digital.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-201">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="9a5ce-202">El cifrado depende de firmas digitales para comprobar que se han reconstruido los datos correctamente.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-202">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="9a5ce-203">Las sesiones de confianza deben almacenar en búfer los mensajes enviados al cliente para entregarlos más tarde si se pierde un mensaje durante la transferencia y deben contener los mensajes en el servicio antes de entregarlos a la implementación del servicio para conservar el orden del mensaje en caso de que los mensajes se reciban fuera de secuencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-203">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="9a5ce-204">Debido a estas restricciones funcionales, puede utilizar solo las opciones de seguridad de nivel de transporte para la transmisión por secuencias y no puede activar las sesiones de confianza.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-204">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="9a5ce-205">La transmisión por secuencias solo está disponible con los siguientes enlaces definidos por el sistema:</span><span class="sxs-lookup"><span data-stu-id="9a5ce-205">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="9a5ce-206">Dado que los transportes subyacentes de <xref:System.ServiceModel.NetTcpBinding> y <xref:System.ServiceModel.NetNamedPipeBinding> tienen una compatibilidad inherente con sesiones según la conexión y permiten una entrega confiable, a diferencia de HTTP, en la práctica estas restricciones afectan mínimamente a estos dos enlaces.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-206">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="9a5ce-207">La transmisión por secciones no está disponible con el transporte de Message Queuing Server (MSMQ) y, por lo tanto, no se puede utilizar con <xref:System.ServiceModel.NetMsmqBinding> o la clase <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-207">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="9a5ce-208">El transporte de Message Queuing solo admite las transferencias de datos almacenadas en búfer con un tamaño de mensaje restringido, mientras que el resto de transportes no tienen ningún límite del tamaño de mensaje práctico para la inmensa mayoría de escenarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-208">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="9a5ce-209">La transmisión por secuencias no está tampoco disponible al utilizar el transporte del canal del mismo nivel, por lo que no está disponible con <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-209">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="9a5ce-210">Transmisión por secuencias y sesiones</span><span class="sxs-lookup"><span data-stu-id="9a5ce-210">Streaming and Sessions</span></span>  

 <span data-ttu-id="9a5ce-211">Puede obtener un comportamiento inesperado al transmitir mediante secuencias las llamadas con un enlace basado en sesión.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="9a5ce-212">Todas las llamadas de transferencias por secuencias se realizan a través de un canal único (el canal del datagrama) que no admite sesiones incluso si el enlace utilizado esté configurado para utilizar sesiones.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="9a5ce-213">Si varios clientes realizan llamadas de transferencia por secuencias al mismo objeto de servicio sobre un enlace basado en sesión y el modo de simultaneidad del objeto de servicio se establece en Single y su modo de contexto de instancia está establecido en PerSession, todas las llamadas deben pasar por el canal de datagramas y solo se procesará una llamada al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-213">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="9a5ce-214">Uno o más clientes pueden agotar el tiempo de espera. Para solucionar este problema, puede establecer el modo de contexto de instancia del objeto de servicio en percall o Concurrency en Multiple.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-214">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a5ce-215">MaxConcurrentSessions no influye en este caso porque solo hay una "sesión" disponible.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-215">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="9a5ce-216">Habilitar la transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="9a5ce-216">Enabling Streaming</span></span>  

 <span data-ttu-id="9a5ce-217">Puede habilitar la transmisión por secuencias de las siguientes maneras:</span><span class="sxs-lookup"><span data-stu-id="9a5ce-217">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="9a5ce-218">Envíe y acepte las solicitudes en modo de transmisión y acepte y devuelva las respuestas en modo almacenado en búfer (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-218">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="9a5ce-219">Envíe y acepte las solicitudes en modo de almacenamiento en búfer y acepte y devuelva las respuestas en modo de transmisión (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-219">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="9a5ce-220">Envíe y reciba solicitudes y respuestas en modo de transmisión en ambas direcciones.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-220">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="9a5ce-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="9a5ce-222">Puede deshabilitar la transmisión por secuencias estableciendo el modo de transferencia en <xref:System.ServiceModel.TransferMode.Buffered>, que es la configuración predeterminada en todos los enlaces.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-222">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="9a5ce-223">El código siguiente muestra cómo establecer el modo de transferencia en la configuración.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-223">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="9a5ce-224">Cuando cree instancias de su enlace en el código, debe establecer la propiedad `TransferMode` respectiva del enlace (o el elemento de enlace del transporte si está creando un enlace personalizado) en uno de los valores previamente mencionados.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-224">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="9a5ce-225">Puede activar transmisiones por secuencias para las solicitudes y respuestas o para ambas direcciones independientemente en cualquier lado de las partes en comunicación sin afectar a la funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-225">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="9a5ce-226">Sin embargo, siempre debería suponer que el tamaño de datos transferido es tan significativo que habilitar la transmisión por secuencias se justifica en ambos puntos de conexión de un enlace de comunicación.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-226">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="9a5ce-227">Para la comunicación multiplataforma donde uno de los puntos de conexión no se implementa con WCF, la capacidad de usar la transmisión por secuencias depende de las capacidades de transmisión por secuencias de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-227">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="9a5ce-228">Otra excepción poco frecuente podría ser un escenario conducido por consumo de memoria donde un cliente o servicio debe minimizar su espacio de trabajo y permitir solo los tamaños de búfer pequeños.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-228">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="9a5ce-229">Habilitar la transmisión de datos asincrónica</span><span class="sxs-lookup"><span data-stu-id="9a5ce-229">Enabling Asynchronous Streaming</span></span>  

 <span data-ttu-id="9a5ce-230">Para habilitar el streaming asincrónico, agregue el comportamiento de punto de conexión <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> al host de servicio y establezca la propiedad <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> en `true`.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-230">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="9a5ce-231">También hemos agregado la capacidad de transmisión de datos asincrónica verdadera en el lado de envío.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-231">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="9a5ce-232">Esto mejora la escalabilidad del servicio en escenarios donde transmite por secuencias mensajes para varios clientes, algunos de los cuales son lentos en la lectura; posiblemente debido a la congestión de red o que no leen en absoluto.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-232">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="9a5ce-233">En estos escenarios ahora no bloqueamos subprocesos individuales en el servicio por cliente.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-233">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="9a5ce-234">Esto garantiza que el servicio pueda procesar muchos más clientes, mejorando así la escalabilidad del servicio.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-234">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="9a5ce-235">Modelo de programación para las transferencias de transmisión</span><span class="sxs-lookup"><span data-stu-id="9a5ce-235">Programming Model for Streamed Transfers</span></span>  

 <span data-ttu-id="9a5ce-236">El modelo de programación para transmisión es sencillo.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-236">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="9a5ce-237">Para recibir los datos transmitidos, especifique un contrato de operación que tiene un parámetro de entrada único de tipo <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-237">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="9a5ce-238">Para devolver los datos transmitidos, devuelva una referencia <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-238">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="9a5ce-239">`Echo` en el ejemplo anterior recibe y devuelve una secuencia y se debería utilizar por consiguiente en un enlace con <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-239">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="9a5ce-240">Para `RequestInfo` de la operación, <xref:System.ServiceModel.TransferMode.StreamedResponse> se adapta mejor, porque solo devuelve <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-240">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="9a5ce-241">La operación unidireccional se adapta mejor para <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-241">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="9a5ce-242">Tenga en cuenta que si se agrega un segundo parámetro a las operaciones `Echo` o `ProvideInfo` siguientes, se hace que el modelo de servicio se revierta a una estrategia con almacenamiento en búfer y se utilice la representación de serialización en tiempo de ejecución de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-242">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="9a5ce-243">Solo las operaciones con un parámetro de flujo de entrada único son compatibles con la transmisión por secuencias de solicitud de principio a fin.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-243">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="9a5ce-244">Esta regla se aplica de igual forma a los contratos de mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-244">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="9a5ce-245">Como se muestra en el contrato de mensaje siguiente, puede tener solo un miembro de un único cuerpo en el contrato del mensaje que sea una secuencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-245">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="9a5ce-246">Si desea comunicar la información adicional con la secuencia, esta información debe estar incluida en los encabezados del mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-246">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="9a5ce-247">El cuerpo del mensaje se reserva exclusivamente para el contenido de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-247">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="9a5ce-248">Las transferencias con secuencias finalizan y el mensaje se cierra cuando la secuencia alcanza el final del archivo (EOF).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-248">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="9a5ce-249">Cuando se envía un mensaje (que devuelve un valor o se invoca una operación), se puede pasar un objeto <xref:System.IO.FileStream> y la infraestructura de WCF extrae posteriormente todos los datos de esa secuencia hasta que la secuencia se ha leído completamente y se ha alcanzado con EOF.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-249">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="9a5ce-250">Para transferir datos transmitidos al origen cuando no existe clase derivada <xref:System.IO.Stream> previamente generada, construya esta clase, superponga la clase sobre su origen de secuencia y utilícelo como el argumento o valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-250">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="9a5ce-251">Al recibir un mensaje, WCF construye una secuencia sobre el contenido del cuerpo del mensaje codificado en base64 (o la parte MIME respectiva si se usa MTOM) y la secuencia llega a EOF cuando se ha leído el contenido.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-251">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="9a5ce-252">La transmisión por secuencias del nivel de transporte también funciona con cualquier otro tipo de contrato de mensaje (listas de parámetros, argumentos de contrato de datos y el contrato del mensaje explícito), pero como la serialización y deserialización de estos mensajes con tipo definido requieren el almacenado en búfer por el serializador, no se recomienda utilizar estas variantes de contrato.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-252">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="9a5ce-253">Consideraciones de seguridad específicas para datos de gran tamaño</span><span class="sxs-lookup"><span data-stu-id="9a5ce-253">Special Security Considerations for Large Data</span></span>  

 <span data-ttu-id="9a5ce-254">Todos los enlaces le permiten restringir el tamaño de los mensajes entrantes para evitar los ataques por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-254">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="9a5ce-255"><xref:System.ServiceModel.BasicHttpBinding>Por ejemplo, expone una propiedad [System. ServiceModel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) que limita el tamaño del mensaje entrante y, por tanto, también limita la cantidad máxima de memoria a la que se tiene acceso al procesar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-255">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="9a5ce-256">Esta unidad se establece en bytes con un valor predeterminado de 65.536 bytes.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-256">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="9a5ce-257">Una amenaza de seguridad específica del escenario de transmisión por flujos de datos grandes provoca una denegación de servicio haciendo que se almacenen en búfer los datos cuando el receptor espera que se transmitan.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-257">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="9a5ce-258">Por ejemplo, WCF siempre almacena en búfer los encabezados SOAP de un mensaje y, de este modo, un atacante puede construir un mensaje malintencionado de gran tamaño que conste exclusivamente de encabezados para forzar el almacenamiento en búfer de los datos.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-258">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="9a5ce-259">Cuando está habilitada la transmisión por secuencias, `MaxReceivedMessageSize` puede estar establecido en un valor sumamente grande, porque el receptor nunca espera que el mensaje completo esté almacenado en búfer en memoria a la vez.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-259">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="9a5ce-260">Si se fuerza a WCF a almacenar en búfer el mensaje, se produce un desbordamiento de memoria.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-260">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="9a5ce-261">Por consiguiente, restringir el tamaño máximo del mensaje entrante no es suficiente en este caso.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-261">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="9a5ce-262">La `MaxBufferSize` propiedad es necesaria para restringir la memoria que los búferes de WCF.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-262">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="9a5ce-263">Es importante establecer esto en un valor seguro (o mantenerlo en el valor predeterminado) en la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-263">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="9a5ce-264">Por ejemplo, suponga que su servicio debe recibir los archivos hasta 4 GB en tamaño y almacenarlos en el disco local.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-264">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="9a5ce-265">Suponga además que su memoria se restringe de tal manera que puede almacenar en búfer solo 64 KB de datos a la vez.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-265">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="9a5ce-266">A continuación, establecería `MaxReceivedMessageSize` en 4 GB y `MaxBufferSize` a 64 KB.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-266">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="9a5ce-267">Asimismo, en su implementación de servicio debe asegurarse de que solo lee de la secuencia entrante en fragmentos de 64 KB y no leer el fragmento siguiente antes de que el anterior se haya escrito en el disco y haya sido descartado de la memoria.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-267">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="9a5ce-268">También es importante entender que esta cuota solo limita el almacenamiento en búfer realizado por WCF y no puede protegerle contra ningún almacenamiento en búfer que haga en su propio servicio o implementación de cliente.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-268">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="9a5ce-269">Para obtener más información sobre las consideraciones de seguridad adicionales, consulte [consideraciones de seguridad para los datos](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="9a5ce-269">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a5ce-270">La decisión de utilizar transferencias almacenadas en búfer o transmitidas es una decisión local del punto de conexión.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-270">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="9a5ce-271">Para los transportes HTTP, el modo de transferencia no se propaga a través de una conexión o a los servidores proxy y otros intermediarios.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-271">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="9a5ce-272">Establecer el modo de transferencia no se refleja en la descripción de la interfaz de servicio.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-272">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="9a5ce-273">Después de generar un cliente de WCF a un servicio, debe editar el archivo de configuración para los servicios pensados para usarse con transferencias transmitidas para establecer el modo.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-273">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="9a5ce-274">En los transportes con canalizaciones con nombre y TCP, el modo de transferencia se propaga como una aserción de directiva.</span><span class="sxs-lookup"><span data-stu-id="9a5ce-274">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9a5ce-275">Vea también</span><span class="sxs-lookup"><span data-stu-id="9a5ce-275">See also</span></span>

- [<span data-ttu-id="9a5ce-276">Procedimiento para habilitar el streaming</span><span class="sxs-lookup"><span data-stu-id="9a5ce-276">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
