---
title: Expresiones de código delimitadas
description: 'Obtenga información sobre las expresiones de código delimitadas de F #, una característica del lenguaje que permite generar y trabajar con las expresiones de código de F # mediante programación.'
ms.date: 08/13/2020
ms.openlocfilehash: dc37fdbd6cd29e5ee94e5c0186dfe2bfeb666f32
ms.sourcegitcommit: f99115e12a5eb75638abe45072e023a3ce3351ac
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/12/2020
ms.locfileid: "94557199"
---
# <a name="code-quotations"></a><span data-ttu-id="1f0bb-103">Expresiones de código delimitadas</span><span class="sxs-lookup"><span data-stu-id="1f0bb-103">Code quotations</span></span>

<span data-ttu-id="1f0bb-104">En este artículo se describen las expresiones de *código delimitadas* , una característica del lenguaje que permite generar y trabajar con las expresiones de código de F # mediante programación.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-104">This article describes *code quotations* , a language feature that enables you to generate and work with F# code expressions programmatically.</span></span> <span data-ttu-id="1f0bb-105">Esta característica permite generar un árbol de sintaxis abstracta que representa el código de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-105">This feature lets you generate an abstract syntax tree that represents F# code.</span></span> <span data-ttu-id="1f0bb-106">A continuación, el árbol de sintaxis abstracta puede atravesarse y procesarse según las necesidades de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-106">The abstract syntax tree can then be traversed and processed according to the needs of your application.</span></span> <span data-ttu-id="1f0bb-107">Por ejemplo, puede usar el árbol para generar código de F # o generar código en otro lenguaje.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-107">For example, you can use the tree to generate F# code or generate code in some other language.</span></span>

## <a name="quoted-expressions"></a><span data-ttu-id="1f0bb-108">Expresiones entre comillas</span><span class="sxs-lookup"><span data-stu-id="1f0bb-108">Quoted Expressions</span></span>

<span data-ttu-id="1f0bb-109">Una *expresión entre comillas* es una expresión de F # en el código que está delimitada de manera que no se compila como parte del programa, sino que se compila en un objeto que representa una expresión de f #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-109">A *quoted expression* is an F# expression in your code that is delimited in such a way that it is not compiled as part of your program, but instead is compiled into an object that represents an F# expression.</span></span> <span data-ttu-id="1f0bb-110">Puede marcar una expresión entre comillas de una de estas dos maneras: con información de tipo o sin información de tipo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-110">You can mark a quoted expression in one of two ways: either with type information or without type information.</span></span> <span data-ttu-id="1f0bb-111">Si desea incluir información de tipo, use los símbolos `<@` y `@>` para delimitar la expresión entre comillas.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-111">If you want to include type information, you use the symbols `<@` and `@>` to delimit the quoted expression.</span></span> <span data-ttu-id="1f0bb-112">Si no necesita información de tipo, use los símbolos `<@@` y `@@>` .</span><span class="sxs-lookup"><span data-stu-id="1f0bb-112">If you do not need type information, you use the symbols `<@@` and `@@>`.</span></span> <span data-ttu-id="1f0bb-113">En el código siguiente se muestran las comillas con tipo y sin tipo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-113">The following code shows typed and untyped quotations.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

<span data-ttu-id="1f0bb-114">Atravesar un árbol de expresión grande es más rápido si no incluye información de tipo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-114">Traversing a large expression tree is faster if you do not include type information.</span></span> <span data-ttu-id="1f0bb-115">El tipo resultante de una expresión entre comillas con los símbolos con tipo es `Expr<'T>` , donde el parámetro de tipo tiene el tipo de la expresión determinado por el algoritmo de inferencia de tipos del compilador de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-115">The resulting type of an expression quoted with the typed symbols is `Expr<'T>`, where the type parameter has the type of the expression as determined by the F# compiler's type inference algorithm.</span></span> <span data-ttu-id="1f0bb-116">Cuando se usan expresiones de código delimitadas sin información de tipos, el tipo de la expresión entrecomillada es el tipo no genérico [expr](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr.html).</span><span class="sxs-lookup"><span data-stu-id="1f0bb-116">When you use code quotations without type information, the type of the quoted expression is the non-generic type [Expr](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr.html).</span></span> <span data-ttu-id="1f0bb-117">Puede llamar a la propiedad [raw](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr-1.html#Raw) en la clase con tipo `Expr` para obtener el objeto sin tipo `Expr` .</span><span class="sxs-lookup"><span data-stu-id="1f0bb-117">You can call the [Raw](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr-1.html#Raw) property on the typed `Expr` class to obtain the untyped `Expr` object.</span></span>

<span data-ttu-id="1f0bb-118">Hay una variedad de métodos estáticos que permiten generar objetos de expresión de F # mediante programación en la `Expr` clase sin usar expresiones entre comillas.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-118">There are a variety of static methods that allow you to generate F# expression objects programmatically in the `Expr` class without using quoted expressions.</span></span>

<span data-ttu-id="1f0bb-119">Tenga en cuenta que una expresión de código delimitada debe incluir una expresión completa.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-119">Note that a code quotation must include a complete expression.</span></span> <span data-ttu-id="1f0bb-120">Para un `let` enlace, por ejemplo, necesitará la definición del nombre enlazado y una expresión adicional que use el enlace.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-120">For a `let` binding, for example, you need both the definition of the bound name and an additional expression that uses the binding.</span></span> <span data-ttu-id="1f0bb-121">En la sintaxis detallada, se trata de una expresión que sigue a la `in` palabra clave.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-121">In verbose syntax, this is an expression that follows the `in` keyword.</span></span> <span data-ttu-id="1f0bb-122">En el nivel superior de un módulo, se trata simplemente de la siguiente expresión del módulo, pero en una expresión de código delimitada, se requiere explícitamente.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-122">At the top-level in a module, this is just the next expression in the module, but in a quotation, it is explicitly required.</span></span>

<span data-ttu-id="1f0bb-123">Por lo tanto, la siguiente expresión no es válida.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-123">Therefore, the following expression is not valid.</span></span>

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

<span data-ttu-id="1f0bb-124">Pero las siguientes expresiones son válidas.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-124">But the following expressions are valid.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

<span data-ttu-id="1f0bb-125">Para evaluar las comillas de F #, debe utilizar el [evaluador de Comillas de f #](https://github.com/fsprojects/FSharp.Quotations.Evaluator).</span><span class="sxs-lookup"><span data-stu-id="1f0bb-125">To evaluate F# quotations, you must use the [F# Quotation Evaluator](https://github.com/fsprojects/FSharp.Quotations.Evaluator).</span></span> <span data-ttu-id="1f0bb-126">Proporciona compatibilidad para evaluar y ejecutar objetos de expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-126">It provides support for evaluating and executing F# expression objects.</span></span>

<span data-ttu-id="1f0bb-127">Las comillas de F # también conservan la información de restricciones de tipos.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-127">F# quotations also retain type constraint information.</span></span> <span data-ttu-id="1f0bb-128">Considere el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="1f0bb-128">Consider the following example:</span></span>

```fsharp
open FSharp.Linq.RuntimeHelpers

let eval q = LeafExpressionConverter.EvaluateQuotation q

let inline negate x = -x
// val inline negate: x: ^a ->  ^a when  ^a : (static member ( ~- ) :  ^a ->  ^a)

<@ negate 1.0 @>  |> eval
```

<span data-ttu-id="1f0bb-129">La restricción generada por la `inline` función se conserva en el código qutoation.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-129">The constraint generated by the `inline` function is retained in the code qutoation.</span></span> <span data-ttu-id="1f0bb-130">`negate`Ahora se puede evaluar el formulario quotated de la función.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-130">The `negate` function's quotated form can now be evaluated.</span></span>

## <a name="expr-type"></a><span data-ttu-id="1f0bb-131">Tipo de expresión</span><span class="sxs-lookup"><span data-stu-id="1f0bb-131">Expr Type</span></span>

<span data-ttu-id="1f0bb-132">Una instancia del `Expr` tipo representa una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-132">An instance of the `Expr` type represents an F# expression.</span></span> <span data-ttu-id="1f0bb-133">Los tipos genéricos y no genéricos `Expr` están documentados en la documentación de la biblioteca de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-133">Both the generic and the non-generic `Expr` types are documented in the F# library documentation.</span></span> <span data-ttu-id="1f0bb-134">Para obtener más información, vea [FSharp. Quotations (espacio de nombres](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations.html) ) y [Quotations. expr (clase](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr.html)).</span><span class="sxs-lookup"><span data-stu-id="1f0bb-134">For more information, see [FSharp.Quotations Namespace](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations.html) and [Quotations.Expr Class](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-fsharpexpr.html).</span></span>

## <a name="splicing-operators"></a><span data-ttu-id="1f0bb-135">Operadores de inserción</span><span class="sxs-lookup"><span data-stu-id="1f0bb-135">Splicing Operators</span></span>

<span data-ttu-id="1f0bb-136">La inserción permite combinar las expresiones de código delimitadas de literales con las expresiones que ha creado mediante programación o desde otro código de Comillas.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-136">Splicing enables you to combine literal code quotations with expressions that you have created programmatically or from another code quotation.</span></span> <span data-ttu-id="1f0bb-137">Los `%` `%%` operadores y permiten agregar un objeto Expression de F # en una expresión de código delimitada.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-137">The `%` and `%%` operators enable you to add an F# expression object into a code quotation.</span></span> <span data-ttu-id="1f0bb-138">El operador se usa `%` para insertar un objeto de expresión con tipo en una comilla con tipo; el `%%` operador se usa para insertar un objeto de expresión sin tipo en una comilla sin tipo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-138">You use the `%` operator to insert a typed expression object into a typed quotation; you use the `%%` operator to insert an untyped expression object into an untyped quotation.</span></span> <span data-ttu-id="1f0bb-139">Ambos operadores son operadores de prefijo unario.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-139">Both operators are unary prefix operators.</span></span> <span data-ttu-id="1f0bb-140">Por lo tanto `expr` , si es una expresión sin tipo de tipo `Expr` , el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-140">Thus if `expr` is an untyped expression of type `Expr`, the following code is valid.</span></span>

```fsharp
<@@ 1 + %%expr @@>
```

<span data-ttu-id="1f0bb-141">Y si `expr` es una comilla con tipo de tipo `Expr<int>` , el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-141">And if `expr` is a typed quotation of type `Expr<int>`, the following code is valid.</span></span>

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a><span data-ttu-id="1f0bb-142">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="1f0bb-142">Example</span></span>

### <a name="description"></a><span data-ttu-id="1f0bb-143">Descripción</span><span class="sxs-lookup"><span data-stu-id="1f0bb-143">Description</span></span>

<span data-ttu-id="1f0bb-144">En el ejemplo siguiente se muestra el uso de expresiones de código delimitadas para colocar código de F # en un objeto de expresión y, a continuación, imprimir el código de F # que representa la expresión.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-144">The following example illustrates the use of code quotations to put F# code into an expression object and then print the F# code that represents the expression.</span></span> <span data-ttu-id="1f0bb-145">`println`Se define una función que contiene una función recursiva `print` que muestra un objeto de expresión de F # (de tipo `Expr` ) en un formato descriptivo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-145">A function `println` is defined that contains a recursive function `print` that displays an F# expression object (of type `Expr`) in a friendly format.</span></span> <span data-ttu-id="1f0bb-146">Hay varios patrones activos en los módulos [FSharp. Quotations. Patterns](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-patternsmodule.html) y [FSharp. Quotations. DerivedPatterns](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-derivedpatternsmodule.html) que se pueden usar para analizar objetos de expresión.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-146">There are several active patterns in the [FSharp.Quotations.Patterns](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-patternsmodule.html) and [FSharp.Quotations.DerivedPatterns](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-derivedpatternsmodule.html) modules that can be used to analyze expression objects.</span></span> <span data-ttu-id="1f0bb-147">En este ejemplo no se incluyen todos los patrones posibles que pueden aparecer en una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-147">This example does not include all the possible patterns that might appear in an F# expression.</span></span> <span data-ttu-id="1f0bb-148">Cualquier patrón no reconocido desencadena una coincidencia con el patrón de caracteres comodín ( `_` ) y se representa mediante el `ToString` método, que, en el `Expr` tipo, permite conocer el modelo activo que se va a agregar a la expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-148">Any unrecognized pattern triggers a match to the wildcard pattern (`_`) and is rendered by using the `ToString` method, which, on the `Expr` type, lets you know the active pattern to add to your match expression.</span></span>

### <a name="code"></a><span data-ttu-id="1f0bb-149">Código</span><span class="sxs-lookup"><span data-stu-id="1f0bb-149">Code</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet601.fs)]

### <a name="output"></a><span data-ttu-id="1f0bb-150">Resultados</span><span class="sxs-lookup"><span data-stu-id="1f0bb-150">Output</span></span>

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a><span data-ttu-id="1f0bb-151">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="1f0bb-151">Example</span></span>

### <a name="description"></a><span data-ttu-id="1f0bb-152">Descripción</span><span class="sxs-lookup"><span data-stu-id="1f0bb-152">Description</span></span>

<span data-ttu-id="1f0bb-153">También puede usar los tres patrones activos en el [módulo ExprShape](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-exprshapemodule.html) para recorrer los árboles de expresión con menos patrones activos.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-153">You can also use the three active patterns in the [ExprShape module](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-exprshapemodule.html) to traverse expression trees with fewer active patterns.</span></span> <span data-ttu-id="1f0bb-154">Estos modelos activos pueden ser útiles si desea atravesar un árbol, pero no necesita toda la información en la mayoría de los nodos.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-154">These active patterns can be useful when you want to traverse a tree but you do not need all the information in most of the nodes.</span></span> <span data-ttu-id="1f0bb-155">Cuando se usan estos patrones, cualquier expresión de F # coincide con uno de los tres patrones siguientes: `ShapeVar` si la expresión es una variable, `ShapeLambda` si la expresión es una expresión lambda, o `ShapeCombination` si la expresión es otra cosa.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-155">When you use these patterns, any F# expression matches one of the following three patterns: `ShapeVar` if the expression is a variable, `ShapeLambda` if the expression is a lambda expression, or `ShapeCombination` if the expression is anything else.</span></span> <span data-ttu-id="1f0bb-156">Si atraviesa un árbol de expresión usando los modelos activos como en el ejemplo de código anterior, tendrá que usar muchos más patrones para controlar todos los posibles tipos de expresión de F # y el código será más complejo.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-156">If you traverse an expression tree by using the active patterns as in the previous code example, you have to use many more patterns to handle all possible F# expression types, and your code will be more complex.</span></span> <span data-ttu-id="1f0bb-157">Para obtener más información, consulte [ExprShape. ShapeVar&#124;ShapeLambda&#124;Active Pattern](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-exprshapemodule.html#(%20|ShapeVar|ShapeLambda|ShapeCombination|%20)).</span><span class="sxs-lookup"><span data-stu-id="1f0bb-157">For more information, see [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination Active Pattern](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-exprshapemodule.html#(%20|ShapeVar|ShapeLambda|ShapeCombination|%20)).</span></span>

<span data-ttu-id="1f0bb-158">El siguiente ejemplo de código se puede utilizar como base para los recorridos más complejos.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-158">The following code example can be used as a basis for more complex traversals.</span></span> <span data-ttu-id="1f0bb-159">En este código, se crea un árbol de expresión para una expresión que implica una llamada de función, `add` .</span><span class="sxs-lookup"><span data-stu-id="1f0bb-159">In this code, an expression tree is created for an expression that involves a function call, `add`.</span></span> <span data-ttu-id="1f0bb-160">El modelo activo [SpecificCall (](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-derivedpatternsmodule.html#(%20|SpecificCall|_|%20)) se usa para detectar cualquier llamada a `add` en el árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-160">The [SpecificCall](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-quotations-derivedpatternsmodule.html#(%20|SpecificCall|_|%20)) active pattern is used to detect any call to `add` in the expression tree.</span></span> <span data-ttu-id="1f0bb-161">Este modelo activo asigna los argumentos de la llamada al `exprList` valor.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-161">This active pattern assigns the arguments of the call to the `exprList` value.</span></span> <span data-ttu-id="1f0bb-162">En este caso, solo hay dos, por lo que se extraen y se llama a la función de forma recursiva en los argumentos.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-162">In this case, there are only two, so these are pulled out and the function is called recursively on the arguments.</span></span> <span data-ttu-id="1f0bb-163">Los resultados se insertan en una expresión de código que representa una llamada a `mul` mediante el operador de inserción ( `%%` ).</span><span class="sxs-lookup"><span data-stu-id="1f0bb-163">The results are inserted into a code quotation that represents a call to `mul` by using the splice operator (`%%`).</span></span> <span data-ttu-id="1f0bb-164">La `println` función del ejemplo anterior se usa para mostrar los resultados.</span><span class="sxs-lookup"><span data-stu-id="1f0bb-164">The `println` function from the previous example is used to display the results.</span></span>

<span data-ttu-id="1f0bb-165">El código de las otras ramas del modelo activo simplemente vuelve a generar el mismo árbol de expresión, por lo que el único cambio en la expresión resultante es el cambio de `add` a `mul` .</span><span class="sxs-lookup"><span data-stu-id="1f0bb-165">The code in the other active pattern branches just regenerates the same expression tree, so the only change in the resulting expression is the change from `add` to `mul`.</span></span>

### <a name="code"></a><span data-ttu-id="1f0bb-166">Código</span><span class="sxs-lookup"><span data-stu-id="1f0bb-166">Code</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet701.fs)]

### <a name="output"></a><span data-ttu-id="1f0bb-167">Salida</span><span class="sxs-lookup"><span data-stu-id="1f0bb-167">Output</span></span>

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a><span data-ttu-id="1f0bb-168">Vea también</span><span class="sxs-lookup"><span data-stu-id="1f0bb-168">See also</span></span>

- [<span data-ttu-id="1f0bb-169">Referencia del lenguaje F#</span><span class="sxs-lookup"><span data-stu-id="1f0bb-169">F# Language Reference</span></span>](index.md)
