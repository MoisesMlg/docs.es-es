---
title: Diseñar las validaciones en el nivel de modelo de dominio
description: Arquitectura de microservicios de .NET para aplicaciones .NET en contenedores | Información sobre conceptos clave de las validaciones de modelo de dominio.
ms.date: 10/08/2018
ms.openlocfilehash: 18c8350d0bf514a8a01a210a2a2a6d8f73317580
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94820636"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="d0f49-103">Diseño de validaciones en el nivel de modelo de dominio</span><span class="sxs-lookup"><span data-stu-id="d0f49-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="d0f49-104">En el diseño guiado por el dominio (DDD), las reglas de validación se pueden considerar invariables.</span><span class="sxs-lookup"><span data-stu-id="d0f49-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="d0f49-105">La responsabilidad principal de un agregado es aplicar invariables en todos los cambios de estado para todas las entidades de ese agregado.</span><span class="sxs-lookup"><span data-stu-id="d0f49-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="d0f49-106">Las entidades de dominio siempre deben ser entidades válidas.</span><span class="sxs-lookup"><span data-stu-id="d0f49-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="d0f49-107">Hay un número determinado de invariables para un objeto que siempre deben ser verdaderas.</span><span class="sxs-lookup"><span data-stu-id="d0f49-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="d0f49-108">Por ejemplo, un objeto de un elemento de pedido siempre debe tener una cantidad que debe constar de un entero positivo, un nombre de artículo y un precio.</span><span class="sxs-lookup"><span data-stu-id="d0f49-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="d0f49-109">Por lo tanto, la aplicación de invariables es responsabilidad de las entidades de dominio (en especial de la raíz agregada) y un objeto de entidad no debería poder existir si no es válido.</span><span class="sxs-lookup"><span data-stu-id="d0f49-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="d0f49-110">Las reglas invariables se expresan como contratos y, si se infringen, se generan excepciones o notificaciones.</span><span class="sxs-lookup"><span data-stu-id="d0f49-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="d0f49-111">El razonamiento es que se producen muchos errores porque los objetos tienen un estado que no deberían tener nunca.</span><span class="sxs-lookup"><span data-stu-id="d0f49-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span>

<span data-ttu-id="d0f49-112">Ahora imaginémonos que tenemos un SendUserCreationEmailService que toma un UserProfile… ¿Cómo podemos justificar en ese servicio que Name no es nulo?</span><span class="sxs-lookup"><span data-stu-id="d0f49-112">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="d0f49-113">¿Lo volvemos a comprobar?</span><span class="sxs-lookup"><span data-stu-id="d0f49-113">Do we check it again?</span></span> <span data-ttu-id="d0f49-114">O lo que es más probable: no se molesta en comprobarlo y "espera lo mejor" (espera que alguien se haya molestado en validarlo antes de enviárselo).</span><span class="sxs-lookup"><span data-stu-id="d0f49-114">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="d0f49-115">Por supuesto, si usamos TDD, una de las primeras pruebas que deberíamos escribir es que si, al enviar un cliente con un nombre nulo, se generaría un error.</span><span class="sxs-lookup"><span data-stu-id="d0f49-115">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="d0f49-116">Pero, una vez que empezamos a escribir estos tipos de pruebas una y otra vez, nos damos cuenta de que… "Espera, si no hubiéramos dejado que Name fuera nulo, no tendríamos todas estas pruebas".</span><span class="sxs-lookup"><span data-stu-id="d0f49-116">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests".</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="d0f49-117">Implementación de validaciones en el nivel de modelo de dominio</span><span class="sxs-lookup"><span data-stu-id="d0f49-117">Implement validations in the domain model layer</span></span>

<span data-ttu-id="d0f49-118">Las validaciones se suelen implementar en constructores de entidad de dominio o en métodos que pueden actualizar la entidad.</span><span class="sxs-lookup"><span data-stu-id="d0f49-118">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="d0f49-119">Hay varias maneras de implementar las validaciones, como la comprobación de los datos y la generación de excepciones si se produce un error en la validación.</span><span class="sxs-lookup"><span data-stu-id="d0f49-119">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="d0f49-120">También hay patrones más avanzados, como el uso del patrón de especificación para las validaciones y el patrón de notificación para devolver una colección de errores en lugar de devolver una excepción para cada validación mientras se produce.</span><span class="sxs-lookup"><span data-stu-id="d0f49-120">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="d0f49-121">Validación de condiciones y generación de excepciones</span><span class="sxs-lookup"><span data-stu-id="d0f49-121">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="d0f49-122">En el siguiente ejemplo de código se muestra el método de validación más sencillo en una entidad de dominio mediante la generación de una excepción.</span><span class="sxs-lookup"><span data-stu-id="d0f49-122">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="d0f49-123">En la tabla de referencias que encontrará al final de esta sección puede ver vínculos a implementaciones más avanzadas según los patrones que hemos analizado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d0f49-123">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="d0f49-124">Un ejemplo mejor demostraría la necesidad de garantizar que el estado interno no varió o que se produjeron todas las mutaciones de un método.</span><span class="sxs-lookup"><span data-stu-id="d0f49-124">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="d0f49-125">Por ejemplo, la siguiente implementación dejaría el objeto en un estado no válido:</span><span class="sxs-lookup"><span data-stu-id="d0f49-125">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="d0f49-126">Si el valor del estado no es válido, la primera línea de dirección y la ciudad ya se han cambiado,</span><span class="sxs-lookup"><span data-stu-id="d0f49-126">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="d0f49-127">lo cual podría invalidar la dirección.</span><span class="sxs-lookup"><span data-stu-id="d0f49-127">That might make the address invalid.</span></span>

<span data-ttu-id="d0f49-128">Se puede aplicar un enfoque similar en el constructor de la entidad, generando una excepción para garantizar que la entidad sea válida una vez creada.</span><span class="sxs-lookup"><span data-stu-id="d0f49-128">A similar approach can be used in the entity's constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="d0f49-129">Uso de atributos de validación en el modelo en función de las anotaciones de datos</span><span class="sxs-lookup"><span data-stu-id="d0f49-129">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="d0f49-130">Las anotaciones de datos, como los atributos MaxLength o Required, se pueden usar para configurar las propiedades de campo de base de datos de EF Core, como se explica en detalle en la sección [Asignación de tabla](infrastructure-persistence-layer-implementation-entity-framework-core.md#table-mapping), pero [ya no funcionan para la validación de entidades en EF Core](https://github.com/dotnet/efcore/issues/3680) (tampoco funciona el método <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType>), tal y como lo han hecho desde EF 4.x en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d0f49-130">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implementation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/dotnet/efcore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="d0f49-131">Las anotaciones de datos y la interfaz <xref:System.ComponentModel.DataAnnotations.IValidatableObject> todavía se pueden usar para la validación del modelo durante el enlace de modelos, antes de la invocación de acciones del controlador como de costumbre, pero ese modelo está pensado para ser un ViewModel o DTO, y eso atañe a MVC o la API, no al modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="d0f49-131">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller's actions invocation as usual, but that model is meant to be a ViewModel or DTO and that's an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="d0f49-132">Después de tener la diferencia conceptual clara, todavía puede usar anotaciones de datos y `IValidatableObject` en la clase de entidad para la validación, si las acciones reciben un parámetro de objeto de clase de entidad, lo que no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="d0f49-132">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="d0f49-133">En ese caso, la validación se producirá durante el enlace de modelos, justo antes de invocar la acción y se puede comprobar la propiedad ModelState.IsValid del controlador para comprobar el resultado, pero nuevamente, ocurre en el controlador, no antes de guardar el objeto de entidad en el DbContext, tal como se había llevado a cabo desde EF 4.x.</span><span class="sxs-lookup"><span data-stu-id="d0f49-133">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller's ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="d0f49-134">Todavía puede implementar la validación personalizada en la clase de entidad con las anotaciones de datos y el método `IValidatableObject.Validate` invalidando el método SaveChanges de DbContext.</span><span class="sxs-lookup"><span data-stu-id="d0f49-134">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext's SaveChanges method.</span></span>

<span data-ttu-id="d0f49-135">Puede ver un ejemplo de implementación de la validación de entidades de `IValidatableObject` en [este comentario en GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span><span class="sxs-lookup"><span data-stu-id="d0f49-135">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="d0f49-136">Ese ejemplo no realiza validaciones basadas en atributos, pero deberían ser fáciles de implementar mediante la reflexión en el mismo reemplazo.</span><span class="sxs-lookup"><span data-stu-id="d0f49-136">That sample doesn't do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="d0f49-137">Aunque, desde la óptica del DDD, el modelo de dominio se ajusta mejor con el uso de excepciones en los métodos de comportamiento de la entidad o con la implementación de los patrones de especificación y notificación para aplicar reglas de validación.</span><span class="sxs-lookup"><span data-stu-id="d0f49-137">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity's behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="d0f49-138">Puede resultar lógico usar anotaciones de datos en el nivel de aplicación en las clases ViewModel (en lugar de hacerlo en las entidades de dominio) que aceptarán la entrada a fin de permitirlas para la validación del modelo en la capa de la interfaz de usuario,</span><span class="sxs-lookup"><span data-stu-id="d0f49-138">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="d0f49-139">pero no se debería hacer en la exclusión de validación dentro del modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="d0f49-139">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="d0f49-140">Validación de entidades implementando el patrón de especificación y el patrón de notificación</span><span class="sxs-lookup"><span data-stu-id="d0f49-140">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="d0f49-141">Por último, un enfoque más elaborado para implementar validaciones en el modelo de dominio consiste en implementar el patrón de especificación junto con el patrón de notificación, como se explica en algunos de los recursos adicionales que se muestran más adelante.</span><span class="sxs-lookup"><span data-stu-id="d0f49-141">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="d0f49-142">Merece la pena mencionar que también se puede usar solo uno de estos patrones (por ejemplo, validándolo manualmente con instrucciones de control, pero usando el patrón de notificación para apilar y devolver una lista de errores de validación).</span><span class="sxs-lookup"><span data-stu-id="d0f49-142">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="d0f49-143">Uso de la validación diferida en el dominio</span><span class="sxs-lookup"><span data-stu-id="d0f49-143">Use deferred validation in the domain</span></span>

<span data-ttu-id="d0f49-144">Hay varios métodos para tratar las validaciones diferidas en el dominio.</span><span class="sxs-lookup"><span data-stu-id="d0f49-144">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="d0f49-145">En su libro [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577) (Implementación del diseño guiado por el dominio), Vaughn Vernon habla de ellos en la sección sobre la validación.</span><span class="sxs-lookup"><span data-stu-id="d0f49-145">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="d0f49-146">Validación en dos pasos</span><span class="sxs-lookup"><span data-stu-id="d0f49-146">Two-step validation</span></span>

<span data-ttu-id="d0f49-147">Plantéese también usar la validación en dos pasos.</span><span class="sxs-lookup"><span data-stu-id="d0f49-147">Also consider two-step validation.</span></span> <span data-ttu-id="d0f49-148">Use la validación de nivel de campo en los objetos de transferencia de datos (DTO) de comandos y la validación de nivel de dominio dentro de las entidades.</span><span class="sxs-lookup"><span data-stu-id="d0f49-148">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="d0f49-149">Para ello, puede devolver un objeto de resultado en vez de excepciones para que resulte más fácil tratar los errores de validación.</span><span class="sxs-lookup"><span data-stu-id="d0f49-149">You can do this by returning a result object instead of exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="d0f49-150">Si usa la validación de campos con anotaciones de datos, por ejemplo, no se duplica la definición de validación.</span><span class="sxs-lookup"><span data-stu-id="d0f49-150">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="d0f49-151">Pero la ejecución puede ser del lado servidor y del lado cliente en el caso de los DTO (comandos y ViewModels, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="d0f49-151">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="d0f49-152">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="d0f49-152">Additional resources</span></span>

- <span data-ttu-id="d0f49-153">**Rachel Appel. Validación de modelos en ASP.NET Core MVC** </span><span class="sxs-lookup"><span data-stu-id="d0f49-153">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** </span></span>\
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="d0f49-154">**Rick Anderson. Agregar validación a una aplicación ASP.NET Core MVC** </span><span class="sxs-lookup"><span data-stu-id="d0f49-154">**Rick Anderson. Adding validation** </span></span>\
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="d0f49-155">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** \ (Reemplazo del inicio de excepciones por notificaciones en validaciones)</span><span class="sxs-lookup"><span data-stu-id="d0f49-155">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** </span></span>\
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="d0f49-156">**Specification and Notification Patterns** \ (Patrones de especificación y notificación)</span><span class="sxs-lookup"><span data-stu-id="d0f49-156">**Specification and Notification Patterns** </span></span>\
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="d0f49-157">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)**  \ (Validación en diseños guiados por dominio)</span><span class="sxs-lookup"><span data-stu-id="d0f49-157">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** </span></span>\
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="d0f49-158">**Colin Jack. Domain Model Validation** \ (Validación de modelos de dominio)</span><span class="sxs-lookup"><span data-stu-id="d0f49-158">**Colin Jack. Domain Model Validation** </span></span>\
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="d0f49-159">**Jimmy Bogard. Validation in a DDD world** \ (Validación en un mundo de diseños guiados por dominio)</span><span class="sxs-lookup"><span data-stu-id="d0f49-159">**Jimmy Bogard. Validation in a DDD world** </span></span>\
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="d0f49-160">[Anterior](enumeration-classes-over-enum-types.md)
> [Siguiente](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="d0f49-160">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>
