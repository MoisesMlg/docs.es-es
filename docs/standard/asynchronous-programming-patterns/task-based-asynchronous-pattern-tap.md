---
title: Modelo asincrónico basado en tareas (TAP)
description: Descubra el modelo asincrónico basado en tareas (TAP). TAP es el modelo asincrónico de diseño recomendado para los nuevos desarrollos en .NET.
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 2987e7baa52f627d1da41af21d05bfa22a247fbb
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889249"
---
# <a name="task-based-asynchronous-pattern"></a><span data-ttu-id="e2b82-104">Modelo asincrónico basado en tareas</span><span class="sxs-lookup"><span data-stu-id="e2b82-104">Task-based asynchronous pattern</span></span>

<span data-ttu-id="e2b82-105">El modelo asincrónico basado en tareas (TAP) se basa en los tipos <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> del espacio de nombres <xref:System.Threading.Tasks?displayProperty=nameWithType>, que se usan para representar operaciones asincrónicas arbitrarias.</span><span class="sxs-lookup"><span data-stu-id="e2b82-105">The task-based asynchronous pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="e2b82-106">TAP es el patrón asincrónico de diseño recomendado para los nuevos desarrollos.</span><span class="sxs-lookup"><span data-stu-id="e2b82-106">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="e2b82-107">Nombres, parámetros y tipos de valores devueltos</span><span class="sxs-lookup"><span data-stu-id="e2b82-107">Naming, parameters, and return types</span></span>

<span data-ttu-id="e2b82-108">TAP usa un solo método para representar el inicio y la finalización de una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="e2b82-108">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="e2b82-109">Esto contrasta con el modelo de programación asincrónico (APM o `IAsyncResult`) y con el modelo asincrónico basado en eventos (EAP).</span><span class="sxs-lookup"><span data-stu-id="e2b82-109">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="e2b82-110">APM requiere los métodos `Begin` y `End`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-110">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="e2b82-111">EPA requiere un método con el sufijo `Async` y también requiere uno o más eventos, tipos de delegado de controlador de eventos y tipos derivados de `EventArg`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-111">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="e2b82-112">Los métodos asincrónicos en TAP incluyen el sufijo `Async` después del nombre de la operación para los métodos que devuelven tipos que admiten await, como <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask> y <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-112">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="e2b82-113">Por ejemplo, una operación `Get` asincrónica que devuelve un `Task<String>` se puede denominar `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-113">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="e2b82-114">Si va a agregar un método de TAP a una clase que ya contiene un nombre de método EAP con el sufijo `Async`, use el sufijo `TaskAsync` en su lugar.</span><span class="sxs-lookup"><span data-stu-id="e2b82-114">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="e2b82-115">Por ejemplo, si la clase ya tiene un método `GetAsync`, use el nombre `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-115">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="e2b82-116">Si un método inicia una operación asincrónica pero no devuelve un tipo que admite await, su nombre debe comenzar por `Begin`, `Start` u otro verbo que sugiera que este método no devuelve ni genera el resultado de la operación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-116">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="e2b82-117">Un método de TAP devuelve <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, en función de si el método sincrónico correspondiente devuelve void o un tipo `TResult`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-117">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="e2b82-118">Los parámetros de un método de TAP deben coincidir con los parámetros de su homólogo sincrónico y se deben proporcionar en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="e2b82-118">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="e2b82-119">Sin embargo, los parámetros `out` y `ref` están exentos de esta regla y se deben evitar completamente.</span><span class="sxs-lookup"><span data-stu-id="e2b82-119">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="e2b82-120">En su lugar, los datos que se hubieran devuelto con un parámetro `out` o `ref` se deben devolver como parte del tipo `TResult` devuelto por <xref:System.Threading.Tasks.Task%601> y deben usar una tupla o una estructura de datos personalizada para incluir varios valores.</span><span class="sxs-lookup"><span data-stu-id="e2b82-120">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="e2b82-121">También debería plantearse la posibilidad de agregar un parámetro <xref:System.Threading.CancellationToken> aunque el homólogo sincrónico del método TAP no ofrezca ninguno.</span><span class="sxs-lookup"><span data-stu-id="e2b82-121">Also, consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="e2b82-122">Los métodos que están dedicados exclusivamente a la creación, manipulación o combinación de tareas (donde el intento asincrónico del método está claro en el nombre del método o en el nombre del tipo al que el método pertenece) no necesitan seguir este modelo de nomenclatura; esos métodos se conocen a menudo como *combinadores* (también denominados elementos de combinación).</span><span class="sxs-lookup"><span data-stu-id="e2b82-122">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="e2b82-123">Los ejemplos de combinadores incluyen <xref:System.Threading.Tasks.Task.WhenAll%2A> y <xref:System.Threading.Tasks.Task.WhenAny%2A>, y se describen en la sección que describe los combinadores integrados basados en tareas titulada [Usar los combinadores integrados basados en tareas](consuming-the-task-based-asynchronous-pattern.md#combinators) del artículo [Utilizar el modelo asincrónico basado en tareas](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="e2b82-123">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="e2b82-124">Para obtener ejemplos de cómo la sintaxis de TAP difiere de la sintaxis empleada en patrones heredados de programación asincrónica como el modelo de programación asincrónica (APM) y el patrón asincrónico basado en eventos (EAP), vea [Modelos para la programación asincrónica](index.md).</span><span class="sxs-lookup"><span data-stu-id="e2b82-124">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="e2b82-125">Inicio de una operación asincrónica</span><span class="sxs-lookup"><span data-stu-id="e2b82-125">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="e2b82-126">Un método asincrónico basado en TAP puede hacer una pequeña cantidad de trabajo sincrónicamente, como validar argumentos e iniciar la operación asincrónica, antes de que devuelva la tarea resultante.</span><span class="sxs-lookup"><span data-stu-id="e2b82-126">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="e2b82-127">El trabajo sincrónico debe reducirse al mínimo de modo que el método asincrónico pueda volver rápidamente.</span><span class="sxs-lookup"><span data-stu-id="e2b82-127">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="e2b82-128">Entre las razones para un retorno rápido se incluyen las siguientes:</span><span class="sxs-lookup"><span data-stu-id="e2b82-128">Reasons for a quick return include:</span></span>  
  
- <span data-ttu-id="e2b82-129">Los métodos asincrónicos se pueden invocar desde subprocesos de la interfaz de usuario (UI) y cualquier trabajo sincrónico de ejecución prolongada puede dañar la capacidad de respuesta de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-129">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="e2b82-130">Se pueden iniciar varios métodos asincrónicos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="e2b82-130">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="e2b82-131">Por tanto, cualquier trabajo de ejecución prolongada en la parte sincrónica de un método asincrónico puede retrasar el inicio de otras operaciones asincrónicas, lo que reduce las ventajas de la simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="e2b82-131">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="e2b82-132">En algunos casos, la cantidad de trabajo necesario para completar la operación es menor que la cantidad de trabajo necesario para iniciar la operación de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="e2b82-132">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="e2b82-133">La lectura de una secuencia donde la operación de lectura se puede satisfacer mediante datos que ya están almacenados en búfer en la memoria es un ejemplo de este escenario.</span><span class="sxs-lookup"><span data-stu-id="e2b82-133">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="e2b82-134">En casos como este, la operación puede completarse sincrónicamente y puede devolver una tarea que ya se ha completado.</span><span class="sxs-lookup"><span data-stu-id="e2b82-134">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="e2b82-135">Excepciones</span><span class="sxs-lookup"><span data-stu-id="e2b82-135">Exceptions</span></span>  
 <span data-ttu-id="e2b82-136">Un método asincrónico debe generar una excepción fuera de la llamada de método asincrónico solo como respuesta a un error de uso.</span><span class="sxs-lookup"><span data-stu-id="e2b82-136">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="e2b82-137">Los errores de uso nunca deben producirse en código de producción.</span><span class="sxs-lookup"><span data-stu-id="e2b82-137">Usage errors should never occur in production code.</span></span> <span data-ttu-id="e2b82-138">Por ejemplo, si al pasar una referencia nula (`Nothing` en Visual Basic) como uno de los argumentos del método se produce un estado de error (representado normalmente por una excepción <xref:System.ArgumentNullException>), puede modificar el código de llamada para asegurarse de que nunca se pase una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e2b82-138">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method's arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="e2b82-139">Para todos los demás errores, las excepciones que se producen cuando se ejecuta un método asincrónico deben asignarse a la tarea devuelta, aunque el método asincrónico se complete sincrónicamente antes de que se devuelva la tarea.</span><span class="sxs-lookup"><span data-stu-id="e2b82-139">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="e2b82-140">Normalmente, una tarea contiene como máximo una excepción.</span><span class="sxs-lookup"><span data-stu-id="e2b82-140">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="e2b82-141">Sin embargo, si la tarea representa varias operaciones (por ejemplo, <xref:System.Threading.Tasks.Task.WhenAll%2A>), se pueden asociar varias excepciones a una única tarea.</span><span class="sxs-lookup"><span data-stu-id="e2b82-141">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="e2b82-142">Entorno de destino</span><span class="sxs-lookup"><span data-stu-id="e2b82-142">Target environment</span></span>  
 <span data-ttu-id="e2b82-143">Cuando implementa un método de TAP, puede determinar dónde se produce la ejecución asincrónica.</span><span class="sxs-lookup"><span data-stu-id="e2b82-143">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="e2b82-144">Puede optar por ejecutar la carga de trabajo en el grupo de subprocesos, implementarla mediante E/S asincrónica (sin enlazarse a un subproceso durante la mayor parte de la ejecución de la operación), ejecutarla en un subproceso concreto (como el subproceso de la interfaz de usuario) o usar cualquier número de contextos posibles.</span><span class="sxs-lookup"><span data-stu-id="e2b82-144">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation's execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="e2b82-145">Un método de TAP incluso puede no tener nada que ejecutar y puede devolver simplemente una clase <xref:System.Threading.Tasks.Task> que representa la ocurrencia de una condición en otra ubicación en el sistema (por ejemplo, una tarea que representa datos que llegan a una estructura de datos en cola).</span><span class="sxs-lookup"><span data-stu-id="e2b82-145">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="e2b82-146">El autor de la llamada al método TAP puede bloquear la espera para que el método de TAP se complete mediante la espera sincrónica en la tarea resultante, o bien puede ejecutar código (de continuación) adicional cuando la operación asincrónica se completa.</span><span class="sxs-lookup"><span data-stu-id="e2b82-146">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="e2b82-147">El creador del código de continuación tiene control sobre lo que ese código ejecuta.</span><span class="sxs-lookup"><span data-stu-id="e2b82-147">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="e2b82-148">Puede crear el código de continuación explícitamente, mediante métodos de la clase <xref:System.Threading.Tasks.Task> (por ejemplo, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) o implícitamente, usando la compatibilidad con lenguaje sobre las continuaciones (por ejemplo, `await` en C#, `Await` en Visual Basic, `AwaitValue` en F#).</span><span class="sxs-lookup"><span data-stu-id="e2b82-148">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="e2b82-149">Estado de la tarea</span><span class="sxs-lookup"><span data-stu-id="e2b82-149">Task status</span></span>  
 <span data-ttu-id="e2b82-150">La clase <xref:System.Threading.Tasks.Task> proporciona un ciclo de vida para las operaciones asincrónicas y ese ciclo se representa mediante la enumeración <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-150">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="e2b82-151">Para admitir los casos extremos de tipos que se derivan de <xref:System.Threading.Tasks.Task> y <xref:System.Threading.Tasks.Task%601>, y para admitir la separación de la construcción de la programación, la clase <xref:System.Threading.Tasks.Task> expone un método <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-151">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="e2b82-152">Las tareas creadas por los constructores públicos <xref:System.Threading.Tasks.Task> se denominan *tareas en frío* , porque inician su ciclo de vida en el estado <xref:System.Threading.Tasks.TaskStatus.Created> no programado y solo se programan cuando se llama a <xref:System.Threading.Tasks.Task.Start%2A> en estas instancias.</span><span class="sxs-lookup"><span data-stu-id="e2b82-152">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks* , because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="e2b82-153">Todas las demás tareas inician su ciclo de vida en un estado activo, lo que significa que las operaciones asincrónicas que representan ya se han iniciado y su estado de la tarea es un valor de enumeración distinto de <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-153">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2b82-154">Todas las tareas que se devuelven de métodos de TAP deben estar activas.</span><span class="sxs-lookup"><span data-stu-id="e2b82-154">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="e2b82-155">**Si un método de TAP usa internamente el constructor de una tarea para crear instancias de la tarea que se va a devolver, el método de TAP debe llamar a <xref:System.Threading.Tasks.Task.Start%2A> en el objeto <xref:System.Threading.Tasks.Task> antes de devolverlo.**</span><span class="sxs-lookup"><span data-stu-id="e2b82-155">**If a TAP method internally uses a task's constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="e2b82-156">Los consumidores de un método de TAP pueden suponer con seguridad que la tarea devuelta está activa y no deben intentar llamar a <xref:System.Threading.Tasks.Task.Start%2A> en ningún <xref:System.Threading.Tasks.Task> que se devuelve de un método de TAP.</span><span class="sxs-lookup"><span data-stu-id="e2b82-156">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="e2b82-157">La llamada a <xref:System.Threading.Tasks.Task.Start%2A> en una tarea activa produce una excepción <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-157">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="e2b82-158">Cancelación (opcional)</span><span class="sxs-lookup"><span data-stu-id="e2b82-158">Cancellation (optional)</span></span>  
 <span data-ttu-id="e2b82-159">En TAP, la cancelación es opcional tanto para los implementadores de método asincrónico como para los consumidores de este método.</span><span class="sxs-lookup"><span data-stu-id="e2b82-159">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="e2b82-160">Si una operación permite la cancelación, expone una sobrecarga del método asincrónico que acepta un token de cancelación (instancia de <xref:System.Threading.CancellationToken>).</span><span class="sxs-lookup"><span data-stu-id="e2b82-160">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="e2b82-161">Por convención, el parámetro se denomina `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-161">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="e2b82-162">La operación asincrónica supervisa este token para las solicitudes de cancelación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-162">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="e2b82-163">Si recibe una solicitud de cancelación, puede elegir admitir esa solicitud y cancelar la operación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-163">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="e2b82-164">Si la solicitud de cancelación hace que el trabajo finalice prematuramente, el método de TAP devuelve una tarea que finaliza en el estado <xref:System.Threading.Tasks.TaskStatus.Canceled>; no hay ningún resultado disponible y no se produce ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="e2b82-164">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="e2b82-165">El estado <xref:System.Threading.Tasks.TaskStatus.Canceled> se considera un estado final (completado) para una tarea, junto con los estados <xref:System.Threading.Tasks.TaskStatus.Faulted> y <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-165">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="e2b82-166">Por tanto, si una tarea está en el estado <xref:System.Threading.Tasks.TaskStatus.Canceled>, su propiedad <xref:System.Threading.Tasks.Task.IsCompleted%2A> devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-166">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="e2b82-167">Cuando una tarea se completa en el estado <xref:System.Threading.Tasks.TaskStatus.Canceled>, cualquier continuación registrada con la tarea se programa o se ejecuta, a menos que se especificara una opción de continuación como <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> para rechazar la continuación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-167">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="e2b82-168">Cualquier código que espera de forma asincrónica una tarea cancelada mediante el uso de características del lenguaje sigue ejecutándose pero recibe un objeto <xref:System.OperationCanceledException> o una excepción derivada del mismo.</span><span class="sxs-lookup"><span data-stu-id="e2b82-168">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="e2b82-169">El código que se bloquea sincrónicamente en espera de la tarea mediante métodos como <xref:System.Threading.Tasks.Task.Wait%2A> y <xref:System.Threading.Tasks.Task.WaitAll%2A> también continúa ejecutándose con una excepción.</span><span class="sxs-lookup"><span data-stu-id="e2b82-169">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="e2b82-170">Si un token de cancelación ha solicitado la cancelación antes de que se llame al método de TAP que acepta ese token, el método de TAP debe devolver una tarea <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-170">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="e2b82-171">Sin embargo, si se solicita la cancelación mientras la operación asincrónica se ejecuta, la operación asincrónica no necesita aceptar la solicitud de cancelación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-171">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="e2b82-172">La tarea devuelta debe finalizar en el estado <xref:System.Threading.Tasks.TaskStatus.Canceled> solo si la operación termina como resultado de la solicitud de cancelación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-172">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="e2b82-173">Si se solicita la cancelación pero aún se produce un resultado o una excepción, la tarea debe finalizar en el estado <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> o <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-173">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="e2b82-174">En el caso de los métodos asincrónicos que quieren exponer la capacidad de cancelarse ante todo, no tiene que proporcionar una sobrecarga que no acepte un token de cancelación.</span><span class="sxs-lookup"><span data-stu-id="e2b82-174">For asynchronous methods that want to expose the ability to be canceled first and foremost, you don't have to provide an overload that doesn't accept a cancellation token.</span></span> <span data-ttu-id="e2b82-175">Para los métodos que no pueden cancelarse, no proporcione sobrecargas que acepten un token de cancelación; esto ayuda a indicar al llamador si el método de destino es realmente cancelable.</span><span class="sxs-lookup"><span data-stu-id="e2b82-175">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="e2b82-176">El código de consumidor que no desea la cancelación puede llamar a un método que acepta un objeto <xref:System.Threading.CancellationToken> y proporciona <xref:System.Threading.CancellationToken.None%2A> como valor del argumento.</span><span class="sxs-lookup"><span data-stu-id="e2b82-176">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="e2b82-177"><xref:System.Threading.CancellationToken.None%2A> es funcionalmente equivalente al objeto <xref:System.Threading.CancellationToken> predeterminado.</span><span class="sxs-lookup"><span data-stu-id="e2b82-177"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="e2b82-178">Informe de progreso (opcional)</span><span class="sxs-lookup"><span data-stu-id="e2b82-178">Progress reporting (optional)</span></span>  
 <span data-ttu-id="e2b82-179">Algunas operaciones asincrónicas se benefician de proporcionar notificaciones de progreso; se suelen usar para actualizar una interfaz de usuario con información sobre el progreso de la operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="e2b82-179">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="e2b82-180">En TAP, el progreso se controla a través de una interfaz <xref:System.IProgress%601>, la cual se pasa al método asincrónico como un parámetro normalmente denominado `progress`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-180">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="e2b82-181">Proporcionar la interfaz de progreso cuando se llama al método asincrónico ayuda a eliminar condiciones de carrera resultantes de un uso incorrecto (es decir, cuando los controladores de eventos registrados incorrectamente después del inicio de la operación pueden perder actualizaciones).</span><span class="sxs-lookup"><span data-stu-id="e2b82-181">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="e2b82-182">Lo que es más importante, la interfaz de progreso admite implementaciones diferentes de progreso, según determina el código usado.</span><span class="sxs-lookup"><span data-stu-id="e2b82-182">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="e2b82-183">Por ejemplo, el código usado puede que desee encargarse solo de la última actualización de progreso, almacenar en búfer todas las actualizaciones, invocar una acción para cada actualización o controlar si se serializa la invocación en un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="e2b82-183">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="e2b82-184">Todas estas opciones se pueden conseguir mediante otra implementación de la interfaz, personalizada según las necesidades particulares del consumidor.</span><span class="sxs-lookup"><span data-stu-id="e2b82-184">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer's needs.</span></span>  <span data-ttu-id="e2b82-185">Como ocurre con la cancelación, las implementaciones de TAP deben proporcionar un parámetro <xref:System.IProgress%601> solo si la API admite notificaciones de progreso.</span><span class="sxs-lookup"><span data-stu-id="e2b82-185">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="e2b82-186">Por ejemplo, si el método `ReadAsync` anteriormente mencionado en este artículo puede informar del progreso intermedio en forma de número de bytes leídos hasta el momento, la devolución de llamada de progreso puede ser una interfaz <xref:System.IProgress%601>:</span><span class="sxs-lookup"><span data-stu-id="e2b82-186">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="e2b82-187">Si un método `FindFilesAsync` devuelve una lista de todos los archivos que satisfacen un patrón particular de búsqueda, la devolución de progreso puede proporcionar una estimación del porcentaje de trabajo completado y el conjunto actual de resultados parciales.</span><span class="sxs-lookup"><span data-stu-id="e2b82-187">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed and the current set of partial results.</span></span> <span data-ttu-id="e2b82-188">Podría proporcionar esta información con una tupla:</span><span class="sxs-lookup"><span data-stu-id="e2b82-188">It could provide this information with either a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="e2b82-189">o con un tipo de datos que sea específico de la API:</span><span class="sxs-lookup"><span data-stu-id="e2b82-189">or with a data type that's specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="e2b82-190">En este último caso, el tipo de datos especial suele tener el sufijo `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-190">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="e2b82-191">Si las implementaciones de TAP proporcionan sobrecargas que aceptan un parámetro `progress`, deben permitir que el argumento sea `null`, en cuyo caso no se notificará ningún progreso.</span><span class="sxs-lookup"><span data-stu-id="e2b82-191">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress is reported.</span></span> <span data-ttu-id="e2b82-192">Las implementaciones de TAP deben notificar sincrónicamente el progreso al objeto <xref:System.Progress%601>, lo que permite que el método asincrónico proporcione rápidamente el progreso.</span><span class="sxs-lookup"><span data-stu-id="e2b82-192">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress.</span></span> <span data-ttu-id="e2b82-193">También permite al consumidor del progreso determinar cómo y dónde es mejor controlar la información.</span><span class="sxs-lookup"><span data-stu-id="e2b82-193">It also allows the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="e2b82-194">Por ejemplo, la instancia de progreso puede optar por hacerse con las devoluciones de llamada y generar eventos en un contexto capturado de sincronización.</span><span class="sxs-lookup"><span data-stu-id="e2b82-194">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="e2b82-195">Implementaciones\<T> de IProgress</span><span class="sxs-lookup"><span data-stu-id="e2b82-195">IProgress\<T> implementations</span></span>  
<span data-ttu-id="e2b82-196">.NET proporciona la clase <xref:System.Progress%601>, que implementa <xref:System.IProgress%601>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-196">.NET provides the <xref:System.Progress%601> class, which implements <xref:System.IProgress%601>.</span></span> <span data-ttu-id="e2b82-197">La clase <xref:System.Progress%601> se declara de la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="e2b82-197">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T>? ProgressChanged;  
}  
```
  
 <span data-ttu-id="e2b82-198">Una instancia de <xref:System.Progress%601> expone un evento <xref:System.Progress%601.ProgressChanged>, que se provoca cada vez que la operación asincrónica informe de una actualización de progreso.</span><span class="sxs-lookup"><span data-stu-id="e2b82-198">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="e2b82-199">El evento <xref:System.Progress%601.ProgressChanged> se genera en el objeto <xref:System.Threading.SynchronizationContext> que se capturó cuando se creó la instancia de <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-199">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="e2b82-200">Si no había ningún contexto de sincronización disponible, se usa un contexto predeterminado destinado al grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e2b82-200">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="e2b82-201">Los controladores pueden registrarse con este evento.</span><span class="sxs-lookup"><span data-stu-id="e2b82-201">Handlers may be registered with this event.</span></span> <span data-ttu-id="e2b82-202">También se puede proporcionar un único controlador al constructor <xref:System.Progress%601> por comodidad, y se comportará como un controlador de eventos para el evento <xref:System.Progress%601.ProgressChanged>.</span><span class="sxs-lookup"><span data-stu-id="e2b82-202">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="e2b82-203">Las actualizaciones de progreso se generan de forma asincrónica para evitar retrasar la operación asincrónica mientras los controladores de eventos se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="e2b82-203">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="e2b82-204">Otra implementación <xref:System.IProgress%601> podría elegir aplicar semánticas diferentes.</span><span class="sxs-lookup"><span data-stu-id="e2b82-204">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="e2b82-205">Elección de las sobrecargas que se van a proporcionar</span><span class="sxs-lookup"><span data-stu-id="e2b82-205">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="e2b82-206">Si una implementación TAP usa la propiedad <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> y los parámetros <xref:System.IProgress%601> opcionales, podría requerir hasta cuatro sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="e2b82-206">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="e2b82-207">Aunque muchas implementaciones de TAP no ofrecen funcionalidades de cancelación o progreso, por lo que requieren un único método:</span><span class="sxs-lookup"><span data-stu-id="e2b82-207">However, many TAP implementations don't provide cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="e2b82-208">Si una implementación de TAP admite la cancelación o el progreso pero no ambos, puede proporcionar dos sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="e2b82-208">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="e2b82-209">Si una implementación TAP admite la cancelación y el progreso, puede exponer las cuatro sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="e2b82-209">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="e2b82-210">Sin embargo, puede proporcionar solo las dos siguientes:</span><span class="sxs-lookup"><span data-stu-id="e2b82-210">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="e2b82-211">Para compensar las dos combinaciones intermedias que faltan, los desarrolladores pueden pasar la propiedad <xref:System.Threading.CancellationToken.None%2A> o un objeto <xref:System.Threading.CancellationToken> predeterminado para el parámetro `cancellationToken` y `null` para el parámetro `progress`.</span><span class="sxs-lookup"><span data-stu-id="e2b82-211">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="e2b82-212">Si se espera que cada uso del método TAP admita cancelación o progreso, puede omitir las sobrecargas que no acepten el parámetro pertinente.</span><span class="sxs-lookup"><span data-stu-id="e2b82-212">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don't accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="e2b82-213">Si se decide exponer varias sobrecargas para conseguir que la cancelación o el progreso sean opcionales, las sobrecargas que no admitan cancelación o progreso deben comportarse como si pasaran <xref:System.Threading.CancellationToken.None%2A> para la cancelación o `null` para el progreso en la sobrecarga que admite ambas.</span><span class="sxs-lookup"><span data-stu-id="e2b82-213">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don't support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-articles"></a><span data-ttu-id="e2b82-214">Artículos relacionados</span><span class="sxs-lookup"><span data-stu-id="e2b82-214">Related articles</span></span>
  
|<span data-ttu-id="e2b82-215">Title</span><span class="sxs-lookup"><span data-stu-id="e2b82-215">Title</span></span>|<span data-ttu-id="e2b82-216">Descripción</span><span class="sxs-lookup"><span data-stu-id="e2b82-216">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="e2b82-217">Patrones para la programación asincrónica</span><span class="sxs-lookup"><span data-stu-id="e2b82-217">Asynchronous Programming Patterns</span></span>](index.md)|<span data-ttu-id="e2b82-218">Presenta los tres patrones para realizar las operaciones asincrónicas: el patrón asincrónico basado en tareas (TAP), el modelo de programación asincrónica (APM) y el patrón asincrónico basado en eventos (EAP).</span><span class="sxs-lookup"><span data-stu-id="e2b82-218">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="e2b82-219">Implementar el modelo asincrónico basado en tareas</span><span class="sxs-lookup"><span data-stu-id="e2b82-219">Implementing the Task-based Asynchronous Pattern</span></span>](implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="e2b82-220">Describe cómo implementar el patrón asincrónico basado en tareas (TAP) de tres maneras: mediante los compiladores de C# y Visual Basic de Visual Studio, manualmente o a través de una combinación del compilador y de métodos manuales.</span><span class="sxs-lookup"><span data-stu-id="e2b82-220">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="e2b82-221">Modelo asincrónico basado en tareas (TAP)</span><span class="sxs-lookup"><span data-stu-id="e2b82-221">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="e2b82-222">Describe cómo se pueden utilizar las tareas y las devoluciones de llamada para conseguir esperas sin bloqueos.</span><span class="sxs-lookup"><span data-stu-id="e2b82-222">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="e2b82-223">Interoperabilidad con otros tipos y patrones asincrónicos</span><span class="sxs-lookup"><span data-stu-id="e2b82-223">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="e2b82-224">Describe cómo usar el patrón asincrónico basado en tareas (TAP) para implementar el modelo de programación asincrónica (APM) y el patrón asincrónico basado en eventos (EAP).</span><span class="sxs-lookup"><span data-stu-id="e2b82-224">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
