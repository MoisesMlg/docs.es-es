---
title: Async en profundidad
description: Obtenga información sobre cómo es sencillo escribir código asincrónico enlazado a E/S y CPU al usar el modelo asincrónico basado en tareas de .NET.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 7fcc41c4ea5037d643402fc722e8f16f28d560ee
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94823334"
---
# <a name="async-in-depth"></a><span data-ttu-id="b05ed-103">Async en profundidad</span><span class="sxs-lookup"><span data-stu-id="b05ed-103">Async in depth</span></span>

<span data-ttu-id="b05ed-104">La escritura de código asincrónico enlazado a E/S y CPU es sencilla al usar el modelo asincrónico basado en tareas de .NET.</span><span class="sxs-lookup"><span data-stu-id="b05ed-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="b05ed-105">El modelo se expone mediante los tipos `Task` y `Task<T>` y las palabras claves `async` y `await` en C# y Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b05ed-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="b05ed-106">(Los recursos específicos del idioma se encuentran en la sección [Vea también](#see-also)). En este artículo, se explica cómo usar Async de .NET y se proporciona información sobre el marco de trabajo de Async usado en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="b05ed-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="b05ed-107">Task y Task\<T></span><span class="sxs-lookup"><span data-stu-id="b05ed-107">Task and Task\<T></span></span>

<span data-ttu-id="b05ed-108">Las tareas son construcciones que se usan para implementar lo que se conoce como el [modelo de promesa de simultaneidad](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="b05ed-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="b05ed-109">En resumen, le ofrecen una "promesa" de que el trabajo se completará en un momento posterior, lo que le permite coordinarse con la promesa con una API limpia.</span><span class="sxs-lookup"><span data-stu-id="b05ed-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

- <span data-ttu-id="b05ed-110">`Task` representa una única operación que no devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="b05ed-110">`Task` represents a single operation which does not return a value.</span></span>
- <span data-ttu-id="b05ed-111">`Task<T>` representa una única operación que devuelve un valor de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="b05ed-112">Es importante razonar sobre las tareas como abstracciones de trabajo que se producen de forma asincrónica y *no* una abstracción sobre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="b05ed-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="b05ed-113">De manera predeterminada, las tareas se ejecutan en el trabajo de subproceso y delegado actual del sistema operativo, según corresponda.</span><span class="sxs-lookup"><span data-stu-id="b05ed-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="b05ed-114">De forma opcional, se puede solicitar de forma explícita que se ejecuten las tareas en un subproceso independiente mediante la API `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="b05ed-115">Las tareas exponen un protocolo de API para supervisar, esperar y acceder al valor del resultado (en el caso de `Task<T>`) de una tarea.</span><span class="sxs-lookup"><span data-stu-id="b05ed-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="b05ed-116">La integración de lenguajes, con la palabra clave `await`, proporciona una abstracción de alto nivel para usar tareas.</span><span class="sxs-lookup"><span data-stu-id="b05ed-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="b05ed-117">Mediante `await`, su aplicación o servicio puede realizar trabajo útil mientras se ejecuta una tarea al ceder el control a su llamador hasta que se realiza la tarea.</span><span class="sxs-lookup"><span data-stu-id="b05ed-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="b05ed-118">El código no tiene que depender de las devoluciones de llamada ni eventos para seguir ejecutándose una vez completada la tarea.</span><span class="sxs-lookup"><span data-stu-id="b05ed-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="b05ed-119">La integración de la API de tareas y lenguajes se encarga de ello.</span><span class="sxs-lookup"><span data-stu-id="b05ed-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="b05ed-120">Si está usando `Task<T>`, la palabra clave `await` "desencapsulará" también el valor devuelto cuando se completa la tarea.</span><span class="sxs-lookup"><span data-stu-id="b05ed-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="b05ed-121">Más adelante se explican los detalles sobre cómo funciona esto.</span><span class="sxs-lookup"><span data-stu-id="b05ed-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="b05ed-122">Puede obtener más información sobre las tareas y las distintas formas de interactuar con ellas en el tema [Modelo asincrónico basado en tareas (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="b05ed-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="b05ed-123">Tareas para una operación enlazada a E/S en profundidad</span><span class="sxs-lookup"><span data-stu-id="b05ed-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="b05ed-124">En la siguiente sección, se describe una vista general de lo que sucede con una llamada de E/S asincrónica normal.</span><span class="sxs-lookup"><span data-stu-id="b05ed-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="b05ed-125">Comencemos con un par de ejemplos.</span><span class="sxs-lookup"><span data-stu-id="b05ed-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="b05ed-126">En el primer ejemplo, se llama a un método asincrónico y se devuelve una tarea activa que, probablemente, aún esté sin completar.</span><span class="sxs-lookup"><span data-stu-id="b05ed-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="b05ed-127">En el segundo ejemplo, se agrega el uso de las palabras clave `async` y `await` para que funcionen en la tarea.</span><span class="sxs-lookup"><span data-stu-id="b05ed-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="b05ed-128">La llamada a `GetStringAsync()` se realiza a través de bibliotecas de .NET de nivel inferior (es posible que se llame a otros métodos asincrónicos) hasta que se alcanza una llamada de interoperabilidad de P/Invoke en una biblioteca de red nativa.</span><span class="sxs-lookup"><span data-stu-id="b05ed-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="b05ed-129">La biblioteca nativa puede realizar posteriormente una llamada API del sistema (como `write()` a un socket en Linux).</span><span class="sxs-lookup"><span data-stu-id="b05ed-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="b05ed-130">Se creará un objeto de tarea en el límite nativo o administrado, posiblemente mediante [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="b05ed-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="b05ed-131">El objeto de tarea se pasará por las capas, funcionará en ellas o se devolverá directamente y, finalmente, se devuelve al llamador inicial.</span><span class="sxs-lookup"><span data-stu-id="b05ed-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="b05ed-132">En este segundo ejemplo, se devolverá un objeto `Task<T>` de `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="b05ed-133">El uso de la palabra clave `await` hace que el método devuelva un objeto de tarea recién creado.</span><span class="sxs-lookup"><span data-stu-id="b05ed-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="b05ed-134">El control vuelve al llamador de esta ubicación en el método `GetFirstCharactersCountAsync`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="b05ed-135">Los métodos y propiedades del objeto [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) permiten que los llamadores supervisen el progreso de la tarea, que se completará cuando se haya ejecutado el código restante en GetFirstCharactersCountAsync.</span><span class="sxs-lookup"><span data-stu-id="b05ed-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="b05ed-136">Después de la llamada API del sistema, la solicitud ahora está en el espacio del kernel, que avanza hacia el subsistema de red del sistema operativo (como `/net` en Linux Kernel).</span><span class="sxs-lookup"><span data-stu-id="b05ed-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="b05ed-137">Aquí, el sistema operativo controlará la solicitud de red *de forma asincrónica*.</span><span class="sxs-lookup"><span data-stu-id="b05ed-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="b05ed-138">Los detalles pueden ser diferentes según el sistema operativo usado (la llamada al controlador de dispositivo puede programarse como una señal devuelta al tiempo de ejecución o una llamada al controlador de dispositivo puede realizarse y *después* se devuelve una señal), pero, finalmente, el tiempo de ejecución recibirá la información de que la solicitud de red está en curso.</span><span class="sxs-lookup"><span data-stu-id="b05ed-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="b05ed-139">En este momento, el trabajo del controlador de dispositivo estará programado, en curso o ya estará terminado (la solicitud ya estará "en la conexión"), pero como esto se produce de forma asincrónica, el controlador de dispositivo es capaz de controlar otra cosa de forma inmediata.</span><span class="sxs-lookup"><span data-stu-id="b05ed-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="b05ed-140">Por ejemplo, en Windows, un subproceso de sistema operativo realiza una llamada al controlador de dispositivo de red y le pide que realice la operación de red a través de un paquete de petición de interrupción (IRP) que representa la operación.</span><span class="sxs-lookup"><span data-stu-id="b05ed-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="b05ed-141">El controlador de dispositivo recibe el IRP, realiza la llamada a la red, marca el IRP como "pendiente" y vuelve al sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="b05ed-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="b05ed-142">Ya que el subproceso de sistema operativo ahora sabe que el IRP está "pendiente", no tiene nada más que hacer en este trabajo y "vuelve", de modo que se puede usar para realizar otro trabajo.</span><span class="sxs-lookup"><span data-stu-id="b05ed-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="b05ed-143">Cuando se haya realizado la solicitud y regresen los datos a través del controlador de dispositivo, notifica a la CPU que se han recibido nuevos datos mediante una interrupción.</span><span class="sxs-lookup"><span data-stu-id="b05ed-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="b05ed-144">La forma en que se controla esta interrupción varía según el sistema operativo, pero, finalmente, los datos pasarán a través del sistema operativo hasta que lleguen a una llamada de interoperabilidad del sistema (por ejemplo, en Linux un controlador de interrupciones programará la mitad inferior de la IRQ para pasar los datos a través del sistema operativo de forma asincrónica).</span><span class="sxs-lookup"><span data-stu-id="b05ed-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="b05ed-145">Tenga en cuenta que esto *también* se produce de manera asincrónica.</span><span class="sxs-lookup"><span data-stu-id="b05ed-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="b05ed-146">El resultado se pone en cola hasta que el siguiente subproceso disponible puede ejecutar el método asincrónico y "desencapsular" el resultado de la tarea completada.</span><span class="sxs-lookup"><span data-stu-id="b05ed-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="b05ed-147">A lo largo de todo este proceso, un punto clave es que **ningún subproceso se dedica a ejecutar la tarea**.</span><span class="sxs-lookup"><span data-stu-id="b05ed-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="b05ed-148">Aunque el trabajo se ejecuta en algún contexto (es decir, el sistema operativo tiene que pasar datos a un controlador de dispositivo y responder a una interrupción), no hay ningún subproceso dedicado a *esperar* a que vuelvan los datos de la solicitud.</span><span class="sxs-lookup"><span data-stu-id="b05ed-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="b05ed-149">Esto permite al sistema controlar un volumen de trabajo mucho mayor en lugar de esperar a que finalicen algunas llamadas de E/S.</span><span class="sxs-lookup"><span data-stu-id="b05ed-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="b05ed-150">Aunque lo anterior puede parecer mucho trabajo que realizar, al medirlo en términos de tiempo de reloj, es ínfimo en comparación con el tiempo necesario para realizar el trabajo de E/S real.</span><span class="sxs-lookup"><span data-stu-id="b05ed-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="b05ed-151">Aunque no es exacta, una escala de tiempo posible para una llamada de este estilo tendría este aspecto:</span><span class="sxs-lookup"><span data-stu-id="b05ed-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="b05ed-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="b05ed-152">0-1————————————————————————————————————————————————–2-3</span></span>

- <span data-ttu-id="b05ed-153">El tiempo empleado de los puntos `0` a `1` es todo hasta que un método asincrónico cede el control a su llamador.</span><span class="sxs-lookup"><span data-stu-id="b05ed-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
- <span data-ttu-id="b05ed-154">El tiempo empleado de los puntos `1` a `2` es el tiempo transcurrido en E/S, sin ningún costo de CPU.</span><span class="sxs-lookup"><span data-stu-id="b05ed-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
- <span data-ttu-id="b05ed-155">Por último, el tiempo empleado de los puntos `2` a `3` es durante el que se pasa el control (y posiblemente un valor) de nuevo al método asincrónico, momento en que se vuelve a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="b05ed-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="b05ed-156">¿Qué significa esto en un escenario de servidor?</span><span class="sxs-lookup"><span data-stu-id="b05ed-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="b05ed-157">Este modelo funciona bien con una carga de trabajo de escenario de servidor típica.</span><span class="sxs-lookup"><span data-stu-id="b05ed-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="b05ed-158">Ya que no hay ningún subproceso dedicado al bloqueo de tareas incompletas, el grupo de subprocesos de servidor puede atender a un mayor volumen de solicitudes web.</span><span class="sxs-lookup"><span data-stu-id="b05ed-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="b05ed-159">Considere dos servidores: uno que ejecute código asincrónico y otro que no lo haga.</span><span class="sxs-lookup"><span data-stu-id="b05ed-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="b05ed-160">Para este ejemplo, cada servidor tiene solo 5 subprocesos disponibles para las solicitudes de servicio.</span><span class="sxs-lookup"><span data-stu-id="b05ed-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="b05ed-161">Tenga en cuenta que estos números son pequeños y sirven solo en un contexto demostrativo.</span><span class="sxs-lookup"><span data-stu-id="b05ed-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="b05ed-162">Suponga que ambos servidores reciben seis solicitudes simultáneas.</span><span class="sxs-lookup"><span data-stu-id="b05ed-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="b05ed-163">Cada solicitud realiza una operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="b05ed-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="b05ed-164">El servidor *sin* código asincrónico tiene que poner en cola la solicitud 6 hasta que uno de los 5 subprocesos haya finalizado el trabajo enlazado a E/S y escrito una respuesta.</span><span class="sxs-lookup"><span data-stu-id="b05ed-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="b05ed-165">En el momento en que entre la solicitud 20, el servidor puede comenzar a ralentizarse, porque la cola se extiende demasiado.</span><span class="sxs-lookup"><span data-stu-id="b05ed-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="b05ed-166">El servidor *con* código asincrónico en ejecución también pone en cola la solicitud 6, pero ya que usa `async` y `await`, cada uno de los subprocesos se libera cuando se inicia el trabajo enlazado a E/S, en lugar de cuando finaliza.</span><span class="sxs-lookup"><span data-stu-id="b05ed-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="b05ed-167">Cuando llega la solicitud 20, la cola de solicitudes entrantes será mucho más pequeña (en caso de que haya algo) y no se ralentiza el servidor.</span><span class="sxs-lookup"><span data-stu-id="b05ed-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="b05ed-168">Aunque se trata de un ejemplo inventado, ocurre de forma muy similar en el mundo real.</span><span class="sxs-lookup"><span data-stu-id="b05ed-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="b05ed-169">De hecho, puede esperar que un servidor pueda controlar más solicitudes mediante `async` y `await` que si se dedicaba a un subproceso para cada solicitud que recibe.</span><span class="sxs-lookup"><span data-stu-id="b05ed-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="b05ed-170">¿Qué significa esto en un escenario de cliente?</span><span class="sxs-lookup"><span data-stu-id="b05ed-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="b05ed-171">El mayor beneficio al usar `async` y `await` para una aplicación cliente es un aumento en la capacidad de respuesta.</span><span class="sxs-lookup"><span data-stu-id="b05ed-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="b05ed-172">Aunque puede crear una aplicación dinámica al generar subprocesos de forma manual, el hecho de generar un subproceso es una operación costosa en comparación a usar solo `async` y `await`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="b05ed-173">Especialmente en el caso de juegos para móviles, es fundamental afectar lo mínimo posible al subproceso de interfaz de usuario en lo que a E/S se refiere.</span><span class="sxs-lookup"><span data-stu-id="b05ed-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="b05ed-174">Sobre todo, ya que el trabajo enlazado a E/S no invierte prácticamente ningún tiempo en la CPU, dedicar un subproceso de CPU completo a realizar prácticamente ningún trabajo útil sería un mal uso de recursos.</span><span class="sxs-lookup"><span data-stu-id="b05ed-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="b05ed-175">Además, es muy sencillo enviar trabajo al subproceso de interfaz de usuario (como actualizar una interfaz de usuario) con métodos `async` y no requiere trabajo adicional (como llamar a un delegado seguro para subprocesos).</span><span class="sxs-lookup"><span data-stu-id="b05ed-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="b05ed-176">Task y Task\<T> para una operación enlazada a la CPU en profundidad</span><span class="sxs-lookup"><span data-stu-id="b05ed-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="b05ed-177">El código `async` enlazado a la CPU es un poco diferente del código `async` enlazado a E/S.</span><span class="sxs-lookup"><span data-stu-id="b05ed-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="b05ed-178">Ya que el trabajo se realiza en la CPU, no hay ninguna forma de evitar dedicar un subproceso al cálculo.</span><span class="sxs-lookup"><span data-stu-id="b05ed-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="b05ed-179">El uso de `async` y `await` le proporciona una manera clara de interactuar con subprocesos en segundo plano y mantener al llamador del método asincrónico dinámico.</span><span class="sxs-lookup"><span data-stu-id="b05ed-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="b05ed-180">Tenga en cuenta que esto no proporciona ninguna protección para datos compartidos.</span><span class="sxs-lookup"><span data-stu-id="b05ed-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="b05ed-181">Si usa datos compartidos, aún tendrá que aplicar una estrategia de sincronización adecuada.</span><span class="sxs-lookup"><span data-stu-id="b05ed-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="b05ed-182">Esta es una vista general de una llamada asincrónica enlazada a la CPU:</span><span class="sxs-lookup"><span data-stu-id="b05ed-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="b05ed-183">`CalculateResult()` se ejecuta en el subproceso en que se ha llamado.</span><span class="sxs-lookup"><span data-stu-id="b05ed-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="b05ed-184">Cuando llama a `Task.Run`, pone en cola la operación costosa enlazada a la CPU, `DoExpensiveCalculation()`, en el grupo de subprocesos y recibe un controlador `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="b05ed-185">`DoExpensiveCalculation()` se ejecuta finalmente de forma simultánea en el siguiente subproceso disponible, probablemente en otro núcleo de CPU.</span><span class="sxs-lookup"><span data-stu-id="b05ed-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="b05ed-186">Es posible realizar trabajo simultáneo mientras `DoExpensiveCalculation()` está ocupado en otro subproceso, ya que el subproceso que llama a `CalculateResult()` aún se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="b05ed-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="b05ed-187">Una vez se encuentra `await`, la ejecución de `CalculateResult()` se cede a su llamador, lo que permite que se realice otro trabajo con el subproceso actual mientras `DoExpensiveCalculation()` genera un resultado.</span><span class="sxs-lookup"><span data-stu-id="b05ed-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="b05ed-188">Una vez que haya finalizado, el resultado se pone en la cola para ejecutarse en el subproceso principal.</span><span class="sxs-lookup"><span data-stu-id="b05ed-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="b05ed-189">Finalmente, el subproceso principal volverá a ejecutar `CalculateResult()`, momento en que tendrá el resultado de `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="b05ed-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="b05ed-190">¿Por qué ayuda Async en este caso?</span><span class="sxs-lookup"><span data-stu-id="b05ed-190">Why does async help here?</span></span>

<span data-ttu-id="b05ed-191">`async` y `await` son el procedimiento recomendado para administrar el trabajo enlazado a la CPU si necesita capacidad de respuesta.</span><span class="sxs-lookup"><span data-stu-id="b05ed-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="b05ed-192">Hay varios patrones para usar Async con trabajo enlazado a la CPU.</span><span class="sxs-lookup"><span data-stu-id="b05ed-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="b05ed-193">Es importante tener en cuenta que hay un pequeño costo al usar Async y no se recomienda para bucles de pequeñas dimensiones.</span><span class="sxs-lookup"><span data-stu-id="b05ed-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="b05ed-194">Depende de usted determinar cómo escribe el código en torno a esta nueva funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="b05ed-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="b05ed-195">Vea también</span><span class="sxs-lookup"><span data-stu-id="b05ed-195">See also</span></span>

- [<span data-ttu-id="b05ed-196">Programación asincrónica en C#</span><span class="sxs-lookup"><span data-stu-id="b05ed-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="b05ed-197">Programación asincrónica con async y await (C#)</span><span class="sxs-lookup"><span data-stu-id="b05ed-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="b05ed-198">Programación asincrónica en F#</span><span class="sxs-lookup"><span data-stu-id="b05ed-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="b05ed-199">Programación asincrónica con Async y Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b05ed-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
