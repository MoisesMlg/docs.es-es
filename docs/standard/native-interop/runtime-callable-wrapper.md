---
title: Contenedor al que se puede llamar en tiempo de ejecución
description: CLR expone objetos COM mediante un contenedor RCW, que administra las llamadas entre un cliente .NET y un objeto COM.
ms.date: 03/30/2017
helpviewer_keywords:
- COM interop, COM wrappers
- RCW
- COM wrappers
- runtime callable wrappers
- interoperation with unmanaged code, COM wrappers
ms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4
ms.openlocfilehash: 985f6e5057a06ac9dcadc0e2c1e4d7743d96f035
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/24/2020
ms.locfileid: "95730232"
---
# <a name="runtime-callable-wrapper"></a><span data-ttu-id="be808-103">Contenedor al que se puede llamar en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="be808-103">Runtime Callable Wrapper</span></span>

<span data-ttu-id="be808-104">Common Language Runtime expone objetos COM mediante un proxy denominado el contenedor RCW (Runtime Callable Wrapper).</span><span class="sxs-lookup"><span data-stu-id="be808-104">The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).</span></span> <span data-ttu-id="be808-105">Aunque el contenedor RCW aparece como un objeto corriente para los clientes .NET, su función principal es calcular referencias de llamadas entre un cliente .NET y un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="be808-105">Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.</span></span>  
  
 <span data-ttu-id="be808-106">CLR crea exactamente un contenedor RCW para cada objeto COM, independientemente del número de referencias que existan en ese objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-106">The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.</span></span> <span data-ttu-id="be808-107">CLR mantiene un único contenedor RCW por proceso para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-107">The runtime maintains a single RCW per process for each object.</span></span>  <span data-ttu-id="be808-108">Si crea un contenedor RCW en un dominio de aplicación o apartamento y después pasa una referencia a otro dominio de aplicación o apartamento, se usará un proxy para el primer objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-108">If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.</span></span>  <span data-ttu-id="be808-109">Como se muestra en la siguiente ilustración, cualquier número de clientes administrados puede contener una referencia a los objetos COM que exponen las interfaces INew e INewer.</span><span class="sxs-lookup"><span data-stu-id="be808-109">As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.</span></span>  

<span data-ttu-id="be808-110">En la imagen siguiente se muestra el proceso para obtener acceso a objetos COM a través del contenedor RCW:</span><span class="sxs-lookup"><span data-stu-id="be808-110">The following image shows the process for accessing COM objects through the runtime callable wrapper:</span></span>

 ![Proceso para obtener acceso a objetos COM a través del contenedor RCW.](./media/runtime-callable-wrapper/runtime-callable-wrapper.gif)  

 <span data-ttu-id="be808-112">Usando los metadatos derivados de una biblioteca de tipos, CLR crea el objeto COM al que se está llamando y un contenedor para dicho objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-112">Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.</span></span> <span data-ttu-id="be808-113">Cada contenedor RCW mantiene una memoria caché de punteros de interfaz en el objeto COM que contiene y libera su referencia en el objeto COM cuando el contenedor RCW ya no es necesario.</span><span class="sxs-lookup"><span data-stu-id="be808-113">Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.</span></span> <span data-ttu-id="be808-114">CLR realiza la recolección de elementos no utilizados en el contenedor RCW.</span><span class="sxs-lookup"><span data-stu-id="be808-114">The runtime performs garbage collection on the RCW.</span></span>  
  
 <span data-ttu-id="be808-115">Entre otras actividades, el contenedor RCW calcula referencias de datos entre el código administrado y no administrado, en nombre del objeto encapsulado.</span><span class="sxs-lookup"><span data-stu-id="be808-115">Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.</span></span> <span data-ttu-id="be808-116">El contenedor RCW proporciona específicamente serialización para argumentos de métodos y valores devueltos de métodos cada vez que el cliente y el servidor tienen representaciones diferentes de los datos que se pasan entre ellos.</span><span class="sxs-lookup"><span data-stu-id="be808-116">Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.</span></span>  
  
 <span data-ttu-id="be808-117">El contenedor estándar impone las reglas de cálculo de referencias integradas.</span><span class="sxs-lookup"><span data-stu-id="be808-117">The standard wrapper enforces built-in marshaling rules.</span></span> <span data-ttu-id="be808-118">Por ejemplo, cuando un cliente .NET pasa un tipo String como parte de un argumento a un objeto no administrado, el contenedor convierte la cadena en un tipo BSTR.</span><span class="sxs-lookup"><span data-stu-id="be808-118">For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.</span></span> <span data-ttu-id="be808-119">Si el objeto COM devuelve una cadena BSTR a su llamador administrado, el llamador recibe una cadena.</span><span class="sxs-lookup"><span data-stu-id="be808-119">Should the COM object return a BSTR to its managed caller, the caller receives a String.</span></span> <span data-ttu-id="be808-120">Tanto el cliente como el servidor envían y reciben datos que les resultan familiares.</span><span class="sxs-lookup"><span data-stu-id="be808-120">Both the client and the server send and receive data that is familiar to them.</span></span> <span data-ttu-id="be808-121">Otros tipos no requieren conversión.</span><span class="sxs-lookup"><span data-stu-id="be808-121">Other types require no conversion.</span></span> <span data-ttu-id="be808-122">Por ejemplo, un contenedor estándar pasará siempre un entero de 4 bytes entre el código administrado y no administrado sin convertir el tipo.</span><span class="sxs-lookup"><span data-stu-id="be808-122">For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.</span></span>  
  
## <a name="marshaling-selected-interfaces"></a><span data-ttu-id="be808-123">Serialización de interfaces seleccionadas</span><span class="sxs-lookup"><span data-stu-id="be808-123">Marshaling selected interfaces</span></span>  

 <span data-ttu-id="be808-124">El objetivo principal del [contenedor RCW](runtime-callable-wrapper.md) es ocultar las diferencias entre los modelos de programación administrada y no administrada.</span><span class="sxs-lookup"><span data-stu-id="be808-124">The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models.</span></span> <span data-ttu-id="be808-125">Para crear una transición fluida, el contenedor RCW consume interfaces COM seleccionadas sin exponerlas al cliente .NET, tal y como se muestra en la siguiente ilustración.</span><span class="sxs-lookup"><span data-stu-id="be808-125">To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.</span></span>

 <span data-ttu-id="be808-126">En la imagen siguiente se muestran las interfaces COM y el contenedor RCW:</span><span class="sxs-lookup"><span data-stu-id="be808-126">The following image shows COM interfaces and the runtime callable wrapper:</span></span>
  
 ![Captura de pantalla del contenedor RCW con interfaces.](./media/runtime-callable-wrapper/runtime-callable-wrapper-interfaces.gif)  
  
 <span data-ttu-id="be808-128">Cuando se crea como un objeto de enlace en tiempo de compilación, el contenedor RCW es un tipo específico.</span><span class="sxs-lookup"><span data-stu-id="be808-128">When created as an early-bound object, the RCW is a specific type.</span></span> <span data-ttu-id="be808-129">Implementa las interfaces que el objeto COM implementa, y expone los métodos, las propiedades y los eventos de las interfaces del objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-129">It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.</span></span> <span data-ttu-id="be808-130">En la ilustración, el contenedor RCW expone la interfaz INew pero consume las interfaces **IUnknown** e **IDispatch**.</span><span class="sxs-lookup"><span data-stu-id="be808-130">In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces.</span></span> <span data-ttu-id="be808-131">Además, el contenedor RCW expone todos los miembros de la interfaz INew al cliente .NET.</span><span class="sxs-lookup"><span data-stu-id="be808-131">Further, the RCW exposes all members of the INew interface to the .NET client.</span></span>  
  
 <span data-ttu-id="be808-132">El contenedor RCW consume las interfaces enumeradas en la siguiente tabla, expuestas por el objeto que encapsula.</span><span class="sxs-lookup"><span data-stu-id="be808-132">The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="be808-133">Interfaz</span><span class="sxs-lookup"><span data-stu-id="be808-133">Interface</span></span>|<span data-ttu-id="be808-134">Descripción</span><span class="sxs-lookup"><span data-stu-id="be808-134">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="be808-135">**IDispatch**</span><span class="sxs-lookup"><span data-stu-id="be808-135">**IDispatch**</span></span>|<span data-ttu-id="be808-136">Para el enlace en tiempo de ejecución a objetos COM mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="be808-136">For late binding to COM objects through reflection.</span></span>|  
|<span data-ttu-id="be808-137">**IErrorInfo**</span><span class="sxs-lookup"><span data-stu-id="be808-137">**IErrorInfo**</span></span>|<span data-ttu-id="be808-138">Proporciona una descripción textual del error, su origen, un archivo de ayuda, contexto de ayuda y el GUID de la interfaz que definió el error (siempre **GUID_NULL** para las clases. NET).</span><span class="sxs-lookup"><span data-stu-id="be808-138">Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).</span></span>|  
|<span data-ttu-id="be808-139">**IProvideClassInfo**</span><span class="sxs-lookup"><span data-stu-id="be808-139">**IProvideClassInfo**</span></span>|<span data-ttu-id="be808-140">Si el objeto COM que se está encapsulando implementa **IProvideClassInfo**, el contenedor RCW extrae la información de tipos de esta interfaz para proporcionar una mejor identidad de tipos.</span><span class="sxs-lookup"><span data-stu-id="be808-140">If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.</span></span>|  
|<span data-ttu-id="be808-141">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="be808-141">**IUnknown**</span></span>|<span data-ttu-id="be808-142">Para la identidad de objetos, la conversión de tipos y la administración de la duración:</span><span class="sxs-lookup"><span data-stu-id="be808-142">For object identity, type coercion, and lifetime management:</span></span><br /><br /> <span data-ttu-id="be808-143">-   Identidad de objetos</span><span class="sxs-lookup"><span data-stu-id="be808-143">-   Object identity</span></span><br />     <span data-ttu-id="be808-144">El tiempo de ejecución distingue los objetos COM comparando el valor de la interfaz **IUnknown** de cada objeto.</span><span class="sxs-lookup"><span data-stu-id="be808-144">The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.</span></span><br /><span data-ttu-id="be808-145">-   Coerción de tipos</span><span class="sxs-lookup"><span data-stu-id="be808-145">-   Type coercion</span></span><br />     <span data-ttu-id="be808-146">El contenedor RCW reconoce la detección dinámica de tipos que realiza el método **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="be808-146">The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.</span></span><br /><span data-ttu-id="be808-147">-   Administración de la duración</span><span class="sxs-lookup"><span data-stu-id="be808-147">-   Lifetime management</span></span><br />     <span data-ttu-id="be808-148">Con el método **QueryInterface**, el contenedor RCW obtiene y mantiene una referencia a un objeto no administrado hasta que CLR realiza la recolección de elementos no utilizados en el contenedor, lo que libera el objeto no administrado.</span><span class="sxs-lookup"><span data-stu-id="be808-148">Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.</span></span>|  
  
 <span data-ttu-id="be808-149">Opcionalmente, el contenedor RCW consume las interfaces enumeradas en la siguiente tabla, expuestas por el objeto que encapsula.</span><span class="sxs-lookup"><span data-stu-id="be808-149">The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="be808-150">Interfaz</span><span class="sxs-lookup"><span data-stu-id="be808-150">Interface</span></span>|<span data-ttu-id="be808-151">Descripción</span><span class="sxs-lookup"><span data-stu-id="be808-151">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="be808-152">**IConnectionPoint** e **IConnectionPointContainer**</span><span class="sxs-lookup"><span data-stu-id="be808-152">**IConnectionPoint** and **IConnectionPointContainer**</span></span>|<span data-ttu-id="be808-153">El contenedor RCW convierte los objetos que exponen el estilo de evento de punto de conexión en eventos basados en delegado.</span><span class="sxs-lookup"><span data-stu-id="be808-153">The RCW converts objects that expose the connection-point event style to delegate-based events.</span></span>|  
|<span data-ttu-id="be808-154">**IDispatchEx** (solo .NET Framework)</span><span class="sxs-lookup"><span data-stu-id="be808-154">**IDispatchEx** (.NET Framework Only)</span></span> |<span data-ttu-id="be808-155">Si la clase implementa **IDispatchEx**, el contenedor RCW implementa **IExpando**.</span><span class="sxs-lookup"><span data-stu-id="be808-155">If the class implements **IDispatchEx**, the RCW implements **IExpando**.</span></span> <span data-ttu-id="be808-156">La interfaz **IDispatchEx** es una extensión de la interfaz **IDispatch** que, a diferencia de **IDispatch**, permite enumerar, agregar, eliminar y llamar a miembros con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="be808-156">The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.</span></span>|  
|<span data-ttu-id="be808-157">**IEnumVARIANT**</span><span class="sxs-lookup"><span data-stu-id="be808-157">**IEnumVARIANT**</span></span>|<span data-ttu-id="be808-158">Permite tratar como colecciones a los tipos COM que admiten enumeraciones.</span><span class="sxs-lookup"><span data-stu-id="be808-158">Enables COM types that support enumerations to be treated as collections.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="be808-159">Vea también</span><span class="sxs-lookup"><span data-stu-id="be808-159">See also</span></span>

- [<span data-ttu-id="be808-160">Contenedores COM</span><span class="sxs-lookup"><span data-stu-id="be808-160">COM Wrappers</span></span>](com-wrappers.md)
- [<span data-ttu-id="be808-161">Contenedor CCW (COM callable wrapper)</span><span class="sxs-lookup"><span data-stu-id="be808-161">COM Callable Wrapper</span></span>](com-callable-wrapper.md)
- <span data-ttu-id="be808-162">[Resumen de la conversión de bibliotecas de tipos en ensamblados](/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="be808-162">[Type Library to Assembly Conversion Summary](/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</span></span>
- [<span data-ttu-id="be808-163">Importar una biblioteca de tipos como un ensamblado</span><span class="sxs-lookup"><span data-stu-id="be808-163">Importing a Type Library as an Assembly</span></span>](../../framework/interop/importing-a-type-library-as-an-assembly.md)
