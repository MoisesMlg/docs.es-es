---
title: Flujo de datos (biblioteca TPL)
description: Aprenda a usar componentes de flujo de datos en la biblioteca TPL para mejorar la solidez de aplicaciones habilitadas para simultaneidad.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 8c6eeab852f30535d721aa44b3c60e4b6febe0fc
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94817645"
---
# <a name="dataflow-task-parallel-library"></a>Flujo de datos (biblioteca TPL)
La biblioteca TPL (Task Parallel Library, biblioteca de procesamiento paralelo basado en tareas) proporciona componentes de flujo de datos que ayudan a aumentar la solidez de aplicaciones habilitadas para simultaneidad. Se conoce colectivamente a estos componentes de flujo de datos como *biblioteca TDF (biblioteca de TPL Dataflow)* pero nos referiremos descriptivamente a ella como "biblioteca de flujos de datos TPL". Este modelo de flujo de datos promueve una programación basada en actores mediante el paso de mensajes en proceso para tareas de canalización y de flujo de datos de grano grueso. Los componentes de flujo de datos se basan en los tipos y la infraestructura de programación de la biblioteca TPL y se integran con la compatibilidad de los lenguajes C#, Visual Basic y F# para proporcionar programación asincrónica. Estos componentes de flujo de datos son útiles cuando se tienen varias operaciones que deben comunicarse entre sí de forma asincrónica, o cuando se desea procesar datos a medida que estén disponibles. Por ejemplo, piense en una aplicación que procesa datos de imagen de una cámara web. Con el modelo de flujo de datos, la aplicación puede procesar fotogramas de imagen a medida que estén disponibles. Si la aplicación mejora fotogramas de imagen, por ejemplo, corrigiendo la luz o reduciendo ojos rojos, puede crear una *canalización* de los componentes de flujo de datos. Cada fase de la canalización puede utilizar más funcionalidad de paralelismo de grano grueso, como la funcionalidad proporcionada por la biblioteca TPL, para transformar la imagen.  
  
 En este documento se proporciona información general sobre la biblioteca de flujos de datos TPL. Se describe el modelo de programación, los tipos de bloques de flujo de datos predefinidos y cómo configurar bloques de flujo de datos para satisfacer las necesidades específicas de las aplicaciones.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Modelo de programación
 La biblioteca de flujos de datos TPL proporciona una base para el paso de mensajes y para paralelizar aplicaciones que consumen mucha CPU, así como aplicaciones intensivas de entrada y salida con alto rendimiento y latencia baja. También ofrece el control explícito sobre cómo almacenar los datos en búfer y desplazarlos alrededor del sistema. Para entender mejor el modelo de programación de flujo de datos, piense en una aplicación que de forma asincrónica carga imágenes desde el disco y crea un compuesto de esas imágenes. Los modelos de programación tradicionales suelen usar devoluciones de llamada y objetos de sincronización, como bloqueos, para coordinar tareas y tener acceso a datos compartidos. Con el modelo de programación de flujo de datos, puede crear objetos de flujo de datos que procesan las imágenes como se leen desde el disco. Bajo el modelo de flujo de datos, se declara cómo se controlan los datos cuando están disponibles, así como las dependencias entre datos. Dado que el runtime administra las dependencias entre datos, se puede evitar a menudo la necesidad de sincronizar el acceso a los datos compartidos. Además, dado que el runtime programa el trabajo según la llegada asincrónica de datos, el flujo de datos puede mejorar la capacidad de respuesta y el nivel de rendimiento administrando de forma eficaz los subprocesos subyacentes. Para ver un ejemplo en donde se usa el modelo de programación de flujo de datos para implementar procesamiento de imágenes en una aplicación de Windows Forms, vea [Tutorial: Uso de flujos de datos en aplicaciones de Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Orígenes y destinos  
 La biblioteca de flujos de datos TPL consta de *bloques de flujo de datos*, que son estructuras de datos que almacenan datos en búfer y procesan datos. La biblioteca TPL define tres tipos de bloques de flujos de datos: *bloques de origen*, *bloques de destino* y *bloques propagadores*. Un bloque de origen actúa como un origen de datos y se puede leer desde él. Un bloque de destino actúa como un receptor de datos y se puede escribir en él. Un bloque propagador actúa como un bloque de origen y un bloque de destino, y se puede leer desde él y escribir en él. La biblioteca TPL define la interfaz <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> para representar orígenes, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> para representar destinos y <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> para representar propagadores. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> hereda de <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> y de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 La biblioteca de flujos de datos TPL proporciona varios tipos de bloques de flujo de datos predefinidos que implementan las interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> y <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Estos tipos de bloques de flujo de datos se describen en este documento en la sección [Tipos de bloques de flujo de datos predefinidos](#predefined-dataflow-block-types).  
  
### <a name="connecting-blocks"></a>Conectar bloques  
 Puede conectar los bloques de flujo de datos para establecer *canalizaciones*, que son secuencias lineales de bloques de flujo de datos, o *redes*, que son gráficos de bloques de flujo de datos. Una canalización es una forma de red. En una canalización o red, los orígenes propagan datos de forma asincrónica en destinos a medida que esos datos están disponibles. El método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> vincula un bloque de flujo de datos de origen a un bloque de destino. Un origen puede vincularse a cero o más destinos; los destinos se pueden vincular a partir de cero o más orígenes. Puede agregar o quitar bloques de flujo de datos hacia o desde una canalización o red simultáneamente. Los tipos de bloques de flujo de datos predefinidos controlan todos los aspectos de la seguridad para subprocesos de vinculación y desvinculación.  
  
 Para ver un ejemplo en donde se conectan bloques de flujo de datos para formar una canalización básica, vea [Tutorial: Creación de una canalización de flujos de datos](walkthrough-creating-a-dataflow-pipeline.md). Para ver un ejemplo en donde se conectan bloques de flujo de datos para formar una red más compleja, vea [Tutorial: Uso de flujos de datos en aplicaciones de Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md). Para obtener un ejemplo en donde un destino se desvincula de un origen después de que el origen le ofrezca un mensaje, vea [Procedimiento: Desvinculación de bloques de flujo de datos](how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrado  
 Cuando se llama al método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> para vincular un origen a un destino, puede proporcionar un delegado que determina si el bloque de destino acepta o rechaza un mensaje basado en el valor de ese mensaje. Este mecanismo de filtrado resulta útil para garantizar que un bloque de flujo de datos recibe solo ciertos valores. Para la mayoría de los tipos de bloques de flujo de datos predefinidos, si un bloque de origen está conectado a varios bloques de destino, cuando un bloque de destino rechaza un mensaje, el origen proporciona ese mensaje al destino siguiente. El orden en el que un origen proporciona mensajes a los destinos se define mediante el origen y puede variar según el tipo de origen. La mayoría de los tipos de bloques de origen dejan de proporcionar un mensaje después de que un destino acepta ese mensaje. Una excepción a esta regla es la clase <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, que proporciona cada mensaje a todos los destinos, aunque algunos destinos rechacen el mensaje. Para ver un ejemplo en donde se usa el filtrado para procesar únicamente determinados mensajes, consulte [Tutorial: Uso de flujos de datos en aplicaciones de Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Dado que cada tipo de bloque de flujo de datos de origen predefinido garantiza que los mensajes se propaguen en el orden en que se reciben, se debe leer cada mensaje desde el bloque de origen antes de que el bloque de origen pueda procesar el mensaje siguiente. Por consiguiente, si usa el filtrado para conectarse varios destinos a un origen, asegúrese de que al menos un bloque de destino recibe cada mensaje. De lo contrario, la aplicación podría generar un interbloqueo.  
  
### <a name="message-passing"></a>Paso de mensajes  
 El modelo de programación basado en el flujo de datos está relacionado con el concepto *paso de mensajes*, donde los componentes independientes de un programa comunican entre sí enviándose mensajes. Una manera de propagar mensajes entre los componentes de la aplicación es llamar a los métodos <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> y <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> para enviar mensajes a los bloques de flujo de datos de destino (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> actúa de forma sincrónica; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> actúa de forma asincrónica) y a los métodos <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> y <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> para recibir los mensajes desde los bloques de origen. Puede combinar estos métodos con las canalizaciones o redes de flujo de datos enviando datos de entrada al nodo principal (un bloque de destino) y recibiendo datos de salida del nodo terminal de la canalización o de los nodos terminales de la red (uno o varios bloques de origen). También puede utilizar el método <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> para leer desde el primero de los orígenes proporcionados siempre que tenga datos disponibles y realice acciones sobre esos datos.  
  
 Los bloques de origen proporcionan datos a los bloques de destino llamando al método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>. El bloque de destino responde a un mensaje proporcionado de una de estas tres maneras: puede aceptar el mensaje, rechazar el mensaje o posponer el mensaje. Cuando el destino acepta el mensaje, el método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Cuando el destino rechaza el mensaje, el método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Cuando el destino requiere que ya no recibe ningún mensaje del origen, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Los tipos de bloques de origen predefinidos no proporcionan mensajes a los destinos vinculados después de recibir este valor devuelto, y automáticamente se desvinculan de estos destinos.  
  
 Cuando un bloque de destino pospone el mensaje para su uso posterior, el método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Un bloque de destino que pospone un mensaje puede llamar posteriormente al método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> para tratar de reservar el mensaje proporcionado. En este punto, el mensaje todavía permanece disponible y lo puede usar el bloque de destino, o puede que otro destino haya tomado el mensaje. Cuando el bloque de destino requiere el mensaje posteriormente o cuando ya no necesita el mensaje, llama al método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>, respectivamente. La reserva de mensajes la utilizan normalmente los tipos de bloques de flujo de datos que trabajan en modo no expansivo. El modo no expansivo se explica más adelante en este documento. En lugar de reservar un mensaje pospuesto, un bloque de destino puede utilizar el método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> para intentar utilizar directamente el mensaje pospuesto.  
  
### <a name="dataflow-block-completion"></a>Finalización del bloque de flujo de datos  
 Los bloques de flujo de datos también admiten el concepto de *finalización*. Un bloque de flujo de datos que está en estado completado no realiza ningún trabajo posterior. Cada bloque de flujo de datos tiene un objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> asociado, conocido como *tarea de finalización*, que representa el estado de finalización del bloque. Dado que para finalizar se puede esperar un objeto <xref:System.Threading.Tasks.Task>, mediante tareas de finalización, para finalizar se pueden esperar uno o más nodos terminales de una red de flujo de datos. La interfaz <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> define el método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>, que informa al bloque de flujo de datos de una solicitud para que se complete, y la propiedad <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, que devuelve la tarea de finalización para el bloque de flujo de datos. Tanto <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> como <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> heredan de la interfaz <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Hay dos maneras de determinar si un bloque de flujo de datos se completó sin error, encontró uno o más errores, o se canceló. La primera manera consiste en llamar al método <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> en la tarea de finalización en un bloque `try`-`catch` (`Try`-`Catch` en Visual Basic). En el siguiente ejemplo se crea un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> que produce <xref:System.ArgumentOutOfRangeException> si su valor de entrada es menor que cero. <xref:System.AggregateException> se produce cuando este ejemplo llama a <xref:System.Threading.Tasks.Task.Wait%2A> en la tarea de finalización. Se obtiene acceso a <xref:System.ArgumentOutOfRangeException> mediante la propiedad <xref:System.AggregateException.InnerExceptions%2A> del objeto <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 En este ejemplo se muestra el caso en el que una excepción no está controlada en el delegado de un bloque de flujo de datos de ejecución. Se recomienda controlar las excepciones en los cuerpos de estos bloques. Sin embargo, si no puede hacerlo, el bloque se comporta como si estuviera cancelado y no procesa los mensajes entrantes.  
  
 Cuando un bloque de flujo de datos se cancela explícitamente, el objeto <xref:System.AggregateException> contiene <xref:System.OperationCanceledException> en la propiedad <xref:System.AggregateException.InnerExceptions%2A>. Para obtener más información sobre la cancelación del flujo de datos, vea la sección [Habilitar la cancelación](#enabling-cancellation).  
  
 La segunda manera de determinar el estado de finalización de un bloque de flujo de datos es usar una continuación de la tarea de finalización o utilizar las características de lenguaje asincrónicas de C# y Visual Basic para esperar a la tarea de finalización de forma asincrónica. El delegado que se proporciona al método <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> toma un objeto <xref:System.Threading.Tasks.Task> que representa la tarea anterior. En el caso de la propiedad <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, el delegado de continuación toma la propia tarea de finalización. El siguiente ejemplo se parece el anterior, con la salvedad de que también utiliza el método <xref:System.Threading.Tasks.Task.ContinueWith%2A> para crear una tarea de continuación que imprime el estado de la operación total de flujo de datos.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 También puede usar propiedades como <xref:System.Threading.Tasks.Task.IsCanceled%2A> en el cuerpo de la tarea de continuación para determinar información adicional sobre el estado de finalización de un bloque de flujo de datos. Para obtener más información sobre las tareas de continuación y cómo se relacionan con la cancelación y el control de errores, vea [Encadenar tareas mediante tareas de continuación](chaining-tasks-by-using-continuation-tasks.md), [Cancelación de tareas](task-cancellation.md) y [Control de excepciones](exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Tipos de bloques de flujo de datos predefinidos  
 La biblioteca de flujos de datos TPL proporciona varios tipos de bloques de flujo de datos predefinidos. Estos tipos se dividen en tres categorías: *bloques de almacenamiento en búfer*, *bloques de ejecución* y *bloques de agrupación*. En las secciones siguientes se describen los tipos de bloques que componen estas categorías.  
  
### <a name="buffering-blocks"></a>Bloques de almacenamiento en búfer  
 Los bloques de almacenamiento en búfer contiene datos para su uso por los consumidores de datos. La biblioteca de flujos de datos TPL proporciona tres tipos de bloques de almacenamiento en búfer: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 La clase <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> representa una estructura de mensajería asincrónica de uso general. Esta clase almacena una cola FIFO (primero en entrar, primero en salir) de mensajes donde varios orígenes pueden escribir o de los que varios destinos pueden leer. Cuando un destino recibe un mensaje de un objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, ese mensaje se quita de la cola de mensajes. Por tanto, aunque un objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> puede tener varios destinos, solo uno recibirá cada mensaje. La clase <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> resulta útil si desea pasar varios mensajes a otro componente, y ese componente debe recibir cada mensaje.  
  
 En el siguiente ejemplo básico se exponen varios valores <xref:System.Int32> a un objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> y después se leen esos valores desde ese objeto.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Para obtener un ejemplo completo en donde se muestra cómo escribir y leer mensajes desde un objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, vea [Procedimiento: Escritura y lectura de mensajes en un bloque de flujo de datos](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 La clase <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> resulta útil si debe pasar varios mensajes a otro componente, pero este componente solo necesita el valor más reciente. Esta clase también resulta útil si desea difundir un mensaje a varios componentes.  
  
 En el siguiente ejemplo básico se publica un valor <xref:System.Double> a un objeto <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> y después se lee ese valor desde el objeto varias veces. Dado que los valores no se quitan de los objetos <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> después de leerlos, el mismo valor está disponible cada vez.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Para obtener un ejemplo completo en donde se muestra cómo utilizar <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> para difundir un mensaje a varios bloques de destino, vea [Procedimiento: Especificación de un Programador de tareas en un bloque de flujo de datos](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 La clase <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> se asemeja a la clase <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, salvo que un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> se puede escribir una sola una vez. Puede pensar que <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> es similar a la palabra clave de C# [readonly](../../csharp/language-reference/keywords/readonly.md) ([Readonly](../../visual-basic/language-reference/modifiers/readonly.md) en Visual Basic), salvo que un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> se vuelve inalterable después de recibir un valor en lugar de una construcción. Al igual que la clase <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, cuando un destino recibe un mensaje de un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, el mensaje no se quita de dicho objeto. Por tanto, varios destinos reciben una copia del mensaje. La clase <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> es útil si desea difundir solamente el primero de varios de mensajes.  
  
 En el siguiente ejemplo básico se exponen varios valores <xref:System.String> a un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> y después se lee ese valor desde el objeto. Dado que un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> solo se puede escribir una vez, a partir de que un objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> recibe un mensaje, ese objeto descarta los mensajes subsiguientes.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Para ver un ejemplo completo en donde se muestra cómo utilizar <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> para recibir el valor de la primera operación que finaliza, consulte [Procedimiento: Desvinculación de bloques de flujo de datos](how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloques de ejecución  
 Los bloques de ejecución llaman a un delegado proporcionado por el usuario para cada fragmento de datos recibidos. La biblioteca de flujos de datos TPL proporciona tres tipos de bloques de ejecución: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 La clase <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> es un bloque de destino que llama a un delegado cuando recibe datos. Piense en un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> como un delegado que se ejecuta de forma asincrónica cuando los datos están disponibles. El delegado que se proporciona a un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> puede ser de tipo <xref:System.Action%601> o tipo `System.Func<TInput, Task>`. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con <xref:System.Action%601>, se considera que el procesamiento de cada elemento de entrada se ha completado cuando devuelve el delegado. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con `System.Func<TInput, Task>`, se considera que el procesamiento de cada elemento de entrada se ha completado solamente cuando el objeto devuelto <xref:System.Threading.Tasks.Task> está completo. Mediante estos dos mecanismos, se puede utilizar <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> para el procesamiento sincrónico y asincrónico de cada elemento de entrada.  
  
 En el siguiente ejemplo básico se exponen varios valores <xref:System.Int32> a un objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. El objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> imprime esos valores en la consola. Después, en este ejemplo se establece el bloque en estado completado y se espera hasta que finalicen todas las tareas de flujo de datos.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Para obtener ejemplos completos en donde se muestra cómo usar delegados con la clase <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, vea [Procedimiento: Ejecución de una acción cuando un bloque de flujo de datos recibe datos](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 La clase <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> es similar a la clase <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, salvo que actúa como origen y como destino. El delegado que pasa a un objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> devuelve un valor de tipo `TOutput`. El delegado que se proporciona a un objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> puede ser de tipo `System.Func<TInput, TOutput>` o tipo `System.Func<TInput, Task<TOutput>>`. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> con `System.Func<TInput, TOutput>`, se considera que el procesamiento de cada elemento de entrada se ha completado cuando devuelve el delegado. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> que se usa con `System.Func<TInput, Task<TOutput>>`, se considera que el procesamiento de cada elemento de entrada se ha completado solamente cuando el objeto devuelto <xref:System.Threading.Tasks.Task%601> está completo. Al igual que sucede con <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, mediante estos dos mecanismos, se puede utilizar <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> para el procesamiento sincrónico y asincrónico de cada elemento de entrada.  
  
 En el siguiente ejemplo básico se crea un objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> que calcula la raíz cuadrada de la entrada. El objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> toma valores <xref:System.Int32> como entrada y genera valores <xref:System.Double> como salida.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Para obtener ejemplos completos que utilizan <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> en una red de bloques de flujo de datos que realiza procesamiento de imágenes en una aplicación de Windows Forms, vea [Tutorial: Uso de flujos de datos en aplicaciones de Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 La clase <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> es similar a la clase <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, salvo que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> genere cero o más valores de salida por cada valor de entrada, en lugar de generar un solo valor de salida por cada valor de entrada. El delegado que se proporciona a un objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> puede ser de tipo `System.Func<TInput, IEnumerable<TOutput>>` o tipo `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, IEnumerable<TOutput>>`, se considera que el procesamiento de cada elemento de entrada se ha completado cuando devuelve el delegado. Si se utiliza un objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, Task<IEnumerable<TOutput>>>`, se considera que el procesamiento de cada elemento de entrada se ha completado solo cuando el objeto devuelto `System.Threading.Tasks.Task<IEnumerable<TOutput>>` está completo.  
  
 En el siguiente ejemplo básico se crea un objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> que divide las cadenas en sus secuencias de caracteres individuales. El objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> toma valores <xref:System.String> como entrada y genera valores <xref:System.Char> como salida.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Para obtener ejemplos completos que usan <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> para generar varios resultados independientes para cada entrada en una canalización de flujo de datos, vea [Tutorial: Creación de una canalización de flujos de datos](walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Grado de paralelismo  
 Cada uno de los objetos <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> almacena en búfer los mensajes de entrada hasta que el bloque está listo para procesarlos. De forma predeterminada, estas clases procesan los mensajes en el orden en el que se recibieron, un mensaje cada vez. También puede especificar el grado de paralelismo para permitir que los objetos <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> puedan procesar varios mensajes simultáneamente. Para obtener más información sobre la ejecución simultánea, vea la sección Especificar el grado de paralelismo más adelante en este documento. Para obtener un ejemplo en donde se establece el grado de paralelismo que permite que un bloque de flujo de datos de ejecución pueda procesar varios mensajes al mismo tiempo, vea [Procedimiento: Especificación del grado de paralelismo en un bloque de flujo de datos](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Resumen de tipos de delegado  
 En la tabla siguiente se resumen los tipos de delegado que puede proporcionar a los objetos <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. En esta tabla también se especifica si el tipo de delegado funciona de forma sincrónica o asincrónica.  
  
|Tipo|Tipo de delegado sincrónico|Tipo de delegado asincrónico|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 También puede utilizar expresiones lambda cuando trabaja con tipos de bloque de ejecución. Para obtener un ejemplo en donde se muestra cómo usar una expresión lambda con un bloque de ejecución, vea [Procedimiento: Ejecución de una acción cuando un bloque de flujo de datos recibe datos](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Bloques de agrupación  
 Los bloques de agrupación combinan datos de uno o más orígenes y con distintas restricciones. La biblioteca de flujos de datos TPL proporciona tres tipos de bloques de combinación: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 La clase <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> combina conjuntos de datos de entrada, que se conocen como lotes, en las matrices de datos de salida. Especifique el tamaño de cada lote cuando crea un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>. Cuando el objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> recibe el número especificado de elementos de entrada, propaga de forma asincrónica una matriz que contiene esos elementos. Si un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> se establece en el estado completado pero no contiene elementos suficientes para formar un lote, propaga una matriz final que contiene los elementos de entrada restantes.  
  
 La clase <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> funciona en modo *expansivo* o *no expansivo*. En modo expansivo, que es el valor predeterminado, un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> acepta cada mensaje que se proporciona y propaga una matriz después de recibir el número especificado de elementos. En modo no expansivo, un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> pospone todos los mensajes entrantes hasta que haya suficientes orígenes que proporcionen mensajes al bloque para formar un lote. Normalmente, el modo expansivo se comporta mejor que el modo no expansivo porque requiere menos sobrecarga de procesamiento. Sin embargo, se puede usar el modo no expansivo cuando se debe coordinar el consumo de varios orígenes en modo atómico. Especifique el modo no expansivo estableciendo <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> en `False` en el parámetro `dataflowBlockOptions` del constructor <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 En el siguiente ejemplo básico se exponen varios valores <xref:System.Int32> a un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> que contiene diez elementos en un lote. Para garantizar que todos los valores se propagan fuera de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, este ejemplo llama al método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. El método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> establece el objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> en el estado completado y, por consiguiente, el objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> propaga cualquier elemento restante como un lote final.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Para obtener un ejemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para mejorar la eficacia de las operaciones de inserción de la base de datos, vea [Tutorial: Uso de BatchBlock y BatchedJoinBlock para mejorar la eficacia](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Las clases <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> obtienen elementos de entrada y propagan objetos <xref:System.Tuple%602?displayProperty=nameWithType> o <xref:System.Tuple%603?displayProperty=nameWithType> que contienen esos elementos. Las clases <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> no heredan de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. En su lugar, proporcionan propiedades, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, que implementan <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Al igual que <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> funcionan en modo expansivo o no expansivo. En modo expansivo, que es el valor predeterminado, un objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> acepta cada mensaje que se proporciona y propaga una tupla después de que cada uno de sus destinos reciba por lo menos un mensaje. En modo no expansivo, un objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> pospone todos los mensajes entrantes hasta que todos los destinos han proporcionado los datos necesarios para crear una tupla. En este punto, el bloque se involucra en un protocolo de confirmación en dos fases para recuperar atómicamente todos los elementos necesarios de los orígenes. Este aplazamiento permite que, mientras tanto, otra entidad consuma datos, para permitir que el sistema global progrese.  
  
 En el siguiente ejemplo básico se muestra un caso en el que un objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> requiere varios datos para calcular un valor. En este ejemplo se crea un objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> que requiere dos valores <xref:System.Int32> y un valor <xref:System.Char> para realizar una operación aritmética.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Para obtener un ejemplo completo en donde se usan objetos <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> en modo no expansivo para compartir conjuntamente un recurso, vea [Procedimiento: Uso de JoinBlock para leer datos de varios orígenes](how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Las clases <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> obtienen lotes de elementos de entrada y propagan objetos `System.Tuple(IList(T1), IList(T2))` o `System.Tuple(IList(T1), IList(T2), IList(T3))` que contienen esos elementos. Piense en <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> como una combinación de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Especifique el tamaño de cada lote cuando crea un objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> también proporciona propiedades, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, que implementan <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Cuando el número especificado de elementos de entrada se recibe a través de todos los destinos, el objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> propaga de forma asincrónica un objeto `System.Tuple(IList(T1), IList(T2))` que contiene esos elementos.  
  
 En el siguiente ejemplo básico se crea un objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> que contiene resultados, valores <xref:System.Int32> y errores que son objetos <xref:System.Exception>. En este ejemplo se realizan varias operaciones y se escriben los resultados en la propiedad <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A>, y los errores en la propiedad <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, del objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Dado que el número de operaciones correctas y las que dieron error no se conoce de antemano, los objetos <xref:System.Collections.Generic.IList%601> permiten que cada destino reciba cero o más valores.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Para obtener un ejemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar resultados y cualquier excepción que se produzca mientras el programa lee de una base de datos, vea [Tutorial: Uso de BatchBlock y BatchedJoinBlock para mejorar la eficacia](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Configurar el comportamiento del bloque de flujo de datos  
 Puede habilitar opciones adicionales si proporciona un objeto <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> al constructor de los tipos de bloques de flujo de datos. Estas opciones controlan el comportamiento, como el del programador que administra la tarea subyacente, y el grado de paralelismo. El objeto <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> también tiene tipos derivados que especifican el comportamiento específico de ciertos tipos de bloques de flujo de datos. En la tabla siguiente se resumen los tipo de opciones que se asocian a cada tipo de bloques de flujo de datos.  
  
|Tipo de bloques de flujo de datos|Tipo de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Las secciones siguientes proporcionan información adicional sobre las clases importantes de opciones de bloques de flujo de datos que están disponibles a través de las clases <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Especificar el programador de tareas  
 Cada bloque de flujo de datos predefinido utiliza el mecanismo de programación de tareas de la biblioteca TPL para realizar actividades como propagar datos a un destino, recibir datos de un origen y ejecutar delegados definido por el usuario si los datos están disponibles. <xref:System.Threading.Tasks.TaskScheduler> es una clase abstracta que representa un programador de tareas que pone en cola las tareas en los subprocesos. El programador de tareas predeterminado, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, utiliza la clase <xref:System.Threading.ThreadPool> para poner en cola y ejecutar el trabajo. Puede reemplazar el programador de tareas predeterminado estableciendo la propiedad <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> al crear un objeto de bloque de flujo de datos.  
  
 Cuando el mismo programador de tareas administra varios bloques de flujo de datos, puede aplicar directivas entre ellos. Por ejemplo, si cada uno de los bloques de flujo de datos se configuran como destino del programador exclusivo del mismo objeto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, todo el trabajo que se ejecuta a través de estos bloques se serializa. De igual forma, si estos bloques se configuran como destino del programador simultáneo del mismo objeto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, y el programador se configura para tener un nivel de simultaneidad máximo, todo el trabajo de estos bloques se limita a ese número de operaciones simultáneas. Para obtener un ejemplo en donde se usa la clase <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> para permitir que las operaciones de lectura se produzcan en paralelo, pero las operaciones de escritura sean exclusivas del resto de operaciones, vea [Procedimiento: Especificación de un Programador de tareas en un bloque de flujo de datos](how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Para obtener más información sobre los programadores de tareas en la biblioteca TPL, consulte el tema sobre la clase <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Especificar el grado de Paralelismo  
 De forma predeterminada, los tres tipos de bloques de ejecución que la biblioteca de flujos de datos TPL proporciona, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, procesan un mensaje al mismo tiempo. Estos tipos de bloques de flujo de datos también procesan mensajes en el orden en que se reciben. Para permitir que estos bloques de flujo de datos procesen mensajes simultáneamente, establezca la propiedad <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> cuando construya el objeto de bloques de flujo de datos.  
  
 El valor predeterminado de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> es 1, que garantiza que el bloque de flujo de datos procesa un mensaje al mismo tiempo. Al establecer esta propiedad en un valor mayor de 1 se permite que el bloque de flujo de datos procese varios mensajes simultáneamente. Al establecer esta propiedad en <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> se permite que el programador de tareas subyacente administre el grado máximo de simultaneidad.  
  
> [!IMPORTANT]
> Cuando se especifica un grado máximo de paralelismo mayor que 1, varios mensajes se procesan simultáneamente y, por tanto, los mensajes no se pueden procesar en el orden en que se reciben. Pero los mensajes salen del bloque en el mismo orden en que se reciben.  
  
 Dado que la propiedad <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> representa el grado máximo de paralelismo, el bloque de flujo de datos puede ejecutarse con un menor grado de paralelismo que el especificado. El bloque de flujo de datos puede utilizar un menor grado de paralelismo para cumplir los requisitos funcionales o porque hay una falta de recursos del sistema disponibles. Un flujo de datos bloqueado nunca elige más paralelismo que el especificado.  
  
 El valor de la propiedad <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> es exclusivo para cada objeto de bloque de flujo de datos. Por ejemplo, si cuatro objetos de bloques de flujo de datos especifican 1 como el grado máximo de paralelismo, los cuatro objetos de bloques de flujo de datos podrían ejecutarse en paralelo.  
  
 Para obtener un ejemplo en donde se establece el grado máximo de paralelismo que permite que se produzcan operaciones largas en paralelo, vea [Procedimiento: Especificación del grado de paralelismo en un bloque de flujo de datos](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Especificar el número de mensajes por tarea  
 Los tipos predefinidos de bloques de flujo de datos utilizan tareas para procesar varios elementos de entrada. Esto ayuda a minimizar el número de objetos de tarea necesarios para procesar datos, lo que permite que las aplicaciones se ejecuten más eficazmente. Sin embargo, cuando las tareas de un conjunto de bloques de flujo de datos están procesando datos, es posible que las tareas de otros bloques de flujo de datos tengan que esperar el tiempo de procesamiento en la cola mensajes. Para permitir una mejor equidad entre tareas de flujo de datos, establezca la propiedad <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Cuando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> se establece en <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, que es el valor predeterminado, la tarea utilizada por un bloque de flujo de datos procesa tantos mensajes como están disponibles. Cuando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> se establece en un valor distinto de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, el bloque de flujo de datos procesa como máximo este número de mensajes por objeto <xref:System.Threading.Tasks.Task>. Aunque al establecer la propiedad <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> se puede aumentar la equidad entre tareas, puede provocar que el sistema cree más tareas que las necesarias, lo que puede reducir el rendimiento.  
  
### <a name="enabling-cancellation"></a>Habilitar la cancelación  
 La biblioteca TPL proporciona un mecanismo que habilita las tareas para coordinar la cancelación de manera cooperativa. Para permitir que los bloques de flujo de datos puedan participar en este mecanismo de cancelación, establezca la propiedad <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Cuando este objeto <xref:System.Threading.CancellationToken> se establece en el estado cancelado, todos los bloques de flujo de datos que controlan este token finalizan la ejecución de su elemento actual pero no comienzan a procesar los elementos siguientes. Estos bloques de flujo de datos también borran los mensajes almacenados en búfer, conexiones de inicio para los bloques de origen y de destino, y la transición al estado cancelado. Al realizar la transición al estado cancelado, la propiedad <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> tiene la propiedad <xref:System.Threading.Tasks.Task.Status%2A> establecida en <xref:System.Threading.Tasks.TaskStatus.Canceled>, a menos que se produzca una excepción durante el procesamiento. En ese caso, <xref:System.Threading.Tasks.Task.Status%2A> se establece en <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Para obtener un ejemplo en donde se muestra cómo usar la cancelación en una aplicación de Windows Forms, vea [Procedimiento: Cómo: Cancelar un bloque de flujos de datos](how-to-cancel-a-dataflow-block.md). Para más información sobre la cancelación en la biblioteca TPL, consulte [Task Cancellation](task-cancellation.md) (Cancelación de tareas).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Especificar el comportamiento expansivo frente al no expansivo  
 Varios tipos de bloques de flujo de datos de agrupación pueden trabajar en modo *expansivo* o *no expansivo*. De forma predeterminada, los tipos de bloques de flujo de datos predefinidos funcionan en modo expansivo.  
  
 Para los tipos de bloques de combinación como <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, el modo expansivo significa que el bloque acepta datos inmediatamente aunque los correspondientes datos con los que se combinará aún no estén disponibles. El modo no expansivo significa que el bloque pospone todos los mensajes entrantes hasta que uno esté disponible para cada uno de sus destinos para completar la combinación. Si los mensajes pospuestos ya no están disponibles, el bloque de combinación libera todos los mensajes pospuestos y reinicia el proceso. Para la clase <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, el comportamiento expansivo y no expansivo es similar, salvo que en modo no expansivo, un objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> pospone todos los mensajes entrantes hasta que haya suficientes mensajes disponibles de orígenes distintos para completar un lote.  
  
 Para especificar el modo no expansivo para un bloque de flujo de datos, establezca <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> en `False`. Para obtener un ejemplo en donde se muestra cómo usar el modo no expansivo para permitir que varios bloques de combinación compartan un origen de datos con mayor eficacia, vea [Procedimiento: Uso de JoinBlock para leer datos de varios orígenes](how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Bloques de flujo de datos personalizados  
 Aunque la biblioteca de flujos de datos TPL proporciona muchos tipos de bloques predefinidos, puede crear tipos de bloques adicionales que tengan un comportamiento personalizado. Implemente las interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> directamente, o utilice el método <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> para compilar un bloque complejo que encapsule el comportamiento de los tipos de bloques existentes. Para obtener ejemplos que muestran cómo implementar funcionalidad en bloques de flujo de datos personalizados, vea [Tutorial: Creación de tipos de bloques de flujo de datos personalizados](walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Temas relacionados  
  
|Title|Descripción|  
|-----------|-----------------|  
|[Cómo: Escritura y lectura de mensajes en un bloque de flujo de datos](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Muestra cómo escribir y leer los mensajes de un objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>.|  
|[Cómo: Implementación de un modelo de flujo de datos productor-consumidor](how-to-implement-a-producer-consumer-dataflow-pattern.md)|Describe cómo utilizar el modelo de flujo de datos para implementar un patrón consumidor-productor, cuando el productor envía mensajes a un bloque de flujo de datos y el consumidor lee mensajes de ese bloque.|  
|[Cómo: Ejecución de una acción cuando un bloque de flujo de datos recibe datos](how-to-perform-action-when-a-dataflow-block-receives-data.md)|Describe cómo proporcionar delegados a los tipos de bloques de flujo de datos de ejecución, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Tutorial: Creación de una canalización de flujos de datos](walkthrough-creating-a-dataflow-pipeline.md)|Describe cómo crear una canalización de flujo de datos que descarga texto desde Internet y realiza operaciones en ese texto.|  
|[Cómo: Desvinculación de bloques de flujo de datos](how-to-unlink-dataflow-blocks.md)|Muestra cómo utilizar el método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> para desvincular un bloque de destino de su origen después de que el origen proporciona un mensaje al destino.|  
|[Tutorial: Uso de flujos de datos en aplicaciones de Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md)|Muestra cómo crear una red de bloques de flujo de datos que realizan procesamiento de imágenes en una aplicación de Windows Forms.|  
|[Cómo: Cancelación de un bloque de flujo de datos](how-to-cancel-a-dataflow-block.md)|Muestra cómo se usa la cancelación en una aplicación de Windows Forms.|  
|[Cómo: Uso de JoinBlock para leer datos de diferentes orígenes](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explica cómo utilizar la clase <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> para realizar una operación cuando los datos están disponibles a partir de varios orígenes, y cómo utilizar el modo no expansivo para permitir que varios bloques de combinación puedan compartir un origen de datos más eficazmente.|  
|[Cómo: Especificación del grado de paralelismo en un bloque de flujo de datos](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Describe cómo establecer la propiedad <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> para permitir que un bloque de flujo de datos de ejecución pueda procesar varios mensajes al mismo tiempo.|  
|[Cómo: Especificación de un Programador de tareas en un bloque de flujo de datos](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Muestra cómo asociar un programador de tareas específico cuando se usa flujo de datos en la aplicación.|  
|[Tutorial: Uso de BatchBlock y BatchedJoinBlock para mejorar la eficacia](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Describe cómo utilizar la clase <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para mejorar la eficacia de las operaciones de inserción de la base de datos y cómo utilizar la clase <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar los resultados y cualquier excepción que se produzca mientras el programa lee de una base de datos.|  
|[Tutorial: Creación de tipos de bloques de flujo de datos personalizados](walkthrough-creating-a-custom-dataflow-block-type.md)|Muestra dos maneras de crear un tipo de bloque de flujo de datos que implementa un comportamiento personalizado.|  
|[Biblioteca TPL](task-parallel-library-tpl.md)|Presenta la biblioteca TPL, una biblioteca que simplifica la programación paralela y simultánea en aplicaciones de .NET Framework.|
