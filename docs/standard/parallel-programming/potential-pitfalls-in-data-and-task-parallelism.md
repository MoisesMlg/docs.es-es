---
title: Problemas potenciales en el paralelismo de datos y tareas
description: Descubra los posibles problemas en el paralelismo de datos y tareas, ya que el paralelismo agrega complejidad que no se encuentra en el código secuencial.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: 61c0ea2360ae347e9d5b5eed6fc490171e028408
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94822261"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a><span data-ttu-id="8a2e4-103">Problemas potenciales en el paralelismo de datos y tareas</span><span class="sxs-lookup"><span data-stu-id="8a2e4-103">Potential Pitfalls in Data and Task Parallelism</span></span>
<span data-ttu-id="8a2e4-104">En muchos casos, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pueden proporcionar importantes mejoras de rendimiento con respecto a los bucles secuenciales normales.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-104">In many cases, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> can provide significant performance improvements over ordinary sequential loops.</span></span> <span data-ttu-id="8a2e4-105">Sin embargo, el trabajo de paralelizar el bucle aporta una complejidad que puede conducir a problemas que, en código secuencial, no son tan comunes o no se producen en ningún caso.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-105">However, the work of parallelizing the loop introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.</span></span> <span data-ttu-id="8a2e4-106">En este tema se indican algunas prácticas que se deben evitar al escribir bucles paralelos.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-106">This topic lists some practices to avoid when you write parallel loops.</span></span>  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a><span data-ttu-id="8a2e4-107">No suponer que la ejecución en paralelo siempre es más rápida</span><span class="sxs-lookup"><span data-stu-id="8a2e4-107">Do Not Assume That Parallel Is Always Faster</span></span>  
 <span data-ttu-id="8a2e4-108">En ciertos casos, un bucle paralelo podría ejecutarse más lentamente que su equivalente secuencial.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-108">In certain cases a parallel loop might run slower than its sequential equivalent.</span></span> <span data-ttu-id="8a2e4-109">La regla básica es que es poco probable que los bucles en paralelo que tienen pocas iteraciones y delegados de usuario rápidos aumenten la velocidad en gran medida.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-109">The basic rule of thumb is that parallel loops that have few iterations and fast user delegates are unlikely to speedup much.</span></span> <span data-ttu-id="8a2e4-110">Sin embargo, dado que hay muchos factores que afectan al rendimiento, recomendamos medir siempre los resultados reales.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-110">However, because many factors are involved in performance, we recommend that you always measure actual results.</span></span>  
  
## <a name="avoid-writing-to-shared-memory-locations"></a><span data-ttu-id="8a2e4-111">Evitar la escritura en ubicaciones de memoria compartida</span><span class="sxs-lookup"><span data-stu-id="8a2e4-111">Avoid Writing to Shared Memory Locations</span></span>  
 <span data-ttu-id="8a2e4-112">En código secuencial, no es raro leer o escribir en variables estáticas o campos de clase.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-112">In sequential code, it is not uncommon to read from or write to static variables or class fields.</span></span> <span data-ttu-id="8a2e4-113">Sin embargo, cada vez que varios subprocesos tienen acceso simultáneamente a estas variables, hay grandes posibilidades de que se produzcan condiciones de carrera.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-113">However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.</span></span> <span data-ttu-id="8a2e4-114">Aunque se pueden usar bloqueos para sincronizar el acceso a la variable, el costo de la sincronización puede afectar negativamente al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-114">Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.</span></span> <span data-ttu-id="8a2e4-115">Por tanto, se recomienda evitar, o al menos limitar, el acceso al estado compartido en un bucle en paralelo en la medida de lo posible.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-115">Therefore, we recommend that you avoid, or at least limit, access to shared state in a parallel loop as much as possible.</span></span> <span data-ttu-id="8a2e4-116">La mejor manera de hacerlo es utilizar las sobrecargas de <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> que usan una variable <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> para almacenar el estado local de subproceso durante la ejecución del bucle.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-116">The best way to do this is to use the overloads of <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> that use a <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> variable to store thread-local state during loop execution.</span></span> <span data-ttu-id="8a2e4-117">Para obtener más información, vea [Cómo: Escribir un bucle Parallel.For con variables locales de subproceso](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) y [Cómo: Escribir un bucle Parallel.ForEach con variables locales de partición](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="8a2e4-117">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="avoid-over-parallelization"></a><span data-ttu-id="8a2e4-118">Evitar la paralelización excesiva</span><span class="sxs-lookup"><span data-stu-id="8a2e4-118">Avoid Over-Parallelization</span></span>  
 <span data-ttu-id="8a2e4-119">Si usa bucles en paralelo, incurrirá en costos de sobrecarga al crear particiones de la colección de origen y sincronizar los subprocesos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-119">By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.</span></span> <span data-ttu-id="8a2e4-120">El número de procesadores del equipo reduce también las ventajas de la paralelización.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-120">The benefits of parallelization are further limited by the number of processors on the computer.</span></span> <span data-ttu-id="8a2e4-121">Si se ejecutan varios subprocesos enlazados a cálculos en un único procesador, no se gana en velocidad.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-121">There is no speedup to be gained by running multiple compute-bound threads on just one processor.</span></span> <span data-ttu-id="8a2e4-122">Por tanto, debe tener cuidado para no paralelizar en exceso un bucle.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-122">Therefore, you must be careful not to over-parallelize a loop.</span></span>  
  
 <span data-ttu-id="8a2e4-123">El escenario más común en el que se puede producir un exceso de paralelización son los bucles anidados.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-123">The most common scenario in which over-parallelization can occur is in nested loops.</span></span> <span data-ttu-id="8a2e4-124">En la mayoría de los casos, es mejor paralelizar únicamente el bucle exterior, a menos que se cumplan una o varias de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="8a2e4-124">In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</span></span>  
  
- <span data-ttu-id="8a2e4-125">Se sabe que el bucle interno es muy largo.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-125">The inner loop is known to be very long.</span></span>  
  
- <span data-ttu-id="8a2e4-126">Se realiza un cálculo costoso en cada pedido</span><span class="sxs-lookup"><span data-stu-id="8a2e4-126">You are performing an expensive computation on each order.</span></span> <span data-ttu-id="8a2e4-127">(la operación que se muestra en el ejemplo no es costosa).</span><span class="sxs-lookup"><span data-stu-id="8a2e4-127">(The operation shown in the example is not expensive.)</span></span>  
  
- <span data-ttu-id="8a2e4-128">Se sabe que el sistema de destino tiene suficientes procesadores como para controlar el número de subprocesos que se producirán al paralelizar la consulta de `cust.Orders`.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-128">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.</span></span>  
  
 <span data-ttu-id="8a2e4-129">En todos los casos, la mejor manera de determinar la forma óptima de la consulta es mediante la prueba y la medición.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-129">In all cases, the best way to determine the optimum query shape is to test and measure.</span></span>  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a><span data-ttu-id="8a2e4-130">Evitar llamadas a métodos que no son seguros para subprocesos</span><span class="sxs-lookup"><span data-stu-id="8a2e4-130">Avoid Calls to Non-Thread-Safe Methods</span></span>  
 <span data-ttu-id="8a2e4-131">La escritura en métodos de instancia que no son seguros para subprocesos de un bucle en paralelo puede producir daños en los datos, que pueden pasar o no inadvertidos para el programa.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-131">Writing to non-thread-safe instance methods from a parallel loop can lead to data corruption which may or may not go undetected in your program.</span></span> <span data-ttu-id="8a2e4-132">También puede dar lugar a excepciones.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-132">It can also lead to exceptions.</span></span> <span data-ttu-id="8a2e4-133">En el siguiente ejemplo, varios subprocesos estarían intentando llamar simultáneamente al método <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType>, lo que no se admite en la clase.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-133">In the following example, multiple threads would be attempting to call the <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> method simultaneously, which is not supported by the class.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a><span data-ttu-id="8a2e4-134">Limitar las llamadas a métodos seguros para subprocesos</span><span class="sxs-lookup"><span data-stu-id="8a2e4-134">Limit Calls to Thread-Safe Methods</span></span>  
 <span data-ttu-id="8a2e4-135">La mayoría de los métodos estáticos de .NET son seguros para subprocesos y se les puede llamar desde varios simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-135">Most static methods in .NET are thread-safe and can be called from multiple threads concurrently.</span></span> <span data-ttu-id="8a2e4-136">Sin embargo, incluso en estos casos, la sincronización que esto supone puede conducir a una ralentización importante en la consulta.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-136">However, even in these cases, the synchronization involved can lead to significant slowdown in the query.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8a2e4-137">Puede comprobarlo si inserta algunas llamadas a <xref:System.Console.WriteLine%2A> en las consultas.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-137">You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries.</span></span> <span data-ttu-id="8a2e4-138">Aunque este método se usa en los ejemplos de la documentación para fines de demostración, no debe usarlo en bucles paralelos a menos que sea necesario.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-138">Although this method is used in the documentation examples for demonstration purposes, do not use it in parallel loops unless necessary.</span></span>  
  
## <a name="be-aware-of-thread-affinity-issues"></a><span data-ttu-id="8a2e4-139">Tener en cuenta los problemas de afinidad de los subprocesos</span><span class="sxs-lookup"><span data-stu-id="8a2e4-139">Be Aware of Thread Affinity Issues</span></span>  
 <span data-ttu-id="8a2e4-140">Algunas tecnologías, como la interoperabilidad COM para componentes de contenedor uniproceso (STA), Windows Forms y Windows Presentation Foundation (WPF), imponen restricciones de afinidad de subprocesos que exigen que el código se ejecute en un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-140">Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.</span></span> <span data-ttu-id="8a2e4-141">Por ejemplo, tanto en Windows Forms como en WPF, solo se puede tener acceso a un control en el subproceso donde se creó.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-141">For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.</span></span> <span data-ttu-id="8a2e4-142">Por ejemplo, esto significa que no puede actualizar un control de lista desde un bucle paralelo a menos que configure el programador del subproceso para que programe trabajo solo en el subproceso de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-142">This means, for example, that you cannot update a list control from a parallel loop unless you configure the thread scheduler to schedule work only on the UI thread.</span></span> <span data-ttu-id="8a2e4-143">Para obtener más información, vea cómo [especificar un contexto de sincronización](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span><span class="sxs-lookup"><span data-stu-id="8a2e4-143">For more information, see [Specifying a synchronization context](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span></span>  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a><span data-ttu-id="8a2e4-144">Tener precaución cuando se espera en delegados a los que llama Parallel.Invoke</span><span class="sxs-lookup"><span data-stu-id="8a2e4-144">Use Caution When Waiting in Delegates That Are Called by Parallel.Invoke</span></span>  
 <span data-ttu-id="8a2e4-145">En determinadas circunstancias, la biblioteca TPL incluirá una tarea, lo que significa que se ejecuta en la tarea del subproceso que se está ejecutando actualmente.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-145">In certain circumstances, the Task Parallel Library will inline a task, which means it runs on the task on the currently executing thread.</span></span> <span data-ttu-id="8a2e4-146">(Para más información, consulte [Clase TaskScheduler](xref:System.Threading.Tasks.TaskScheduler)). Esta optimización de rendimiento puede provocar un interbloqueo en ciertos casos.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-146">(For more information, see [Task Schedulers](xref:System.Threading.Tasks.TaskScheduler).) This performance optimization can lead to deadlock in certain cases.</span></span> <span data-ttu-id="8a2e4-147">Por ejemplo, dos tareas podrían ejecutar el mismo código de delegado, que señala cuándo se genera un evento, y después esperar a que la otra tarea señale.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-147">For example, two tasks might run the same delegate code, which signals when an event occurs, and then waits for the other task to signal.</span></span> <span data-ttu-id="8a2e4-148">Si la segunda tarea está alineada en el mismo subproceso que la primera y la primera entra en un estado de espera, la segunda tarea nunca podrá señalar su evento.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-148">If the second task is inlined on the same thread as the first, and the first goes into a Wait state, the second task will never be able to signal its event.</span></span> <span data-ttu-id="8a2e4-149">Para evitar que esto suceda, puede especificar un tiempo de espera en la operación de espera o utilizar constructores de subproceso explícitos para ayudar a garantizar que una tarea no pueda bloquear a la otra.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-149">To avoid such an occurrence, you can specify a timeout on the Wait operation, or use explicit thread constructors to help ensure that one task cannot block the other.</span></span>  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a><span data-ttu-id="8a2e4-150">No suponer que las iteraciones de ForEach, For y ForAll siempre se ejecutan en paralelo</span><span class="sxs-lookup"><span data-stu-id="8a2e4-150">Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel</span></span>  
 <span data-ttu-id="8a2e4-151">Es importante tener en cuenta que las iteraciones individuales de un bucle <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> o <xref:System.Linq.ParallelEnumerable.ForAll%2A> pueden ejecutarse en paralelo, pero no tiene que ser así necesariamente.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-151">It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel.</span></span> <span data-ttu-id="8a2e4-152">Por consiguiente, se debe evitar escribir código cuya exactitud dependa de la ejecución en paralelo de las iteraciones o de la ejecución de las iteraciones en algún orden concreto.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-152">Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.</span></span> <span data-ttu-id="8a2e4-153">Por ejemplo, es probable que este código lleve a un interbloqueo:</span><span class="sxs-lookup"><span data-stu-id="8a2e4-153">For example, this code is likely to deadlock:</span></span>  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 <span data-ttu-id="8a2e4-154">En este ejemplo, una iteración establece un evento y el resto de las iteraciones esperan el evento.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-154">In this example, one iteration sets an event, and all other iterations wait on the event.</span></span> <span data-ttu-id="8a2e4-155">Ninguna de las iteraciones que esperan puede completarse hasta que se haya completado la iteración del valor de evento.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-155">None of the waiting iterations can complete until the event-setting iteration has completed.</span></span> <span data-ttu-id="8a2e4-156">Sin embargo, es posible que las iteraciones que esperan bloqueen todos los subprocesos que se utilizan para ejecutar el bucle paralelo antes de que la iteración del valor de evento haya tenido oportunidad de ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-156">However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.</span></span> <span data-ttu-id="8a2e4-157">Esto produce un interbloqueo: la iteración del valor de evento nunca se ejecutará y las iteraciones que esperan nunca se activarán.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-157">This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.</span></span>  
  
 <span data-ttu-id="8a2e4-158">En concreto, una iteración de un bucle paralelo no debe esperar nunca otra iteración del bucle para progresar.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-158">In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.</span></span> <span data-ttu-id="8a2e4-159">Si el bucle paralelo decide programar las iteraciones secuencialmente pero en el orden contrario, se producirá un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-159">If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.</span></span>  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a><span data-ttu-id="8a2e4-160">Evitar la ejecución de bucles en paralelo en el subproceso de la interfaz de usuario</span><span class="sxs-lookup"><span data-stu-id="8a2e4-160">Avoid Executing Parallel Loops on the UI Thread</span></span>  
 <span data-ttu-id="8a2e4-161">Es importante que la interfaz de usuario (IU) de la aplicación siga respondiendo.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-161">It is important to keep your application's user interface (UI) responsive.</span></span> <span data-ttu-id="8a2e4-162">Si una operación contiene bastante trabajo para garantizar la paralelización, no se debería ejecutar en el subproceso de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-162">If an operation contains enough work to warrant parallelization, then it likely should not be run that operation on the UI thread.</span></span>  <span data-ttu-id="8a2e4-163">Conviene descargarla para que se ejecute en un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-163">Instead, it should offload that operation to be run on a background thread.</span></span> <span data-ttu-id="8a2e4-164">Por ejemplo, si desea utilizar un bucle en paralelo para calcular datos que después se presentarán en un control de IU, considere ejecutar el bucle dentro de una instancia de la tarea en lugar de directamente en un controlador de eventos de IU.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-164">For example, if you want to use a parallel loop to compute some data that should then be rendered into a UI control, you should consider executing the loop within a task instance rather than directly in a UI event handler.</span></span>  <span data-ttu-id="8a2e4-165">Solo si el cálculo básico se ha completado se debería serializar la actualización de nuevo en el subproceso de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-165">Only when the core computation has completed should you then marshal the UI update back to the UI thread.</span></span>  
  
 <span data-ttu-id="8a2e4-166">Si ejecuta bucles en paralelo en el subproceso de la interfaz de usuario, tenga cuidado de evitar la actualización de los controles de la interfaz de usuario desde el interior del bucle.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-166">If you do run parallel loops on the UI thread, be careful to avoid updating UI controls from within the loop.</span></span> <span data-ttu-id="8a2e4-167">Si se intenta actualizar los controles de la interfaz de usuario desde dentro de un bucle en paralelo que se está ejecutando en el subproceso de la interfaz de usuario, se pueden provocar daños en el estado, excepciones, retrasos en las actualizaciones e incluso interbloqueos, dependiendo de cómo se invoque la actualización de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-167">Attempting to update UI controls from within a parallel loop that is executing on the UI thread can lead to state corruption, exceptions, delayed updates, and even deadlocks, depending on how the UI update is invoked.</span></span> <span data-ttu-id="8a2e4-168">En el ejemplo siguiente, el bucle en paralelo bloquea el subproceso de la interfaz de usuario en el que se ejecuta hasta que se completan todas las iteraciones.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-168">In the following example, the parallel loop blocks the UI thread on which it's executing until all iterations are complete.</span></span> <span data-ttu-id="8a2e4-169">Sin embargo, si se está ejecutando una iteración del bucle en un subproceso en segundo plano (como puede hacer <xref:System.Threading.Tasks.Parallel.For%2A>), la llamada a Invoke produce que se envíe un mensaje al subproceso de la interfaz de usuario, que se bloquea mientras espera a que ese mensaje se procese.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-169">However, if an iteration of the loop is running on a background thread (as <xref:System.Threading.Tasks.Parallel.For%2A> may do), the call to Invoke causes a message to be submitted to the UI thread and blocks waiting for that message to be processed.</span></span> <span data-ttu-id="8a2e4-170">Puesto que se bloquea el subproceso de la interfaz de usuario cuando se ejecuta <xref:System.Threading.Tasks.Parallel.For%2A>, el mensaje puede no procesarse nunca y el subproceso de la interfaz de usuario se interbloquea.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-170">Since the UI thread is blocked running the <xref:System.Threading.Tasks.Parallel.For%2A>, the message can never be processed, and the UI thread deadlocks.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 <span data-ttu-id="8a2e4-171">En el siguiente ejemplo se muestra cómo evitar el interbloqueo mediante la ejecución del bucle dentro de una instancia de la tarea.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-171">The following example shows how to avoid the deadlock, by running the loop inside a task instance.</span></span> <span data-ttu-id="8a2e4-172">El bucle no bloquea el subproceso de la interfaz de usuario y se puede procesar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="8a2e4-172">The UI thread is not blocked by the loop, and the message can be processed.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a><span data-ttu-id="8a2e4-173">Vea también</span><span class="sxs-lookup"><span data-stu-id="8a2e4-173">See also</span></span>

- [<span data-ttu-id="8a2e4-174">Programación en paralelo</span><span class="sxs-lookup"><span data-stu-id="8a2e4-174">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="8a2e4-175">Posibles problemas con PLINQ</span><span class="sxs-lookup"><span data-stu-id="8a2e4-175">Potential Pitfalls with PLINQ</span></span>](potential-pitfalls-with-plinq.md)
- <span data-ttu-id="8a2e4-176">[Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=19222) (Patrones para la programación paralela: comprender y aplicar patrones paralelos con .NET Framework 4)</span><span class="sxs-lookup"><span data-stu-id="8a2e4-176">[Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=19222)</span></span>
