---
title: cuantificadores en expresiones regulares
description: Descubra los cuantificadores de expresiones regulares, que especifican cuántas instancias de un carácter, grupo o clase de caracteres deben estar presentes en la entrada para que coincidan.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 361286b992180e1d7fdf18d88022780cc3aa53fc
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889431"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="7c0b8-103">cuantificadores en expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="7c0b8-103">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="7c0b8-104">Los cuantificadores especifican cuántas instancias de un carácter, grupo o clase de caracteres deben estar presentes en la entrada para que se encuentre una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="7c0b8-105">En la tabla siguiente se indican los cuantificadores compatibles con .NET.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="7c0b8-106">Cuantificador expansivo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-106">Greedy quantifier</span></span>|<span data-ttu-id="7c0b8-107">Cuantificador diferido</span><span class="sxs-lookup"><span data-stu-id="7c0b8-107">Lazy quantifier</span></span>|<span data-ttu-id="7c0b8-108">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="7c0b8-109">Coincide cero o más veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="7c0b8-110">Coincide una o más veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="7c0b8-111">Coincide cero o una vez.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="7c0b8-112">`{` *n* `}`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-112">`{` *n* `}`</span></span>|<span data-ttu-id="7c0b8-113">`{` *n* `}?`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-113">`{` *n* `}?`</span></span>|<span data-ttu-id="7c0b8-114">Coincide exactamente *n* veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="7c0b8-115">`{` *n* `,}`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-115">`{` *n* `,}`</span></span>|<span data-ttu-id="7c0b8-116">`{` *n* `,}?`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="7c0b8-117">Coincide al menos *n* veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="7c0b8-118">`{` *n* `,` *m* `}`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="7c0b8-119">`{` *n* `,` *m* `}?`</span><span class="sxs-lookup"><span data-stu-id="7c0b8-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="7c0b8-120">Coincide de *n* a *m* veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="7c0b8-121">Las cantidades `n` y `m` son constantes de tipo entero.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="7c0b8-122">Normalmente, los cuantificadores son expansivos, ya que hacen que el motor de expresiones regulares busque el mayor número posible de repeticiones de patrones concretos.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="7c0b8-123">Si se anexa el carácter `?` a un cuantificador se convierte en diferido, ya que hace que el motor de expresiones regulares busque el menor número posible de repeticiones.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="7c0b8-124">Para obtener una descripción completa de la diferencia entre los cuantificadores expansivos y diferidos, consulte la sección [Cuantificadores expansivos y diferidos](#Greedy) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="7c0b8-125">El anidamiento de cuantificadores (por ejemplo, como hace el patrón de expresión regular `(a*)*`) puede aumentar el número de comparaciones que debe realizar el motor de expresiones regulares, como una función exponencial del número de caracteres de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="7c0b8-126">Para obtener más información sobre este comportamiento y sus soluciones alternativas, consulte [Retroceso](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7c0b8-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="7c0b8-127">Cuantificadores de expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="7c0b8-127">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="7c0b8-128">En las secciones siguientes se enumeran los cuantificadores admitidos en expresiones regulares de .NET.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7c0b8-129">Si los caracteres \*, +, ?, { y } se encuentran en un patrón de expresión regular, el motor de expresiones regulares los interpreta como cuantificadores o como parte de construcciones de cuantificador, a menos que se incluyan en una [clase de caracteres](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7c0b8-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="7c0b8-130">Para interpretarlos como caracteres literales fuera de una clase de caracteres, debe anteponerles una barra diagonal inversa para indicar su secuencia de escape.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="7c0b8-131">Por ejemplo, la cadena `\*` en un patrón de expresión regular se interpreta como un carácter de asterisco literal ("\*").</span><span class="sxs-lookup"><span data-stu-id="7c0b8-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="7c0b8-132">Coincidir cero o más veces: \*</span><span class="sxs-lookup"><span data-stu-id="7c0b8-132">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="7c0b8-133">El cuantificador `*` coincide con el elemento anterior cero o más veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="7c0b8-134">Equivale al cuantificador `{0,}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="7c0b8-135">`*` es un cuantificador expansivo cuyo equivalente diferido es `*?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="7c0b8-136">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="7c0b8-137">De los nueve grupos de dígitos de la cadena de entrada, cinco coinciden con el patrón y cuatro (`95`, `929`, `9219` y `9919`) no coinciden.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-137">Of the nine digit groups in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="7c0b8-138">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-139">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-139">Pattern</span></span>|<span data-ttu-id="7c0b8-140">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-141">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="7c0b8-142">Coincide con un "9" seguido de cero o más caracteres "1".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="7c0b8-143">Coincide con cero o más caracteres "9".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-144">Finaliza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="7c0b8-145">Coincidir una o más veces: +</span><span class="sxs-lookup"><span data-stu-id="7c0b8-145">Match One or More Times: +</span></span>  
 <span data-ttu-id="7c0b8-146">El cuantificador `+` coincide con el elemento anterior una o más veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="7c0b8-147">Equivale a `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="7c0b8-148">`+` es un cuantificador expansivo cuyo equivalente diferido es `+?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="7c0b8-149">Por ejemplo, la expresión regular `\ban+\w*?\b` intenta coincidir con palabras completas que empiezan por la letra `a` seguida de una o más instancias de la letra `n`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="7c0b8-150">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="7c0b8-151">La expresión regular coincide con las palabras `an`, `annual`, `announcement` y `antique`, y no coincide con `autumn` y `all`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="7c0b8-152">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-153">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-153">Pattern</span></span>|<span data-ttu-id="7c0b8-154">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-155">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="7c0b8-156">Coincide con una "a" seguida de uno o más caracteres "n".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="7c0b8-157">Coincide con un carácter de palabra cero o más veces, pero el menor número de veces que sea posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-158">Finaliza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="7c0b8-159">Coincidir cero o una vez: ?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-159">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="7c0b8-160">El cuantificador `?` coincide con el elemento anterior cero o una vez.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="7c0b8-161">Equivale a `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="7c0b8-162">`?` es un cuantificador expansivo cuyo equivalente diferido es `??`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="7c0b8-163">Por ejemplo, la expresión regular `\ban?\b` intenta coincidir con palabras completas que empiezan por la letra `a` seguida de cero o una instancia de la letra `n`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="7c0b8-164">En otras palabras, intenta coincidir con las palabras `a` y `an`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="7c0b8-165">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="7c0b8-166">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-167">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-167">Pattern</span></span>|<span data-ttu-id="7c0b8-168">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-169">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="7c0b8-170">Coincide con una "a" seguida de cero o un carácter "n".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-171">Finaliza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="7c0b8-172">Coincidir exactamente n veces: {n}</span><span class="sxs-lookup"><span data-stu-id="7c0b8-172">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="7c0b8-173">El cuantificador `{`*n*`}` coincide con el elemento anterior exactamente *n* veces, donde *n* es un entero.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="7c0b8-174">`{`*n*`}` es un cuantificador expansivo cuyo equivalente diferido es `{`*n*`}?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="7c0b8-175">Por ejemplo, la expresión regular `\b\d+\,\d{3}\b` intenta coincidir con un límite de palabra seguido de uno o más dígitos decimales, seguidos de tres dígitos decimales, seguidos de un límite de palabra.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="7c0b8-176">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="7c0b8-177">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-178">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-178">Pattern</span></span>|<span data-ttu-id="7c0b8-179">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-180">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="7c0b8-181">Buscar coincidencias con uno o más dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="7c0b8-182">Coincide con un carácter de coma.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="7c0b8-183">Coincide con tres dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-184">Finaliza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="7c0b8-185">Coincidir al menos n veces: {n,}</span><span class="sxs-lookup"><span data-stu-id="7c0b8-185">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="7c0b8-186">El cuantificador `{`*n*`,}` coincide con el elemento anterior al menos *n* , donde *n* es un entero.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="7c0b8-187">`{`*n*`,}` es un cuantificador expansivo cuyo equivalente diferido es `{`*n*`,}?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="7c0b8-188">Por ejemplo, la expresión regular `\b\d{2,}\b\D+` intenta coincidir con un límite de palabra seguido de por lo menos dos dígitos, seguidos de un límite de palabra y de un carácter que no sea un dígito.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="7c0b8-189">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="7c0b8-190">La expresión regular no coincide con la frase `"7 days"` porque solo contiene un dígito decimal, pero coincide correctamente con las frases `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="7c0b8-191">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-192">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-192">Pattern</span></span>|<span data-ttu-id="7c0b8-193">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-194">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="7c0b8-195">Coincide con al menos dos dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-196">Coincide con un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="7c0b8-197">Coincide con al menos un carácter de dígito no decimal.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="7c0b8-198">Coincidir de n a m veces: {n,m}</span><span class="sxs-lookup"><span data-stu-id="7c0b8-198">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="7c0b8-199">El cuantificador `{`*n*`,`*m*`}` coincide con el elemento anterior al menos *n* veces, pero no más de *m* veces, donde *n* y *m* son enteros.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="7c0b8-200">`{`*n*`,`*m*`}` es un cuantificador expansivo cuyo equivalente diferido es `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="7c0b8-201">En el ejemplo siguiente, la expresión regular `(00\s){2,4}` intenta coincidir con dos ceros seguidos de un espacio que se repitan de dos a cuatro veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="7c0b8-202">Observe que la parte final de la cadena de entrada incluye este patrón cinco veces en lugar del máximo de cuatro.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="7c0b8-203">Pero solo la parte inicial de esta subcadena (hasta el espacio y el quinto par de ceros) coincide con el patrón de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="7c0b8-204">Coincidir cero o más veces (coincidencia diferida): \*?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-204">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="7c0b8-205">El cuantificador `*?` coincide con el elemento anterior cero o más veces, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-206">Es el equivalente diferido del cuantificador expansivo `*`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="7c0b8-207">En el ejemplo siguiente, la expresión regular `\b\w*?oo\w*?\b` coincide con todas las palabras que contienen la cadena `oo`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="7c0b8-208">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-209">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-209">Pattern</span></span>|<span data-ttu-id="7c0b8-210">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-211">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="7c0b8-212">Coincide con cero o más caracteres de palabra, pero con el menor número de caracteres posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="7c0b8-213">Coincide con la cadena "oo".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="7c0b8-214">Coincide con cero o más caracteres de palabra, pero con el menor número de caracteres posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-215">Finaliza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="7c0b8-216">Coincidir una o más veces (coincidencia diferida): +?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-216">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="7c0b8-217">El cuantificador `+?` coincide con el elemento anterior una o más veces, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-218">Es el equivalente diferido del cuantificador expansivo `+`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="7c0b8-219">Por ejemplo, la expresión regular `\b\w+?\b` coincide con uno o más caracteres separados por límites de palabra.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="7c0b8-220">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="7c0b8-221">Coincidir cero o una vez (coincidencia diferida): ??</span><span class="sxs-lookup"><span data-stu-id="7c0b8-221">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="7c0b8-222">El cuantificador `??` coincide con el elemento anterior cero o una vez, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-223">Es el equivalente diferido del cuantificador expansivo `?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="7c0b8-224">Por ejemplo, la expresión regular `^\s*(System.)??Console.Write(Line)??\(??` intenta coincidir con las cadenas "Console.Write" o "Console.WriteLine".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="7c0b8-225">La cadena también puede incluir "System."</span><span class="sxs-lookup"><span data-stu-id="7c0b8-225">The string can also include "System."</span></span> <span data-ttu-id="7c0b8-226">antes de "Console", y puede ir seguida de un paréntesis de apertura.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="7c0b8-227">La cadena debe estar al principio de una línea, aunque puede ir precedida de un espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="7c0b8-228">En el ejemplo siguiente se muestra esta expresión regular.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="7c0b8-229">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-230">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-230">Pattern</span></span>|<span data-ttu-id="7c0b8-231">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="7c0b8-232">Coincide con el inicio del flujo de entrada.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="7c0b8-233">Busca coincidencias con cero o más caracteres de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="7c0b8-234">Coincide con cero o una repetición de la cadena "System.".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="7c0b8-235">Coincide con la cadena "Console.Write".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="7c0b8-236">Coincide con cero o una repetición de la cadena "Line".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="7c0b8-237">Coincide con cero o con una repetición del paréntesis de apertura.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="7c0b8-238">Coincidir exactamente n veces (coincidencia diferida): {n}?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="7c0b8-239">El cuantificador `{`*n*`}?` coincide con el elemento anterior exactamente `n` veces, donde *n* es un entero.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="7c0b8-240">Es el equivalente diferido del cuantificador expansivo `{`*n*`}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="7c0b8-241">En el ejemplo siguiente, la expresión regular `\b(\w{3,}?\.){2}?\w{3,}?\b` se usa para identificar la dirección de un sitio web.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="7c0b8-242">Observe que coincide con "www.microsoft.com" y con "msdn.microsoft.com", pero no coincide con "mywebsite" ni con "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="7c0b8-243">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-244">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-244">Pattern</span></span>|<span data-ttu-id="7c0b8-245">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-246">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="7c0b8-247">Coincide con al menos 3 caracteres de palabra, pero con el menor número de caracteres posible, seguidos de un carácter de punto.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="7c0b8-248">Este es el primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="7c0b8-249">Coincide con el patrón del primer grupo dos veces, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="7c0b8-250">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="7c0b8-251">Coincidir al menos n veces (coincidencia diferida): {n,}?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="7c0b8-252">El cuantificador `{`*n*`,}?` coincide con el elemento anterior al menos `n` veces, donde *n* es un entero, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-253">Es el equivalente diferido del cuantificador expansivo `{`*n*`,}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="7c0b8-254">Vea el ejemplo del cuantificador `{`*n*`}?` en la sección anterior para obtener una ilustración.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="7c0b8-255">La expresión regular de ese ejemplo usa el cuantificador `{`*n*`,}` para coincidir con una cadena que tenga al menos tres caracteres seguidos de un punto.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="7c0b8-256">Coincidir de n a m veces (coincidencia diferida): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="7c0b8-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="7c0b8-257">El cuantificador `{`*n*`,`*m*`}?` coincide con el elemento anterior de `n` a `m` veces, donde *n* y *m* son enteros, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-258">Es el equivalente diferido del cuantificador expansivo `{`*n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="7c0b8-259">En el ejemplo siguiente, la expresión regular `\b[A-Z](\w*?\s*?){1,10}[.!?]` coincide con las frases que contengan de una a diez palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="7c0b8-260">Coincidencia con todas las frases de la cadena de entrada, excepto con una frase que contiene 18 palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="7c0b8-261">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-262">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-262">Pattern</span></span>|<span data-ttu-id="7c0b8-263">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="7c0b8-264">Empieza en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="7c0b8-265">Coincide con cualquier letra mayúscula de la A a la Z.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="7c0b8-266">Coincide con cero o más caracteres de palabra, seguidos de uno o más caracteres de espacio en blanco, pero el menor número de veces posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="7c0b8-267">Este es el primer grupo de capturas.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="7c0b8-268">Coincide con el patrón anterior entre una y diez veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="7c0b8-269">Coincide con cualquiera de los caracteres de puntuación ".", "!" o "?".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="7c0b8-270">Cuantificadores expansivos y diferidos</span><span class="sxs-lookup"><span data-stu-id="7c0b8-270">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="7c0b8-271">Varios cuantificadores tienen dos versiones:</span><span class="sxs-lookup"><span data-stu-id="7c0b8-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="7c0b8-272">Una versión expansiva.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-272">A greedy version.</span></span>  
  
     <span data-ttu-id="7c0b8-273">Un cuantificador expansivo intenta coincidir con un elemento tantas veces como sea posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="7c0b8-274">Una versión no expansiva o diferida.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="7c0b8-275">Un cuantificador no expansivo intenta coincidir con un elemento el menor número de veces que sea posible.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="7c0b8-276">Para convertir un cuantificador expansivo en un cuantificador diferido con tan solo agregar el signo `?`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="7c0b8-277">Considere una expresión regular simple diseñada para extraer los cuatro últimos dígitos de una cadena de números, como un número de tarjeta de crédito.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="7c0b8-278">La versión de la expresión regular que usa el cuantificador expansivo `*` es `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="7c0b8-279">Pero si una cadena contiene dos números, esta expresión regular coincide con los cuatro últimos dígitos del segundo número, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="7c0b8-280">La expresión regular no coincide con el primer número porque el cuantificador `*` intenta coincidir con el elemento anterior tantas veces como sea posible en toda la cadena y, por tanto, encuentra una coincidencia al final de la cadena.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="7c0b8-281">Este no es el comportamiento deseado.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-281">This is not the desired behavior.</span></span> <span data-ttu-id="7c0b8-282">En su lugar, puede usar el cuantificador diferido `*?` para extraer los dígitos de ambos números, tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="7c0b8-283">En la mayoría de los casos, las expresiones regulares con cuantificadores expansivos y diferidos devuelven las mismas coincidencias.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="7c0b8-284">Suelen devolver resultados diferentes cuando se usan con el metacarácter comodín (`.`), que coincide con cualquier carácter.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="7c0b8-285">Cuantificadores y coincidencias vacías</span><span class="sxs-lookup"><span data-stu-id="7c0b8-285">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="7c0b8-286">Los cuantificadores `*`, `+` y `{`*n*`,`*m*`}` y sus equivalentes diferidos nunca se repiten tras una coincidencia vacía cuando no se ha encontrado el número mínimo de capturas.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="7c0b8-287">Esta regla impide que los cuantificadores entren en bucles infinitos en coincidencias de subexpresiones vacías cuando el número máximo de posibles capturas de grupo es infinito o cerca de infinito.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="7c0b8-288">Por ejemplo, en el código siguiente se muestra el resultado de una llamada al método <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> con el patrón de expresión regular `(a?)*` que coincide cero o más veces con cero o un carácter "a".</span><span class="sxs-lookup"><span data-stu-id="7c0b8-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="7c0b8-289">Observe que el único grupo de captura realiza una captura de todos los caracteres "a", así como de <xref:System.String.Empty?displayProperty=nameWithType>, pero no hay una segunda coincidencia vacía, ya que la primera coincidencia vacía hace que el cuantificador deje de repetirse.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="7c0b8-290">Para ver la diferencia práctica entre un grupo de captura que define un número mínimo y máximo de capturas y otro que define un número fijo de capturas, tenga en cuenta los patrones de expresiones regulares `(a\1|(?(1)\1)){0,2}` y `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="7c0b8-291">Ambas expresiones regulares constan de un único grupo de captura, que se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="7c0b8-292">Modelo</span><span class="sxs-lookup"><span data-stu-id="7c0b8-292">Pattern</span></span>|<span data-ttu-id="7c0b8-293">Descripción</span><span class="sxs-lookup"><span data-stu-id="7c0b8-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="7c0b8-294">Coincide con "a", junto con el valor del primer grupo capturado...</span><span class="sxs-lookup"><span data-stu-id="7c0b8-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="7c0b8-295">…</span><span class="sxs-lookup"><span data-stu-id="7c0b8-295">…</span></span> <span data-ttu-id="7c0b8-296">o bien, prueba si se ha definido el primer grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="7c0b8-297">(Tenga en cuenta que la construcción `(?(1)` no define un grupo de captura).</span><span class="sxs-lookup"><span data-stu-id="7c0b8-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="7c0b8-298">Si el primer grupo capturado existe, coincide con su valor.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="7c0b8-299">Si el grupo no existe, el grupo coincidirá con <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="7c0b8-300">La primera expresión regular intenta coincidir con este patrón de cero a dos veces; el segundo, exactamente dos veces.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="7c0b8-301">Dado que el primer modelo alcanza el número mínimo de capturas con su primera captura de <xref:System.String.Empty?displayProperty=nameWithType>, nunca se repite para intentar coincidir con `a\1`; el cuantificador `{0,2}` solo permite las coincidencias vacías en la última iteración.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="7c0b8-302">En cambio, la segunda expresión regular coincide con "a" porque evalúa `a\1` una segunda vez. El número mínimo de iteraciones (dos) obliga al motor a repetirse tras una coincidencia vacía.</span><span class="sxs-lookup"><span data-stu-id="7c0b8-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="7c0b8-303">Vea también</span><span class="sxs-lookup"><span data-stu-id="7c0b8-303">See also</span></span>

- [<span data-ttu-id="7c0b8-304">Lenguaje de expresiones regulares: referencia rápida</span><span class="sxs-lookup"><span data-stu-id="7c0b8-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="7c0b8-305">Retroceso</span><span class="sxs-lookup"><span data-stu-id="7c0b8-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
