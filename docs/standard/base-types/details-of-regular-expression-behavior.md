---
title: Comportamiento de expresiones regulares
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 1e5d2d40f52220a8fff40eb19a24d8b2efd3cab5
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829705"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="6a7bc-102">Detalles del comportamiento de expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="6a7bc-102">Details of regular expression behavior</span></span>

<span data-ttu-id="6a7bc-103">El motor de expresiones regulares de .NET es un buscador de coincidencias de expresiones regulares con retroceso que incorpora un motor NFA (autómata finito no determinista) tradicional, como el que usa Perl, Python, Emacs y Tcl.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-103">The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="6a7bc-104">Esto lo distingue de los motores DFA (autómatas finitos deterministas) de expresiones regulares puras, más rápidos pero más limitados, como los de awk, egrep o lex.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="6a7bc-105">Esto también lo distingue de los NFA POSIX, estandarizados pero más lentos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="6a7bc-106">En la sección siguiente se describen los tres tipos de motores de expresiones regulares y se explica por qué las expresiones regulares de .NET se implementan mediante un motor NFA tradicional.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-106">The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="6a7bc-107">Ventajas del motor NFA</span><span class="sxs-lookup"><span data-stu-id="6a7bc-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="6a7bc-108">Cuando los motores DFA realizan una búsqueda de coincidencia de patrones, su orden de procesamiento está controlado por la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="6a7bc-109">El motor empieza al principio de la cadena de entrada y continúa de forma secuencial para determinar si el carácter siguiente coincide con el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="6a7bc-110">Pueden garantizar una coincidencia con la cadena más larga posible.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="6a7bc-111">Dado que nunca prueban el mismo carácter dos veces, los motores de búsqueda DFA no permiten el retroceso.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="6a7bc-112">Pero, como los motores de búsqueda DFA solo contienen estados finitos, no pueden coincidir con un patrón con referencias inversas y, como no crean una expansión explícita, no pueden capturar subexpresiones.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="6a7bc-113">A diferencia de los motores DFA, cuando los motores NFA tradicionales realizan una búsqueda de coincidencia de patrones, su orden de procesamiento está controlado por el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="6a7bc-114">Al procesar un elemento del lenguaje determinado, el motor usa una búsqueda de coincidencia expansiva, es decir, coincide con la mayor parte posible de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="6a7bc-115">Pero también guarda su estado después de encontrar una coincidencia correcta con una subexpresión.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="6a7bc-116">Si finalmente se produce un error en una coincidencia, el motor puede volver a un estado guardado para buscar otras coincidencias.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="6a7bc-117">Este proceso de abandonar una coincidencia de subexpresión correcta para que los elementos del lenguaje subsiguientes de la expresión regular también puedan coincidir se conoce como *retroceso*.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="6a7bc-118">Los motores NFA usan el retroceso para probar todas las expansiones posibles de una expresión regular en un orden específico y aceptan la primera coincidencia.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="6a7bc-119">Puesto que los motores NFA tradicionales construyen una expansión específica de la expresión regular para encontrar una coincidencia correcta, pueden capturar coincidencias de subexpresiones y referencias inversas coincidentes.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="6a7bc-120">Pero el hecho de que los motores NFA tradicionales puedan retroceder les permite visitar el mismo estado varias veces si llegan al estado a través de diferentes rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="6a7bc-121">Como resultado, se pueden ejecutar de forma exponencialmente lenta en el peor de los casos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="6a7bc-122">Dado que los motores NFA tradicionales aceptan la primera coincidencia que encuentran, puede darse que no descubran otras coincidencias (probablemente más largas).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="6a7bc-123">Los motores NFA POSIX son como los motores NFA tradicionales, salvo que siguen retrocediendo hasta que puedan garantizar que han encontrado la coincidencia más larga posible.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="6a7bc-124">Como resultado, un motor NFA POSIX es más lento que un motor NFA tradicional, y cuando se usa un motor NFA POSIX, no se puede dar preferencia a una coincidencia más corta frente a una más larga cambiando el orden de la búsqueda hacia atrás.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="6a7bc-125">Los motores NFA tradicionales son muy populares entre los programadores porque ofrecen mayor control sobre la coincidencia de cadenas que los motores de búsqueda DFA o NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="6a7bc-126">Aunque, en el peor de los casos, se pueden ejecutar con lentitud, se les puede dirigir para que busquen coincidencias en tiempo lineal o polinómico mediante patrones que reduzcan las ambigüedades y limiten el retroceso.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="6a7bc-127">En otras palabras, aunque los motores NFA sacrifican el rendimiento a favor de la eficacia y la flexibilidad, en la mayoría de los casos ofrecen un rendimiento aceptable si una expresión regular está escrita correctamente y evitan los casos en los que el retroceso degrada exponencialmente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="6a7bc-128">Para obtener información sobre la reducción del rendimiento que causa un retroceso excesivo y sobre las maneras de crear una expresión regular para solucionarlo, consulte [Retroceso](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-engine-capabilities"></a><span data-ttu-id="6a7bc-129">Funcionalidades del motor de .NET</span><span class="sxs-lookup"><span data-stu-id="6a7bc-129">.NET engine capabilities</span></span>

 <span data-ttu-id="6a7bc-130">Para aprovechar las ventajas de un motor NFA tradicional, el motor de expresiones regulares de .NET incluye un conjunto completo de construcciones que permiten a los programadores dirigir el motor de retroceso.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-130">To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="6a7bc-131">Estas construcciones se pueden usar para buscar coincidencias con mayor rapidez o para dar preferencia a determinadas expansiones frente a otras.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="6a7bc-132">Otras características del motor de expresiones regulares de .NET son las siguientes:</span><span class="sxs-lookup"><span data-stu-id="6a7bc-132">Other features of the .NET regular expression engine include the following:</span></span>

- <span data-ttu-id="6a7bc-133">Cuantificadores diferidos: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="6a7bc-134">Estas construcciones le indican al motor de retroceso que busque primero el número mínimo de repeticiones.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="6a7bc-135">En cambio, los cuantificadores expansivos normales intentan buscar primero el número máximo de repeticiones.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="6a7bc-136">En el siguiente ejemplo se ilustra la diferencia entre ambos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="6a7bc-137">Una expresión regular coincide con una oración que termina con un número, y hay un grupo de capturas diseñado para extraer ese número.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="6a7bc-138">La expresión regular `.+(\d+)\.` incluye el cuantificador expansivo `.+`, lo que hace que el motor de expresiones regulares capture solo el último dígito del número.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="6a7bc-139">En cambio, la expresión regular `.+?(\d+)\.` incluye el cuantificador diferido `.+?`, lo que hace que el motor de expresiones regulares capture el número entero.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="6a7bc-140">Las versiones expansiva y diferida de esta expresión regular se definen como se muestra en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="6a7bc-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="6a7bc-141">Modelo</span><span class="sxs-lookup"><span data-stu-id="6a7bc-141">Pattern</span></span>|<span data-ttu-id="6a7bc-142">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="6a7bc-143">`.+` (cuantificador expansivo)</span><span class="sxs-lookup"><span data-stu-id="6a7bc-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="6a7bc-144">Buscar al menos una repetición de cualquier carácter.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="6a7bc-145">Esto hace que el motor de expresiones regulares busque una coincidencia con la cadena completa y, después, retroceda según sea necesario para coincidir con el resto del patrón.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="6a7bc-146">`.+?` (cuantificador diferido)</span><span class="sxs-lookup"><span data-stu-id="6a7bc-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="6a7bc-147">Coincide con al menos una repetición de cualquier carácter, pero el menor número posible.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="6a7bc-148">Coincide con al menos un carácter numérico y lo asigna al primer grupo de capturas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="6a7bc-149">Coincide con un punto.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-149">Match a period.</span></span>|

     <span data-ttu-id="6a7bc-150">Para más información sobre los cuantificadores diferidos, vea [Cuantificadores](quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-150">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-151">Búsqueda anticipada positiva: `(?=`*subexpresión*`)`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="6a7bc-152">Esta característica permite que el motor de retroceso vuelva a la misma posición en el texto después de encontrar una coincidencia con una subexpresión.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="6a7bc-153">Es útil para buscar en todo el texto mediante la comprobación de varios patrones que empiezan en la misma posición.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="6a7bc-154">Además, permite al motor comprobar que una subcadena existe al final de la coincidencia sin incluir la subcadena en el texto coincidente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="6a7bc-155">En el ejemplo siguiente se usa la búsqueda anticipada positiva para extraer las palabras de una oración que no van seguidas de símbolos de puntuación.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="6a7bc-156">La expresión regular `\b[A-Z]+\b(?=\P{P})` se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="6a7bc-157">Modelo</span><span class="sxs-lookup"><span data-stu-id="6a7bc-157">Pattern</span></span>|<span data-ttu-id="6a7bc-158">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="6a7bc-159">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="6a7bc-160">Coincide con cualquier carácter alfabético una o más veces.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="6a7bc-161">Como se llama al método <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> con la opción <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, la comparación no distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="6a7bc-162">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="6a7bc-163">Busca hacia delante para determinar si el siguiente carácter es un signo de puntuación.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="6a7bc-164">Si no es así, se produce la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="6a7bc-165">Para obtener más información sobre las aserciones de búsqueda anticipada positiva, consulte [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-165">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-166">Búsqueda anticipada negativa: `(?!`*subexpresión*`)`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="6a7bc-167">Esta característica permite coincidir con una expresión solo si no se produce una coincidencia con una subexpresión.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="6a7bc-168">Esto es eficaz a fin de restringir una búsqueda, ya que a menudo resulta más sencillo proporcionar una expresión para un caso que se debe eliminar, en lugar de una expresión para los casos que se deben incluir.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="6a7bc-169">Por ejemplo, es difícil escribir una expresión para buscar palabras que no comienzan por "non".</span><span class="sxs-lookup"><span data-stu-id="6a7bc-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="6a7bc-170">En el ejemplo siguiente se usa la búsqueda anticipada negativa para excluirlas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="6a7bc-171">El patrón de expresión regular `\b(?!non)\w+\b` se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="6a7bc-172">Modelo</span><span class="sxs-lookup"><span data-stu-id="6a7bc-172">Pattern</span></span>|<span data-ttu-id="6a7bc-173">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="6a7bc-174">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="6a7bc-175">Buscar hacia delante para asegurarse de que la cadena actual no empieza por "non".</span><span class="sxs-lookup"><span data-stu-id="6a7bc-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="6a7bc-176">Si lo hace, se produce un error de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="6a7bc-177">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="6a7bc-178">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="6a7bc-179">Para obtener más información sobre las aserciones de búsqueda anticipada negativa, consulte [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-179">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-180">Evaluación condicional: `(?(`*expresión*`)`*sí*`|`*no*`)` y `(?(`*nombre*`)`*sí*`|`*no*`)`, donde *expresión* es una subexpresión que debe coincidir, *nombre* es el nombre de un grupo de capturas, *sí* es la cadena que debe coincidir si *expresión* coincide o *nombre* es un grupo capturado válido y no vacío, y *no* es la subexpresión que debe coincidir si *expresión* no coincide o si *nombre* no es un grupo capturado válido y no vacío.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="6a7bc-181">Esta característica permite al motor buscar mediante más de un patrón alternativo, según el resultado de una búsqueda de coincidencia de subexpresión anterior o el resultado de una aserción de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="6a7bc-182">Esto posibilita una forma más eficaz de referencia inversa que permite, por ejemplo, coincidir con una subexpresión en función de si se produjo una coincidiencia con una subexpresión anterior.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="6a7bc-183">La expresión regular del ejemplo siguiente coincide con párrafos que están pensados tanto para un uso público como interno.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="6a7bc-184">Los párrafos destinados únicamente al uso interno empiezan con una etiqueta `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="6a7bc-185">El patrón de expresión regular `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` usa la evaluación condicional para asignar el contenido de los párrafos pensados para el uso público y para el uso interno a grupos de capturas independientes.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="6a7bc-186">Después, estos párrafos se pueden tratar de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="6a7bc-187">El patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="6a7bc-188">Modelo</span><span class="sxs-lookup"><span data-stu-id="6a7bc-188">Pattern</span></span>|<span data-ttu-id="6a7bc-189">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="6a7bc-190">Inicia la búsqueda de coincidencias al principio de una línea.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="6a7bc-191">Coincide con cero o una repetición de la cadena `<PRIVATE>` seguida de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="6a7bc-192">Asigna la coincidencia a un grupo de capturas denominado `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="6a7bc-193">Si existe el grupo de capturas `Pvt`, coincide con una o más repeticiones de uno o más caracteres de palabra seguidos de cero o un separador de puntuación, seguido de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="6a7bc-194">Asigna la subcadena al primer grupo de capturas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="6a7bc-195">Si no existe el grupo de capturas `Pvt`, coincide con una o más repeticiones de uno o más caracteres de palabra seguidos de cero o un separador de puntuación, seguido de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="6a7bc-196">Asigna la subcadena al tercer grupo de capturas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="6a7bc-197">Coincide con el final de una línea o con el final de la cadena.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="6a7bc-198">Para obtener más información sobre la evaluación condicional, consulte [Construcciones de alternancia](alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-198">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-199">Definiciones de grupos de equilibrio: `(?<`*nombre1*`-`*nombre2*`>`*subexpresión*`)`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="6a7bc-200">Esta característica permite al motor de expresiones regulares realizar un seguimiento de construcciones anidadas como paréntesis o corchetes de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="6a7bc-201">Para ver un ejemplo, consulte [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-201">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-202">Grupos atómicos: `(?>`*subexpresión*`)`.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="6a7bc-203">Esta característica permite al motor de retroceso garantizar que una subexpresión coincida solo con la primera coincidencia encontrada para dicha subexpresión, como si la expresión se ejecutara independientemente de la expresión que la contiene.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="6a7bc-204">Si no usa esta construcción, el retroceso en las búsquedas en la expresión más grande puede cambiar el comportamiento de una subexpresión.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="6a7bc-205">Por ejemplo, la expresión regular `(a+)\w` coincide con uno o varios caracteres "a", junto con un carácter de palabra que sigue a la secuencia de caracteres "a", y asigna la secuencia de caracteres "a" al primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="6a7bc-206">Sin embargo, si el carácter final de la cadena de entrada es también una "a", coincide con el elemento de lenguaje `\w` y no se incluye en el grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="6a7bc-207">La expresión regular `((?>a+))\w` impide este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="6a7bc-208">Dado que todos los caracteres "a" consecutivos se buscan sin retroceso, el primer grupo de capturas incluye todos los caracteres "a" consecutivos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="6a7bc-209">Si los caracteres "a" no van seguidos de al menos otro carácter que no sea "a", se produce un error de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="6a7bc-210">Para más información sobre los grupos atómicos, vea [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-210">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="6a7bc-211">La búsqueda de coincidencias de derecha a izquierda se especifica al proporcionar la opción <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> a un constructor de clase <xref:System.Text.RegularExpressions.Regex> o a un método coincidente de instancia estática.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="6a7bc-212">Esta característica es útil al realizar búsquedas de derecha a izquierda en lugar de izquierda a derecha, o en los casos en los que es más eficaz iniciar una búsqueda de coincidencias en la parte derecha del patrón, en lugar de la izquierda.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="6a7bc-213">Como se muestra en el ejemplo siguiente, el uso de la búsqueda de coincidencias de derecha a izquierda puede cambiar el comportamiento de los cuantificadores expansivos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="6a7bc-214">En el ejemplo se realizan dos búsquedas de una oración que termina con un número.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="6a7bc-215">La búsqueda de izquierda a derecha que usa el cuantificador expansivo `+` coincide con uno de los seis dígitos de la oración, mientras que la búsqueda de derecha a izquierda coincide con los seis dígitos.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="6a7bc-216">Para ver una descripción del patrón de expresión regular, consulte el ejemplo que ilustra los cuantificadores diferidos anteriormente en esta sección.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="6a7bc-217">Para obtener más información sobre la búsqueda de coincidencias de derecha a izquierda, consulte [Opciones de expresiones regulares](regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-217">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="6a7bc-218">Búsqueda tardía positiva y negativa: `(?<=`*subexpresión*`)` para la búsqueda tardía positiva y `(?<!`*subexpresión*`)` para la búsqueda tardía negativa.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="6a7bc-219">Esta característica es parecida a la búsqueda anticipada, que se describe anteriormente en este tema.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="6a7bc-220">Dado que el motor de expresiones regulares permite una búsqueda de coincidencias completa de derecha a izquierda, las expresiones regulares permiten búsquedas tardías sin restricciones.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="6a7bc-221">La búsqueda tardía positiva y negativa también se puede usar para evitar anidar los cuantificadores cuando la subexpresión anidada es un superconjunto de una expresión exterior.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="6a7bc-222">Las expresiones regulares con cuantificadores anidados suelen ofrecer un rendimiento bajo.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="6a7bc-223">Por ejemplo, en el ejemplo siguiente se comprueba que una cadena empieza y acaba con un carácter alfanumérico y que cualquier otro carácter de la cadena es de un subconjunto más grande.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="6a7bc-224">Forma parte de la expresión regular usada para validar direcciones de correo electrónico. Para obtener más información, vea [Procedimiento: Comprobación de que las cadenas están en un formato de correo electrónico válido](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="6a7bc-225">La expresión regular ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="6a7bc-226">Modelo</span><span class="sxs-lookup"><span data-stu-id="6a7bc-226">Pattern</span></span>|<span data-ttu-id="6a7bc-227">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="6a7bc-228">Empieza la búsqueda de coincidencias en el principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="6a7bc-229">Coincide con cualquier carácter numérico o alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="6a7bc-230">(La comparación no distingue mayúsculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="6a7bc-231">Coincide con cero o más repeticiones de cualquier carácter de palabra o de cualquiera de los caracteres siguientes:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124; o ~.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="6a7bc-232">Realiza una búsqueda tardía en el carácter anterior, que debe ser numérico o alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="6a7bc-233">(La comparación no distingue mayúsculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="6a7bc-234">Finalizar la búsqueda al final de la cadena.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="6a7bc-235">Para obtener más información sobre la búsqueda tardía positiva y negativa, consulte [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6a7bc-235">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="6a7bc-236">Artículos relacionados</span><span class="sxs-lookup"><span data-stu-id="6a7bc-236">Related articles</span></span>

|<span data-ttu-id="6a7bc-237">Title</span><span class="sxs-lookup"><span data-stu-id="6a7bc-237">Title</span></span>|<span data-ttu-id="6a7bc-238">Descripción</span><span class="sxs-lookup"><span data-stu-id="6a7bc-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="6a7bc-239">Retroceso</span><span class="sxs-lookup"><span data-stu-id="6a7bc-239">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="6a7bc-240">Proporciona información sobre la manera en que el retroceso de expresiones regulares se bifurca para buscar coincidencias alternativas.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="6a7bc-241">Compilar y reutilizar</span><span class="sxs-lookup"><span data-stu-id="6a7bc-241">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="6a7bc-242">Proporciona información sobre cómo compilar y reutilizar expresiones regulares para aumentar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="6a7bc-243">Seguridad para subprocesos</span><span class="sxs-lookup"><span data-stu-id="6a7bc-243">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="6a7bc-244">Proporciona información sobre la seguridad para subprocesos de expresiones regulares y explica cuándo se debe sincronizar el acceso a objetos de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="6a7bc-245">Expresiones regulares de .NET</span><span class="sxs-lookup"><span data-stu-id="6a7bc-245">.NET Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="6a7bc-246">Proporciona información general sobre el aspecto del lenguaje de programación de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="6a7bc-247">Modelo de objetos de expresión regular</span><span class="sxs-lookup"><span data-stu-id="6a7bc-247">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="6a7bc-248">Proporciona información y ejemplos de código que muestran cómo usar las clases de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="6a7bc-249">Lenguaje de expresiones regulares: referencia rápida</span><span class="sxs-lookup"><span data-stu-id="6a7bc-249">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="6a7bc-250">Ofrece información sobre el conjunto de caracteres, operadores y construcciones que se pueden usar para definir expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="6a7bc-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="6a7bc-251">Referencia</span><span class="sxs-lookup"><span data-stu-id="6a7bc-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
