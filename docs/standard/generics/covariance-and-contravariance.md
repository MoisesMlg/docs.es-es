---
title: Covarianza y contravarianza en genéricos
description: Descubra la covarianza, que permite usar un tipo más derivado, y la contravarianza, que permite usar un tipo menos derivado, en genéricos de .NET.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 1ad8f72f80e88971e2bbf672bd92d9c607134783
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827417"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="88f2c-103">Covarianza y contravarianza en genéricos</span><span class="sxs-lookup"><span data-stu-id="88f2c-103">Covariance and contravariance in generics</span></span>

<span data-ttu-id="88f2c-104">*Covarianza* y *contravarianza* son términos que hacen referencia a la capacidad de usar un tipo más derivado (más específico) o menos derivado (menos específico) que el indicado originalmente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-104">*Covariance* and *contravariance* are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="88f2c-105">Los parámetros de tipo genérico admiten la covarianza y contravarianza para proporcionar mayor flexibilidad a la hora de asignar y usar tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="88f2c-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span>

<span data-ttu-id="88f2c-106">Cuando se hace referencia a un sistema de tipos, la covarianza, contravarianza e invarianza tienen las definiciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="88f2c-106">When you're referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="88f2c-107">En el ejemplo se presupone una clase base denominada `Base` y una clase derivada denominada `Derived`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="88f2c-108">Permite usar un tipo más derivado que el especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="88f2c-109">Puede asignar una instancia de `IEnumerable<Derived>` a una variable de tipo `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-109">You can assign an instance of `IEnumerable<Derived>` to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="88f2c-110">Permite usar un tipo más genérico (menos derivado) que el especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="88f2c-111">Puede asignar una instancia de `Action<Base>` a una variable de tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-111">You can assign an instance of `Action<Base>` to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="88f2c-112">Significa que solo se puede usar el tipo especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-112">Means that you can use only the type originally specified.</span></span> <span data-ttu-id="88f2c-113">Un parámetro de tipo genérico invariable no es covariante ni contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-113">An invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="88f2c-114">No se puede asignar una instancia de `List<Base>` a una variable de tipo `List<Derived>` o viceversa.</span><span class="sxs-lookup"><span data-stu-id="88f2c-114">You cannot assign an instance of `List<Base>` to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="88f2c-115">Los parámetros de tipo covariante permiten realizar asignaciones muy similares al [polimorfismo](../../csharp/programming-guide/classes-and-structs/polymorphism.md), como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-115">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="88f2c-116">La clase <xref:System.Collections.Generic.List%601> implementa la interfaz <xref:System.Collections.Generic.IEnumerable%601> , por lo que `List<Derived>` (`List(Of Derived)` en Visual Basic) implementa `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-116">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="88f2c-117">El parámetro de tipo covariante se encarga del resto.</span><span class="sxs-lookup"><span data-stu-id="88f2c-117">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="88f2c-118">La contravarianza, sin embargo, parece poco intuitiva.</span><span class="sxs-lookup"><span data-stu-id="88f2c-118">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="88f2c-119">En el siguiente ejemplo, se crea un delegado de tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) y, a continuación, se asigna ese delegado a una variable de tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-119">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="88f2c-120">Parece un paso hacia atrás, pero lo que se compila y se ejecuta es código con seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="88f2c-120">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="88f2c-121">La expresión lambda se corresponde con el delegado al que está asignada, por lo que define un método que toma un parámetro de tipo `Base` y no tiene ningún valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="88f2c-121">The lambda expression matches the delegate it's assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="88f2c-122">El delegado resultante puede asignarse a una variable de tipo `Action<Derived>` porque el parámetro de tipo `T` del delegado <xref:System.Action%601> es contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-122">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="88f2c-123">El código tiene seguridad de tipos porque `T` especifica un tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="88f2c-123">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="88f2c-124">Cuando se invoca el delegado de tipo `Action<Base>` como si fuera un delegado de tipo `Action<Derived>`, su argumento debe ser de tipo `Derived`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-124">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="88f2c-125">Este argumento siempre se puede pasar de manera segura al método subyacente porque el parámetro del método es de tipo `Base`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-125">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="88f2c-126">En general, los parámetros de tipo covariante se pueden utilizar como tipos de valor devuelto de un delegado, y los parámetros de tipo contravariante se pueden usar como tipos de parámetro.</span><span class="sxs-lookup"><span data-stu-id="88f2c-126">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="88f2c-127">En el caso de una interfaz, los parámetros de tipo covariante se pueden utilizar como tipos de valor devuelto de los métodos de la interfaz, y los parámetros de tipo contravariante se pueden usar como tipos de parámetro de los métodos de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="88f2c-127">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="88f2c-128">La covarianza y la contravarianza se denominan colectivamente *varianza*.</span><span class="sxs-lookup"><span data-stu-id="88f2c-128">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="88f2c-129">Un parámetro de tipo genérico que no está marcado como covariante ni contravariante se denomina *invariable*.</span><span class="sxs-lookup"><span data-stu-id="88f2c-129">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="88f2c-130">Un breve resumen de hechos relacionados con la varianza en Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="88f2c-130">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="88f2c-131">Los parámetros de tipo variante están restringidos a los tipos de interfaz genérica y delegado genérico.</span><span class="sxs-lookup"><span data-stu-id="88f2c-131">Variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="88f2c-132">Un tipo de interfaz genérica o de delegado genérico puede tener parámetros de tipo covariante y contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-132">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="88f2c-133">La varianza se aplica únicamente a los tipos de referencia; si se especifica un tipo de valor para un parámetro de tipo variante, ese parámetro de tipo es invariable para el tipo construido resultante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-133">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="88f2c-134">La varianza no se aplica a la combinación de delegados.</span><span class="sxs-lookup"><span data-stu-id="88f2c-134">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="88f2c-135">Es decir, si hay dos delegados de tipo `Action<Derived>` y de tipo `Action<Base>` (`Action(Of Derived)` y `Action(Of Base)` en Visual Basic), no se puede combinar el segundo delegado con el primero aunque el resultado tuviese seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="88f2c-135">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="88f2c-136">La varianza permite la asignación del segundo delegado a una variable de tipo `Action<Derived>`, pero los delegados solo se pueden combinar si tienen exactamente el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="88f2c-136">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

- <span data-ttu-id="88f2c-137">A partir de C# 9, se admiten los tipos de valor devuelto covariantes.</span><span class="sxs-lookup"><span data-stu-id="88f2c-137">Starting in C# 9, covariant return types are supported.</span></span> <span data-ttu-id="88f2c-138">Un método de invalidación puede declarar un tipo de valor devuelto más derivado que el método que invalida, y una propiedad de invalidación, de solo lectura, puede declarar un tipo más derivado.</span><span class="sxs-lookup"><span data-stu-id="88f2c-138">An overriding method can declare a more derived return type the method it overrides, and an overriding, read-only property can declare a more derived type.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="88f2c-139">Interfaces genéricas con parámetros de tipo covariante</span><span class="sxs-lookup"><span data-stu-id="88f2c-139">Generic interfaces with covariant type parameters</span></span>

<span data-ttu-id="88f2c-140">Varias interfaces genéricas tienen parámetros de tipo covariante; por ejemplo, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> y <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="88f2c-140">Several generic interfaces have covariant type parameters, for example, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="88f2c-141">Todos los parámetros de tipo de estas interfaces son covariantes, por lo que los parámetros de tipo se usan únicamente para los tipos de valor devuelto de los miembros.</span><span class="sxs-lookup"><span data-stu-id="88f2c-141">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="88f2c-142">En el ejemplo siguiente, se muestran los parámetros de tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-142">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="88f2c-143">Se definen dos tipos: `Base` tiene un método estático denominado `PrintBases` que toma una interfaz `IEnumerable<Base>` (`IEnumerable(Of Base)` en Visual Basic) e imprime los elementos.</span><span class="sxs-lookup"><span data-stu-id="88f2c-143">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="88f2c-144">`Derived` hereda de `Base`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-144">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="88f2c-145">En el ejemplo, se crea un tipo `List<Derived>` (`List(Of Derived)` en Visual Basic) vacío y se muestra que este tipo se puede pasar a `PrintBases` y asignar a una variable de tipo `IEnumerable<Base>` sin conversión alguna.</span><span class="sxs-lookup"><span data-stu-id="88f2c-145">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="88f2c-146"><xref:System.Collections.Generic.List%601> implementa <xref:System.Collections.Generic.IEnumerable%601>, que tiene un solo parámetro de tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-146"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="88f2c-147">El parámetro de tipo covariante es el motivo por el cual se puede usar una instancia de `IEnumerable<Derived>` en lugar de `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-147">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-type-parameters"></a><span data-ttu-id="88f2c-148">Interfaces genéricas con parámetros de tipo contravariante</span><span class="sxs-lookup"><span data-stu-id="88f2c-148">Generic interfaces with contravariant type parameters</span></span>

<span data-ttu-id="88f2c-149">Varias interfaces genéricas tienen parámetros de tipo contravariante; por ejemplo, <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> y <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="88f2c-149">Several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="88f2c-150">Estas interfaces tienen únicamente parámetros de tipo contravariante, por lo que los parámetros de tipo se utilizan solamente como tipos de parámetro en los miembros de las interfaces.</span><span class="sxs-lookup"><span data-stu-id="88f2c-150">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="88f2c-151">En el ejemplo siguiente se muestran los parámetros de tipo contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-151">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="88f2c-152">En el ejemplo se define clase abstracta`MustInherit` ( `Shape` en Visual Basic) con una propiedad `Area` .</span><span class="sxs-lookup"><span data-stu-id="88f2c-152">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="88f2c-153">En el ejemplo también se define una clase `ShapeAreaComparer` que implementa `IComparer<Shape>` (`IComparer(Of Shape)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="88f2c-153">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="88f2c-154">La implementación del método <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> se basa en el valor de la propiedad `Area` , por lo que `ShapeAreaComparer` se puede usar para ordenar los objetos `Shape` por área.</span><span class="sxs-lookup"><span data-stu-id="88f2c-154">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="88f2c-155">La clase `Circle` hereda `Shape` e invalida `Area`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-155">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="88f2c-156">En el ejemplo se crea una colección <xref:System.Collections.Generic.SortedSet%601> de objetos `Circle` , usando un constructor que toma `IComparer<Circle>` (`IComparer(Of Circle)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="88f2c-156">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="88f2c-157">Sin embargo, en lugar de pasar `IComparer<Circle>`, en el ejemplo se pasa un objeto `ShapeAreaComparer` , que implementa `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-157">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="88f2c-158">En el ejemplo se puede pasar un comparador de un tipo menos derivado (`Shape`) cuando el código llama a un comparador de un tipo más derivado (`Circle`), ya que el parámetro de tipo de la interfaz genérica <xref:System.Collections.Generic.IComparer%601> es contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-158">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="88f2c-159">Cuando se agrega un nuevo objeto `Circle` a `SortedSet<Circle>`, se llama al método `IComparer<Shape>.Compare` (`IComparer(Of Shape).Compare` en Visual Basic) del objeto `ShapeAreaComparer` cada vez que el nuevo elemento se compara con un elemento existente.</span><span class="sxs-lookup"><span data-stu-id="88f2c-159">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="88f2c-160">El tipo de parámetro del método (`Shape`) es menos derivado que el tipo que se pasa (`Circle`), por lo que la llamada tiene seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="88f2c-160">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="88f2c-161">La contravarianza permite a `ShapeAreaComparer` ordenar una colección de cualquier tipo único, así como a una colección mixta de tipos, que derivan de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-161">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="88f2c-162">Delegados genéricos con parámetros de tipo variante</span><span class="sxs-lookup"><span data-stu-id="88f2c-162">Generic delegates with variant type parameters</span></span>

<span data-ttu-id="88f2c-163">Los delegados genéricos `Func`, como <xref:System.Func%602>, tienen tipos de valor devueltos covariante y tipos de parámetro contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-163">The `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="88f2c-164">Los delegados genéricos `Action` , como <xref:System.Action%602>, tienen tipos de parámetro contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-164">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="88f2c-165">Esto significa que los delegados se pueden asignar a variables que tengan tipos de parámetro más derivados y (en el caso de los delegados genéricos `Func` ) tipos de valor devuelto menos derivados.</span><span class="sxs-lookup"><span data-stu-id="88f2c-165">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="88f2c-166">El último parámetro de tipo genérico de los delegados genéricos `Func` especifica el tipo del valor devuelto en la firma de delegado.</span><span class="sxs-lookup"><span data-stu-id="88f2c-166">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="88f2c-167">Es covariante (palabra clave`out` ), mientras que los otros parámetros de tipo genérico son contravariante (palabra clave`in` ).</span><span class="sxs-lookup"><span data-stu-id="88f2c-167">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="88f2c-168">Esto se ilustra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="88f2c-168">The following code illustrates this.</span></span> <span data-ttu-id="88f2c-169">En el primer fragmento de código, se definen una clase denominada `Base`, una clase denominada `Derived` que hereda de `Base`y otra clase con un método `static` (`Shared` en Visual Basic) denominado `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-169">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="88f2c-170">El método toma una instancia de `Base` y devuelve una instancia de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-170">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="88f2c-171">(Si el argumento es una instancia de `Derived`, `MyMethod` la devuelve; si el argumento es una instancia de `Base`, `MyMethod` devuelve una nueva instancia de `Derived`.) En `Main()`, se crea en el ejemplo una instancia de `Func<Base, Derived>` (`Func(Of Base, Derived)` en Visual Basic) que representa `MyMethod`, y la almacena en la variable `f1`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-171">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="88f2c-172">En el segundo fragmento de código, se muestra que el delegado puede asignarse a una variable de tipo `Func<Base, Base>` (`Func(Of Base, Base)` en Visual Basic) ya que el tipo de valor devuelto es covariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-172">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="88f2c-173">En el tercer fragmento de código, se muestra que el delegado puede asignarse a una variable de tipo `Func<Derived, Derived>` (`Func(Of Derived, Derived)` en Visual Basic) ya que el tipo de parámetro es contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-173">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="88f2c-174">En el último fragmento de código, se muestra que el delegado puede asignarse a una variable de tipo `Func<Derived, Base>` (`Func(Of Derived, Base)` en Visual Basic), combinando los efectos del tipo de parámetro contravariante y el tipo de valor devuelto covariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-174">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-non-generic-delegates"></a><span data-ttu-id="88f2c-175">Varianza en delegados no genéricos</span><span class="sxs-lookup"><span data-stu-id="88f2c-175">Variance in non-generic delegates</span></span>

 <span data-ttu-id="88f2c-176">En el código anterior, la signatura de `MyMethod` coincide exactamente con la signatura del delegado genérico construido: `Func<Base, Derived>` (`Func(Of Base, Derived)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="88f2c-176">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="88f2c-177">En el ejemplo, se muestra que este delegado genérico se puede almacenar en variables o en parámetros de método que tengan tipos de parámetro más derivados y tipos de valor devuelto menos derivados, siempre y cuando todos los tipos de delegado se construyan a partir del tipo de delegado genérico <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="88f2c-177">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="88f2c-178">Este es un aspecto importante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-178">This is an important point.</span></span> <span data-ttu-id="88f2c-179">Los efectos de la covarianza y la contravarianza en los parámetros de tipo de los delegados genéricos son similares a los efectos de la covarianza y la contravarianza en el enlace a delegados normal; vea [Varianza en delegados (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) y [Varianza en delegados (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="88f2c-179">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="88f2c-180">Sin embargo, la varianza en el enlace a delegados funciona con todos los tipos de delegado, no solo con tipos de delegado genérico que tienen parámetros de tipo variante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-180">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="88f2c-181">Además, la varianza en el enlace a delegados permite enlazar un método a cualquier delegado que tenga tipos de parámetro más restrictivos y un tipo de valor devuelto menos restrictivo, mientras que la asignación de delegados genéricos solo funciona si ambos tipos de delegado se construyen a partir de la misma definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="88f2c-181">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="88f2c-182">En el ejemplo siguiente se muestran los efectos combinados de la varianza en el enlace a delegados y la varianza en los parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="88f2c-182">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="88f2c-183">En el ejemplo se define una jerarquía de tipos que incluye tres tipos, de menos derivado (`Type1`) a más derivado (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="88f2c-183">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="88f2c-184">La varianza en el enlace a delegados normal se usa para enlazar un método con un tipo de parámetro de `Type1` y un tipo de valor devuelto de `Type3` a un delegado genérico con un tipo de parámetro de `Type2` y un tipo de valor devuelto de `Type2`.</span><span class="sxs-lookup"><span data-stu-id="88f2c-184">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="88f2c-185">A continuación, el delegado genérico resultante se asigna a otra variable cuyo tipo de delegado genérico tiene un parámetro de tipo `Type3` y un tipo de valor devuelto de `Type1`, usando la covarianza y contravarianza de parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="88f2c-185">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="88f2c-186">La segunda asignación requiere que tanto el tipo de variable como el tipo de delegado se construyan a partir de la misma definición de tipo genérico, en este caso <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="88f2c-186">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="define-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="88f2c-187">Definición de interfaces y delegados genéricos variantes</span><span class="sxs-lookup"><span data-stu-id="88f2c-187">Define variant generic interfaces and delegates</span></span>

<span data-ttu-id="88f2c-188">Visual Basic y C# tienen palabras clave que permiten marcar como covariantes o contravariantes los parámetros de tipo genérico de las interfaces y los delegados.</span><span class="sxs-lookup"><span data-stu-id="88f2c-188">Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>
  
 <span data-ttu-id="88f2c-189">Un parámetro de tipo covariante se marca con la palabra clave `out` (`Out` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="88f2c-189">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic).</span></span> <span data-ttu-id="88f2c-190">Puede usar un parámetro de tipo covariante como el valor devuelto de un método que pertenece a una interfaz o como el tipo de valor devuelto de un delegado.</span><span class="sxs-lookup"><span data-stu-id="88f2c-190">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="88f2c-191">No puede usar un parámetro de tipo covariante como una restricción de tipo genérico para los métodos de interfaz.</span><span class="sxs-lookup"><span data-stu-id="88f2c-191">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="88f2c-192">Si un método de una interfaz tiene un parámetro que es un tipo de delegado genérico, se puede usar un parámetro de tipo covariante del tipo de interfaz para especificar un parámetro de tipo contravariante del tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="88f2c-192">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="88f2c-193">Un parámetro de tipo contravariante se marca con la palabra clave `in` (`In` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="88f2c-193">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic).</span></span> <span data-ttu-id="88f2c-194">Puede usar un parámetro de tipo contravariante como el tipo de un parámetro de un método que pertenece a una interfaz o como el tipo de un parámetro de un delegado.</span><span class="sxs-lookup"><span data-stu-id="88f2c-194">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="88f2c-195">Puede usar un parámetro de tipo contravariante como una restricción de tipo genérico para un método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="88f2c-195">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="88f2c-196">Solo los tipos de interfaz y los tipos de delegado pueden tener parámetros de tipo variante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-196">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="88f2c-197">Un tipo de interfaz o un tipo de delegado puede tener parámetros de tipo covariante y contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-197">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="88f2c-198">Visual Basic y C# no le permiten infringir las reglas de uso de parámetros de tipo covariante y contravariante ni agregar anotaciones de covarianza y contravarianza a los parámetros de tipo de tipos distintos de interfaces y delegados.</span><span class="sxs-lookup"><span data-stu-id="88f2c-198">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span>
  
 <span data-ttu-id="88f2c-199">Para obtener información y código de ejemplo, vea [Varianza en interfaces genéricas (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) y [Varianza en interfaces genéricas (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="88f2c-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-types"></a><span data-ttu-id="88f2c-200">Lista de tipos</span><span class="sxs-lookup"><span data-stu-id="88f2c-200">List of types</span></span>

<span data-ttu-id="88f2c-201">Los siguientes tipos de interfaz y delegado tienen parámetros de tipo covariante o contravariante.</span><span class="sxs-lookup"><span data-stu-id="88f2c-201">The following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="88f2c-202">Tipo</span><span class="sxs-lookup"><span data-stu-id="88f2c-202">Type</span></span>|<span data-ttu-id="88f2c-203">Parámetros de tipo covariante</span><span class="sxs-lookup"><span data-stu-id="88f2c-203">Covariant type parameters</span></span>|<span data-ttu-id="88f2c-204">Parámetros de tipo contravariante</span><span class="sxs-lookup"><span data-stu-id="88f2c-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="88f2c-205"><xref:System.Action%601> a <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="88f2c-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="88f2c-206">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="88f2c-207">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="88f2c-208">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-208">Yes</span></span>|<span data-ttu-id="88f2c-209">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="88f2c-210">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-210">Yes</span></span>||  
|<span data-ttu-id="88f2c-211"><xref:System.Func%602> a <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="88f2c-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="88f2c-212">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-212">Yes</span></span>|<span data-ttu-id="88f2c-213">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="88f2c-214">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="88f2c-215">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="88f2c-216">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="88f2c-217">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="88f2c-218">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="88f2c-219">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="88f2c-220">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="88f2c-221">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="88f2c-222">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="88f2c-223">Sí</span><span class="sxs-lookup"><span data-stu-id="88f2c-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="88f2c-224">Vea también</span><span class="sxs-lookup"><span data-stu-id="88f2c-224">See also</span></span>

- [<span data-ttu-id="88f2c-225">Covarianza y contravarianza (C#)</span><span class="sxs-lookup"><span data-stu-id="88f2c-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="88f2c-226">Covarianza y contravarianza (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="88f2c-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="88f2c-227">Varianza en delegados (C#)</span><span class="sxs-lookup"><span data-stu-id="88f2c-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="88f2c-228">Varianza en delegados (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="88f2c-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
