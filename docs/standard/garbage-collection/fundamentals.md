---
title: Fundamentos de la recolección de elementos no utilizados
description: Obtenga información sobre cómo funciona el recolector de elementos no utilizados y cómo puede configurarse para un rendimiento óptimo.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: b70eb44c3d92e03ab4b33f81b87d48c70797cec5
ms.sourcegitcommit: 30a686fd4377fe6472aa04e215c0de711bc1c322
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/10/2020
ms.locfileid: "94441016"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="32362-103">Fundamentos de la recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="32362-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="32362-104">En el Common Language Runtime (CLR), el recolector de elementos no utilizados (GC) actúa como administrador de memoria automático.</span><span class="sxs-lookup"><span data-stu-id="32362-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="32362-105">El recolector de elementos no utilizados administra la asignación y liberación de la memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="32362-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="32362-106">Esto significa que los desarrolladores que trabajan con código administrado no tienen que escribir código para realizar tareas de administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="32362-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="32362-107">La administración automática de la memoria puede eliminar problemas frecuentes, como olvidar liberar un objeto y causar una pérdida de memoria, o intentar acceder a la memoria de un objeto que ya se ha liberado.</span><span class="sxs-lookup"><span data-stu-id="32362-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="32362-108">En este artículo se describen los conceptos básicos de la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="32362-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="32362-109">Ventajas</span><span class="sxs-lookup"><span data-stu-id="32362-109">Benefits</span></span>

<span data-ttu-id="32362-110">El recolector de elementos no utilizados proporciona las siguientes ventajas:</span><span class="sxs-lookup"><span data-stu-id="32362-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="32362-111">Exime a los desarrolladores de tener que liberar memoria manualmente.</span><span class="sxs-lookup"><span data-stu-id="32362-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="32362-112">Asigna con eficacia los objetos del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="32362-113">Reclama los objetos que ya no se utilizan, borra la memoria correspondiente y mantiene la memoria disponible para asignaciones futuras.</span><span class="sxs-lookup"><span data-stu-id="32362-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="32362-114">Los objetos administrados obtienen automáticamente contenido limpio desde el principio, de modo que sus constructores no tienen que inicializar todos los campos de datos.</span><span class="sxs-lookup"><span data-stu-id="32362-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="32362-115">Proporciona seguridad de memoria, al asegurarse de que un objeto no pueda utilizar el contenido de otro objeto.</span><span class="sxs-lookup"><span data-stu-id="32362-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="32362-116">Fundamentos de memoria</span><span class="sxs-lookup"><span data-stu-id="32362-116">Fundamentals of memory</span></span>

<span data-ttu-id="32362-117">En la lista siguiente se resumen los conceptos importantes de memoria de CLR.</span><span class="sxs-lookup"><span data-stu-id="32362-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="32362-118">Cada proceso tiene propio espacio de direcciones virtuales independiente.</span><span class="sxs-lookup"><span data-stu-id="32362-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="32362-119">Todos los procesos del equipo comparten la misma memoria física y el archivo de paginación, si hay alguno.</span><span class="sxs-lookup"><span data-stu-id="32362-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="32362-120">De forma predeterminada, en los equipos de 32 bits, cada proceso tiene un espacio de direcciones virtuales en modo usuario de 2 GB.</span><span class="sxs-lookup"><span data-stu-id="32362-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="32362-121">Como desarrollador de aplicaciones, solo trabaja con el espacio de direcciones virtuales y nunca manipula la memoria física directamente.</span><span class="sxs-lookup"><span data-stu-id="32362-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="32362-122">El recolector de elementos no utilizados asigna y libera memoria virtual en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="32362-123">Si está escribiendo código nativo, use funciones de Windows para trabajar con el espacio de direcciones virtuales.</span><span class="sxs-lookup"><span data-stu-id="32362-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="32362-124">Estas funciones asignan y liberan memoria virtual en pilas nativas.</span><span class="sxs-lookup"><span data-stu-id="32362-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="32362-125">La memoria virtual puede estar en tres estados:</span><span class="sxs-lookup"><span data-stu-id="32362-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="32362-126">Estado</span><span class="sxs-lookup"><span data-stu-id="32362-126">State</span></span> | <span data-ttu-id="32362-127">Descripción</span><span class="sxs-lookup"><span data-stu-id="32362-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="32362-128">Gratuito</span><span class="sxs-lookup"><span data-stu-id="32362-128">Free</span></span> | <span data-ttu-id="32362-129">El bloque de memoria no tiene ninguna referencia a ella y está disponible para su asignación.</span><span class="sxs-lookup"><span data-stu-id="32362-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="32362-130">Reservada</span><span class="sxs-lookup"><span data-stu-id="32362-130">Reserved</span></span> | <span data-ttu-id="32362-131">El bloque de memoria está disponible para su uso y no se puede emplear para ninguna otra solicitud de asignación.</span><span class="sxs-lookup"><span data-stu-id="32362-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="32362-132">Sin embargo, no puede almacenar datos en este bloque de memoria hasta que se confirme.</span><span class="sxs-lookup"><span data-stu-id="32362-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="32362-133">Confirmado</span><span class="sxs-lookup"><span data-stu-id="32362-133">Committed</span></span> | <span data-ttu-id="32362-134">El bloque de memoria se asigna al almacenamiento físico.</span><span class="sxs-lookup"><span data-stu-id="32362-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="32362-135">El espacio de direcciones virtuales puede llegar a fragmentarse.</span><span class="sxs-lookup"><span data-stu-id="32362-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="32362-136">Esto significa que hay bloques libres, también conocidos como marcadores, en el espacio de direcciones.</span><span class="sxs-lookup"><span data-stu-id="32362-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="32362-137">Cuando se solicita una asignación de memoria virtual, el administrador de memoria virtual tiene que encontrar un único bloque libre que sea suficientemente grande para satisfacer esa solicitud de asignación.</span><span class="sxs-lookup"><span data-stu-id="32362-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="32362-138">Aunque tenga 2 GB de espacio disponible, una asignación que necesite 2 GB será incorrecta a menos que todo ese espacio disponible esté en un único bloque de direcciones.</span><span class="sxs-lookup"><span data-stu-id="32362-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="32362-139">Puede quedarse sin memoria si no hay suficiente espacio de direcciones virtuales para reservar o espacio físico para confirmar.</span><span class="sxs-lookup"><span data-stu-id="32362-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="32362-140">El archivo de paginación se usa aunque haya poca necesidad de memoria física (es decir, demanda de memoria física).</span><span class="sxs-lookup"><span data-stu-id="32362-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="32362-141">La primera vez que se necesita memoria física, el sistema operativo debe hacer sitio en ella para almacenar los datos y hace una copia de seguridad en el archivo de paginación de algunos datos que están en la memoria física.</span><span class="sxs-lookup"><span data-stu-id="32362-141">The first time that physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="32362-142">Esos datos no se paginan hasta que no se necesitan, por lo que es posible encontrar paginación en situaciones donde haya muy poca necesidad de memoria física.</span><span class="sxs-lookup"><span data-stu-id="32362-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="32362-143">Asignación de memoria</span><span class="sxs-lookup"><span data-stu-id="32362-143">Memory allocation</span></span>

<span data-ttu-id="32362-144">Cuando se inicializa un nuevo proceso, el motor en tiempo de ejecución reserva una región contigua de espacio de direcciones para el proceso.</span><span class="sxs-lookup"><span data-stu-id="32362-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="32362-145">Este espacio de direcciones reservado se denomina montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="32362-146">El montón administrado mantiene un puntero a la dirección a la que se asignará el siguiente objeto del montón.</span><span class="sxs-lookup"><span data-stu-id="32362-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="32362-147">Inicialmente, este puntero se establece en la dirección base del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="32362-148">Todos los tipos de referencia se asignan en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="32362-149">Cuando una aplicación crea el primer tipo de referencia, se le asigna memoria en la dirección base del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="32362-150">Cuando la aplicación crea el siguiente objeto, el recolector de elementos no utilizados le asigna memoria en el espacio de direcciones que sigue inmediatamente al primer objeto.</span><span class="sxs-lookup"><span data-stu-id="32362-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="32362-151">Siempre que haya espacio de direcciones disponible, el recolector de elementos no utilizados continúa asignando espacio a los objetos nuevos de este modo.</span><span class="sxs-lookup"><span data-stu-id="32362-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="32362-152">La asignación de memoria desde el montón administrado es más rápida que la asignación de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="32362-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="32362-153">Como el tiempo de ejecución asigna memoria a los objetos agregando un valor a un puntero, este método es casi tan rápido como la asignación de memoria desde la pila.</span><span class="sxs-lookup"><span data-stu-id="32362-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="32362-154">Además, puesto que los nuevos objetos que se asignan consecutivamente se almacenan uno junto a otro en el montón administrado, la aplicación puede acceder rápidamente a los objetos.</span><span class="sxs-lookup"><span data-stu-id="32362-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="32362-155">Liberación de memoria</span><span class="sxs-lookup"><span data-stu-id="32362-155">Memory release</span></span>

<span data-ttu-id="32362-156">El motor de optimización del recolector de elementos no utilizados determina cuál es el mejor momento para realizar una recolección basándose en las asignaciones realizadas.</span><span class="sxs-lookup"><span data-stu-id="32362-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="32362-157">Cuando el recolector de elementos no utilizados lleva a cabo una recolección, libera la memoria de los objetos que ya no usa la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32362-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="32362-158">Determina qué objetos ya no se usan examinando las *raíces* de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32362-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="32362-159">Las raíces de una aplicación incluyen campos estáticos, variables locales en la pila de un subproceso, registros de la CPU, identificadores de recolección de elementos no utilizados y la cola de finalización.</span><span class="sxs-lookup"><span data-stu-id="32362-159">An application's roots include static fields, local variables on a thread's stack, CPU registers, GC handles, and the finalize queue.</span></span> <span data-ttu-id="32362-160">Cada raíz hace referencia a un objeto del montón administrado, o bien se establece en null.</span><span class="sxs-lookup"><span data-stu-id="32362-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="32362-161">El recolector de elementos no utilizados puede solicitar estas raíces al resto del entorno de ejecución.</span><span class="sxs-lookup"><span data-stu-id="32362-161">The garbage collector can ask the rest of the runtime for these roots.</span></span> <span data-ttu-id="32362-162">Con esta lista, el recolector de elementos no utilizados crea un gráfico que contiene todos los objetos que no se pueden alcanzar desde las raíces.</span><span class="sxs-lookup"><span data-stu-id="32362-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="32362-163">Los objetos que no están en el gráfico no se pueden alcanzar desde las raíces de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32362-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="32362-164">El recolector de elementos no utilizados considera elementos no utilizados los objetos inalcanzables y libera la memoria que tienen asignada.</span><span class="sxs-lookup"><span data-stu-id="32362-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="32362-165">Durante una recolección, el recolector de elementos no utilizados examina el montón administrado y busca los bloques de espacio de direcciones que ocupan los objetos que no se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="32362-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="32362-166">Cuando detecta cada uno de los objetos inalcanzables, usa una función de copia de memoria para compactar los objetos alcanzables en la memoria y libera los bloques de espacios de direcciones asignados a los objetos no alcanzables.</span><span class="sxs-lookup"><span data-stu-id="32362-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="32362-167">Una vez que se ha compactado la memoria de los objetos alcanzables, el recolector de elementos no utilizados hace las correcciones de puntero necesarias para que las raíces de la aplicación señalen a los objetos en sus nuevas ubicaciones.</span><span class="sxs-lookup"><span data-stu-id="32362-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="32362-168">También sitúa el puntero del montón administrado después del último objeto alcanzable.</span><span class="sxs-lookup"><span data-stu-id="32362-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="32362-169">La memoria solo se compacta si, durante una recolección, se detecta un número significativo de objetos inalcanzables.</span><span class="sxs-lookup"><span data-stu-id="32362-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="32362-170">Si todos los objetos del montón administrado sobreviven a una recolección, no hay necesidad de comprimir la memoria.</span><span class="sxs-lookup"><span data-stu-id="32362-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="32362-171">Para mejorar el rendimiento, el tiempo de ejecución asigna memoria a los objetos grandes en un montón aparte.</span><span class="sxs-lookup"><span data-stu-id="32362-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="32362-172">El recolector de elementos no utilizados libera la memoria para los objetos grandes automáticamente.</span><span class="sxs-lookup"><span data-stu-id="32362-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="32362-173">Pero, para no mover objetos grandes en la memoria, normalmente dicha memoria no se compacta.</span><span class="sxs-lookup"><span data-stu-id="32362-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="32362-174">Condiciones para la recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="32362-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="32362-175">La recolección de elementos no utilizados se produce cuando se cumple alguna de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="32362-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="32362-176">El sistema tiene poca memoria física.</span><span class="sxs-lookup"><span data-stu-id="32362-176">The system has low physical memory.</span></span> <span data-ttu-id="32362-177">Esto detecta cualquier la notificación memoria insuficiente desde el sistema operativo o de poca memoria indicada por el host.</span><span class="sxs-lookup"><span data-stu-id="32362-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="32362-178">La memoria que utilizan los objetos asignados del montón administrado supera un umbral aceptable.</span><span class="sxs-lookup"><span data-stu-id="32362-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="32362-179">Este umbral se ajusta continuamente a medida que se ejecuta el proceso.</span><span class="sxs-lookup"><span data-stu-id="32362-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="32362-180">Se llama al método <xref:System.GC.Collect%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="32362-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="32362-181">En casi todos casos, no es necesario llamar a este método, porque el recolector de elementos no utilizados se ejecuta continuamente.</span><span class="sxs-lookup"><span data-stu-id="32362-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="32362-182">Este método se utiliza principalmente para pruebas y situaciones singulares.</span><span class="sxs-lookup"><span data-stu-id="32362-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="32362-183">Montón administrado</span><span class="sxs-lookup"><span data-stu-id="32362-183">The managed heap</span></span>

<span data-ttu-id="32362-184">Una vez que el CLR inicializa el recolector de elementos no utilizados, asigna un segmento de memoria para almacenar y administrar objetos.</span><span class="sxs-lookup"><span data-stu-id="32362-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="32362-185">Esta memoria se denomina montón administrado, y se diferencia del montón nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="32362-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="32362-186">Hay un montón administrado para cada proceso administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="32362-187">Todos los subprocesos del proceso asignan memoria a los objetos del mismo montón.</span><span class="sxs-lookup"><span data-stu-id="32362-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="32362-188">Para reservar memoria, el recolector de elementos no utilizados llama a la función [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) de Windows y reserva un segmento de memoria cada vez para las aplicaciones administradas.</span><span class="sxs-lookup"><span data-stu-id="32362-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="32362-189">El recolector de elementos no utilizados también reserva segmentos según sea necesario y vuelve a liberarlos para el sistema operativo (después de borrarlos de todos los objetos) mediante una llamada a la función [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) de Windows.</span><span class="sxs-lookup"><span data-stu-id="32362-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32362-190">El tamaño de los segmentos asignados por el recolector de elementos no utilizados es específico de la implementación y está sujeto a cambios en cualquier momento, incluso en las actualizaciones periódicas.</span><span class="sxs-lookup"><span data-stu-id="32362-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="32362-191">La aplicación nunca debe realizar suposiciones sobre el tamaño de un sector determinado ni depender de él, y tampoco debe intentar configurar la cantidad de memoria disponible para las asignaciones de segmentos.</span><span class="sxs-lookup"><span data-stu-id="32362-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="32362-192">Cuantos menos objetos se asignen al montón, menos trabajo tendrá que hacer el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="32362-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="32362-193">Al asignar objetos, no use valores redondeados que superen sus necesidades; por ejemplo, no asigne una matriz de 32 bytes si solo necesita 15 bytes.</span><span class="sxs-lookup"><span data-stu-id="32362-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="32362-194">Cuando se desencadena una recolección de elementos no utilizados, el recolector de elementos no utilizados reclama la memoria ocupada por objetos muertos.</span><span class="sxs-lookup"><span data-stu-id="32362-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="32362-195">El proceso de reclamación compacta los objetos activos para moverlos juntos, y el espacio muerto se quita, para reducir el montón.</span><span class="sxs-lookup"><span data-stu-id="32362-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="32362-196">De este modo, se asegura de que los objetos que se asignan juntos permanezcan juntos en el montón administrado, a fin de conservar su situación.</span><span class="sxs-lookup"><span data-stu-id="32362-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="32362-197">La tendencia a la intrusión (frecuencia y duración) de las recolecciones de elementos no utilizados es el resultado del volumen de asignaciones y la cantidad de memoria que sobrevivió en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="32362-198">El montón considerarse una acumulación de dos montones: el [montón de objetos grandes](large-object-heap.md) y el montón de objetos pequeños.</span><span class="sxs-lookup"><span data-stu-id="32362-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="32362-199">El montón de objetos grandes contiene objetos de 85 000 bytes o más, que normalmente son matrices.</span><span class="sxs-lookup"><span data-stu-id="32362-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="32362-200">Es raro que un objeto de instancia sea sumamente grande.</span><span class="sxs-lookup"><span data-stu-id="32362-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="32362-201">Puede [configurar el tamaño de umbral](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) para que los objetos se dirijan al montón de objetos grandes.</span><span class="sxs-lookup"><span data-stu-id="32362-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="32362-202">Generaciones</span><span class="sxs-lookup"><span data-stu-id="32362-202">Generations</span></span>

<span data-ttu-id="32362-203">El algoritmo de GC se basa en varias consideraciones:</span><span class="sxs-lookup"><span data-stu-id="32362-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="32362-204">Es más rápido compactar la memoria de una parte del montón administrado que la de todo el montón.</span><span class="sxs-lookup"><span data-stu-id="32362-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="32362-205">Los objetos más recientes tienen una duración más corta y los objetos antiguos tienen una duración más larga.</span><span class="sxs-lookup"><span data-stu-id="32362-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="32362-206">Los objetos más recientes suelen estar relacionados unos con otros y la aplicación accede a ellos más o menos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="32362-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="32362-207">La recolección de elementos no utilizados se produce principalmente con la reclamación de objetos de corta duración.</span><span class="sxs-lookup"><span data-stu-id="32362-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="32362-208">Para optimizar el rendimiento del recolector de elementos no utilizados, el montón administrado se divide en tres generaciones: 0, 1 y 2, de forma que pueda manipular por separado los objetos de corta duración y los de larga duración.</span><span class="sxs-lookup"><span data-stu-id="32362-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="32362-209">El recolector de elementos no utilizados almacena los nuevos objetos en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="32362-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="32362-210">Los objetos creados en las primeras etapas de la duración de la aplicación y que sobreviven a las recolecciones se promueven y se almacenan en las generaciones 1 y 2.</span><span class="sxs-lookup"><span data-stu-id="32362-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="32362-211">Como es más rápido compactar una parte del montón administrado que todo el montón, este esquema permite que el recolector de elementos no utilizados libere la memoria en una generación específica en lugar de liberarla para todo el montón administrado cada vez que realiza una recolección.</span><span class="sxs-lookup"><span data-stu-id="32362-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="32362-212">**Generación 0**.</span><span class="sxs-lookup"><span data-stu-id="32362-212">**Generation 0**.</span></span> <span data-ttu-id="32362-213">Es la generación más joven y contiene los objetos de corta duración.</span><span class="sxs-lookup"><span data-stu-id="32362-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="32362-214">Un ejemplo de objeto de corta duración es una variable temporal.</span><span class="sxs-lookup"><span data-stu-id="32362-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="32362-215">La recolección de elementos no utilizados se produce con mayor frecuencia en esta generación.</span><span class="sxs-lookup"><span data-stu-id="32362-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="32362-216">Los objetos recién asignados constituyen una nueva generación de objetos y son colecciones de la generación 0, implícitamente.</span><span class="sxs-lookup"><span data-stu-id="32362-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="32362-217">Sin embargo, si son objetos de gran tamaño, pasan al montón de objetos grandes (LOH), al que en ocasiones se denomina *generación 3*.</span><span class="sxs-lookup"><span data-stu-id="32362-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="32362-218">La generación 3 es una generación física que se recopila de forma lógica como elemento de la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="32362-219">La mayoría de los objetos se reclaman para la recolección de elementos no utilizados en la generación 0 y no sobreviven a la generación siguiente.</span><span class="sxs-lookup"><span data-stu-id="32362-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="32362-220">Si una aplicación trata de crear un objeto cuando la generación 0 está llena, el recolector de elementos no utilizados realiza una recolección en un intento de liberar espacio de direcciones para el objeto.</span><span class="sxs-lookup"><span data-stu-id="32362-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="32362-221">Primero examina los objetos de la generación 0 y no todos los objetos del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="32362-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="32362-222">Una recolección de tan sólo la generación 0 a menudo recupera suficiente memoria para que la aplicación pueda continuar creando objetos.</span><span class="sxs-lookup"><span data-stu-id="32362-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="32362-223">**Generación 1**</span><span class="sxs-lookup"><span data-stu-id="32362-223">**Generation 1**.</span></span> <span data-ttu-id="32362-224">Esta generación contiene objetos de corta duración y sirve como búfer entre los objetos de corta y larga duración.</span><span class="sxs-lookup"><span data-stu-id="32362-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="32362-225">Una vez que el recolector de elementos no utilizados realiza una recolección de la generación 0, compacta la memoria de los objetos que se pueden alcanzar y los promueve a la generación 1.</span><span class="sxs-lookup"><span data-stu-id="32362-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="32362-226">Dado que los objetos que sobreviven a las recolecciones suelen tener una duración más larga, es lógico promoverlos a una generación superior.</span><span class="sxs-lookup"><span data-stu-id="32362-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="32362-227">El recolector de elementos no utilizados no tiene que volver a examinar los objetos de las generaciones 1 y 2 cada vez que realiza una recolección en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="32362-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="32362-228">Si una recolección de la generación 0 no recupera memoria suficiente para que la aplicación pueda crear un nuevo objeto, el recolector de elementos no utilizados puede realizar una recolección de la generación 1 y, después, de la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="32362-229">Los objetos de la generación 1 que sobreviven a las recolecciones se promueven a la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="32362-230">**Generación 2**</span><span class="sxs-lookup"><span data-stu-id="32362-230">**Generation 2**.</span></span> <span data-ttu-id="32362-231">Esta generación contiene los objetos de larga duración.</span><span class="sxs-lookup"><span data-stu-id="32362-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="32362-232">Un ejemplo de objeto de larga duración es un objeto de una aplicación de servidor que contiene datos estáticos que están activos mientras dura el proceso.</span><span class="sxs-lookup"><span data-stu-id="32362-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="32362-233">Los objetos de la generación 2 que sobreviven a una recolección se mantienen en esta generación hasta que en una recolección posterior se determina que no se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="32362-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="32362-234">Los objetos del montón de objetos grandes (a veces denominado *generación 3*) también se recopilan en la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="32362-235">Las recolecciones de elementos no utilizados se producen en generaciones concretas según lo permitan las condiciones.</span><span class="sxs-lookup"><span data-stu-id="32362-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="32362-236">La recolección de una generación significa recolectar los objetos de esa generación y de todas las generaciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="32362-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="32362-237">Una recolección de elementos no utilizados de la generación 2 se denomina también recolección de elementos no utilizados completa, porque reclama los objetos de todas las generaciones (es decir, todos los objetos del montón administrado).</span><span class="sxs-lookup"><span data-stu-id="32362-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="32362-238">Supervivencia y promociones</span><span class="sxs-lookup"><span data-stu-id="32362-238">Survival and promotions</span></span>

<span data-ttu-id="32362-239">Los objetos que no se reclaman en una recolección de elementos no utilizados se denominan supervivientes y se promueven a la generación siguiente:</span><span class="sxs-lookup"><span data-stu-id="32362-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="32362-240">Los objetos que sobreviven a una recolección de elementos no utilizados de la generación 0 se promueven a la generación 1.</span><span class="sxs-lookup"><span data-stu-id="32362-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="32362-241">Los objetos que sobreviven a una recolección de elementos no utilizados de la generación 1 se promueven a la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="32362-242">Los objetos que sobreviven a una recolección de elementos no utilizados de la generación 2 permanecen en la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="32362-243">Cuando el recolector de elementos no utilizados detecta que la tasa de supervivencia es alta en una generación, aumenta el umbral de asignaciones para esa generación.</span><span class="sxs-lookup"><span data-stu-id="32362-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="32362-244">La colección siguiente obtiene un tamaño sustancial de memoria reclamada.</span><span class="sxs-lookup"><span data-stu-id="32362-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="32362-245">El CLR equilibra continuamente dos prioridades: no permitir que el espacio de trabajo de una aplicación adquiera un tamaño excesivo al retrasar la recolección de elementos no utilizados y no permitir que la recolección de elementos no utilizados se ejecute con mucha frecuencia.</span><span class="sxs-lookup"><span data-stu-id="32362-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="32362-246">Generaciones y segmentos efímeros</span><span class="sxs-lookup"><span data-stu-id="32362-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="32362-247">Dado que los objetos de las generaciones 0 y 1 son de corta duración, estas generaciones se denominan *generaciones efímeras*.</span><span class="sxs-lookup"><span data-stu-id="32362-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="32362-248">Las generaciones efímeras se asignan en el segmento de memoria denominado segmento efímero.</span><span class="sxs-lookup"><span data-stu-id="32362-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="32362-249">Cada nuevo segmento adquirido por el recolector de elementos no utilizados se convierte en el nuevo segmento efímero y contiene los objetos que sobrevivieron a una recolección de elementos no utilizados de la generación 0.</span><span class="sxs-lookup"><span data-stu-id="32362-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="32362-250">El segmento efímero anterior se convierte en el nuevo segmento de la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="32362-251">El tamaño del segmento efímero varía según si un sistema es de 32 bits o de 64 bits y del tipo del recolector de elementos no utilizados que se está ejecutando ([GC de servidor o estación de trabajo](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="32362-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="32362-252">En la tabla siguiente se muestran los tamaños predeterminados del segmento efímero.</span><span class="sxs-lookup"><span data-stu-id="32362-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="32362-253">GC de servidor/estación de trabajo</span><span class="sxs-lookup"><span data-stu-id="32362-253">Workstation/server GC</span></span>|<span data-ttu-id="32362-254">32 bits</span><span class="sxs-lookup"><span data-stu-id="32362-254">32-bit</span></span>|<span data-ttu-id="32362-255">64 bits</span><span class="sxs-lookup"><span data-stu-id="32362-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="32362-256">Estación de trabajo de catálogo global</span><span class="sxs-lookup"><span data-stu-id="32362-256">Workstation GC</span></span>|<span data-ttu-id="32362-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="32362-257">16 MB</span></span>|<span data-ttu-id="32362-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="32362-258">256 MB</span></span>|
|<span data-ttu-id="32362-259">Servidor de catálogo global</span><span class="sxs-lookup"><span data-stu-id="32362-259">Server GC</span></span>|<span data-ttu-id="32362-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="32362-260">64 MB</span></span>|<span data-ttu-id="32362-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="32362-261">4 GB</span></span>|
|<span data-ttu-id="32362-262">Servidor de catálogo global con > 4 CPU lógicas</span><span class="sxs-lookup"><span data-stu-id="32362-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="32362-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="32362-263">32 MB</span></span>|<span data-ttu-id="32362-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="32362-264">2 GB</span></span>|
|<span data-ttu-id="32362-265">Servidor de catálogo global con > 8 CPU lógicas</span><span class="sxs-lookup"><span data-stu-id="32362-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="32362-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="32362-266">16 MB</span></span>|<span data-ttu-id="32362-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="32362-267">1 GB</span></span>|

<span data-ttu-id="32362-268">El segmento efímero puede incluir objetos de la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="32362-269">Los objetos de la generación 2 pueden utilizar varios segmentos (tantos como necesite el proceso y la memoria permita).</span><span class="sxs-lookup"><span data-stu-id="32362-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="32362-270">La cantidad de memoria liberada como consecuencia de una recolección de elementos no utilizados efímera se limita al tamaño del segmento efímero.</span><span class="sxs-lookup"><span data-stu-id="32362-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="32362-271">La cantidad de memoria que se libera es proporcional al espacio que ocupaban los objetos muertos.</span><span class="sxs-lookup"><span data-stu-id="32362-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="32362-272">Lo que sucede durante la recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="32362-272">What happens during a garbage collection</span></span>

<span data-ttu-id="32362-273">Una recolección de elementos no utilizados tiene las siguientes fases:</span><span class="sxs-lookup"><span data-stu-id="32362-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="32362-274">Una fase de marcado que busca y crea una lista de todos los objetos activos.</span><span class="sxs-lookup"><span data-stu-id="32362-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="32362-275">Una fase de reubicación, que actualiza las referencias a los objetos que se van a compactar.</span><span class="sxs-lookup"><span data-stu-id="32362-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="32362-276">Una fase de compactación, que reclama el espacio ocupado por los objetos muertos y compacta los objetos supervivientes.</span><span class="sxs-lookup"><span data-stu-id="32362-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="32362-277">En la fase de compactación se mueven los objetos que han sobrevivido a una recolección de elementos no utilizados hacia el extremo más antiguo del segmento.</span><span class="sxs-lookup"><span data-stu-id="32362-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="32362-278">Debido a que las recolecciones de la generación 2 pueden ocupar varios segmentos, los objetos que se promueven a la generación 2 se pueden mover a un segmento anterior.</span><span class="sxs-lookup"><span data-stu-id="32362-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="32362-279">Los supervivientes de las generaciones 1 y 2 se pueden mover a un segmento diferente, porque se promueven a la generación 2.</span><span class="sxs-lookup"><span data-stu-id="32362-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="32362-280">Normalmente, el montón de objetos grandes no se compacta, porque al copiar objetos grandes se reduce el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="32362-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="32362-281">Sin embargo, en .NET Core y en .NET Framework 4.5.1 y versiones posteriores, se puede utilizar la propiedad <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> para compactar el montón de objetos grandes a petición.</span><span class="sxs-lookup"><span data-stu-id="32362-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="32362-282">Además, el montón de objetos grandes se compacta automáticamente cuando se establece un límite máximo mediante la especificación de:</span><span class="sxs-lookup"><span data-stu-id="32362-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="32362-283">un límite de memoria en un contenedor.</span><span class="sxs-lookup"><span data-stu-id="32362-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="32362-284">Las opciones de configuración en tiempo de ejecución [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) o [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent).</span><span class="sxs-lookup"><span data-stu-id="32362-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) run-time configuration options.</span></span>

<span data-ttu-id="32362-285">El recolector de elementos no utilizados utiliza la siguiente información para determinar si los objetos están activos:</span><span class="sxs-lookup"><span data-stu-id="32362-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="32362-286">**Raíces de la pila**.</span><span class="sxs-lookup"><span data-stu-id="32362-286">**Stack roots**.</span></span> <span data-ttu-id="32362-287">Variables de pila proporcionadas por el compilador Just-In-Time (JIT) y el rastreador de pila.</span><span class="sxs-lookup"><span data-stu-id="32362-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="32362-288">Las optimizaciones de JIT pueden prolongar o acortar regiones de código en las que se notifican variables de pila al recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="32362-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="32362-289">**Identificadores de recolección de elementos no utilizados**.</span><span class="sxs-lookup"><span data-stu-id="32362-289">**Garbage collection handles**.</span></span> <span data-ttu-id="32362-290">Identificadores que señalan a objetos administrados y que se pueden asignar mediante código de usuario o mediante Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="32362-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="32362-291">**Datos estáticos**.</span><span class="sxs-lookup"><span data-stu-id="32362-291">**Static data**.</span></span> <span data-ttu-id="32362-292">Objetos estáticos de dominios de aplicación que podrían hacer referencia a otros objetos.</span><span class="sxs-lookup"><span data-stu-id="32362-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="32362-293">Cada dominio de aplicación realiza el seguimiento de sus objetos estáticos.</span><span class="sxs-lookup"><span data-stu-id="32362-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="32362-294">Antes de que iniciarse una recolección de elementos no utilizados, todos los subprocesos administrados se suspenden salvo el subproceso que activó la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="32362-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="32362-295">En la ilustración siguiente se muestra un subproceso que desencadena una recolección de elementos no utilizados, lo que provoca la suspensión de los demás subprocesos.</span><span class="sxs-lookup"><span data-stu-id="32362-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Cuando un subproceso activa una recolección de elementos no utilizados](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="32362-297">Recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="32362-297">Unmanaged resources</span></span>

<span data-ttu-id="32362-298">En el caso de la mayoría de los objetos creados por la aplicación, puede utilizar la recolección de elementos no utilizados para realizar automáticamente las tareas de administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="32362-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="32362-299">Sin embargo, los recursos no administrados requieren una limpieza explícita.</span><span class="sxs-lookup"><span data-stu-id="32362-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="32362-300">El tipo más habitual de recurso no administrado es un objeto que contiene un recurso del sistema operativo, como un identificador de archivo, identificador de ventana o conexión de red.</span><span class="sxs-lookup"><span data-stu-id="32362-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="32362-301">Aunque el recolector de elementos no utilizados puede realizar el seguimiento del período de duración de un objeto administrado que encapsula un recurso no administrado, no tiene un conocimiento específico de cómo limpiar el recurso.</span><span class="sxs-lookup"><span data-stu-id="32362-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="32362-302">Cuando se crea un objeto que encapsula un recurso no administrado, es recomendable proporcionar el código necesario para limpiar dicho recurso en un método público `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="32362-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="32362-303">Si se proporciona un método `Dispose`, se permite que los usuarios del objeto liberen su memoria de manera explícita cuando hayan terminado de usarlo.</span><span class="sxs-lookup"><span data-stu-id="32362-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="32362-304">Si se usa un objeto que encapsula un recurso no administrado, asegúrese de llamar a `Dispose` cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="32362-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="32362-305">También debe proporcionar una forma de liberar los recursos no administrados en el caso de que un consumidor de su tipo olvide llamar a `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="32362-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="32362-306">Puede usar un controlador seguro para encapsular el recurso no administrado o invalidar el método <xref:System.Object.Finalize?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="32362-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="32362-307">Para obtener más información sobre la limpieza de recursos no administrados, vea [Limpieza de recursos no administrados](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="32362-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="32362-308">Vea también</span><span class="sxs-lookup"><span data-stu-id="32362-308">See also</span></span>

- [<span data-ttu-id="32362-309">Recolección de elementos no utilizados de estación de trabajo y de servidor</span><span class="sxs-lookup"><span data-stu-id="32362-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="32362-310">Recolección de elementos no utilizados en segundo plano</span><span class="sxs-lookup"><span data-stu-id="32362-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="32362-311">Opciones de configuración para la recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="32362-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="32362-312">Recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="32362-312">Garbage collection</span></span>](index.md)
