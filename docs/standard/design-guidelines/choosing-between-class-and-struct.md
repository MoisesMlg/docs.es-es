---
title: Elegir entre clases y structs
description: Obtenga información sobre cómo decidir si diseñar un tipo como una clase o diseñar un tipo como un struct. Comprenda cómo se diferencian los tipos de referencia y los tipos de valor en .NET.
ms.date: 10/22/2008
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: b1f3d36f4a9b6e44451a8534ca79fb674071a955
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94821481"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="850d2-104">Elegir entre clases y structs</span><span class="sxs-lookup"><span data-stu-id="850d2-104">Choosing Between Class and Struct</span></span>
<span data-ttu-id="850d2-105">Una de las decisiones de diseño básicas a las que se enfrenta cada diseñador de Marcos es si se debe diseñar un tipo como una clase (un tipo de referencia) o como un struct (un tipo de valor).</span><span class="sxs-lookup"><span data-stu-id="850d2-105">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="850d2-106">Es fundamental comprender mejor las diferencias en el comportamiento de los tipos de referencia y los tipos de valor para tomar esta decisión.</span><span class="sxs-lookup"><span data-stu-id="850d2-106">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="850d2-107">La primera diferencia entre los tipos de referencia y los tipos de valor que se deben tener en cuenta es que los tipos de referencia se asignan en el montón y se recolectan como elementos no utilizados, mientras que los tipos de valor se asignan en la pila o en línea en los tipos contenedores y se desasignan cuando se desenreda la pila o cuando se cancela la asignación del tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="850d2-107">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="850d2-108">Por lo tanto, las asignaciones y desasignaciones de tipos de valor son en general más barata que las asignaciones y desasignaciones de tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="850d2-108">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="850d2-109">A continuación, las matrices de tipos de referencia se asignan fuera de línea, lo que significa que los elementos de la matriz son simplemente referencias a las instancias del tipo de referencia que residen en el montón.</span><span class="sxs-lookup"><span data-stu-id="850d2-109">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="850d2-110">Las matrices de tipos de valor se asignan en línea, lo que significa que los elementos de la matriz son las instancias reales del tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="850d2-110">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="850d2-111">Por lo tanto, las asignaciones y desasignaciones de matrices de tipos de valor son mucho más baratas que las asignaciones y desasignaciones de matrices de tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="850d2-111">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="850d2-112">Además, en la mayoría de los casos, las matrices de tipos de valor presentan una ubicación de referencia mucho mejor.</span><span class="sxs-lookup"><span data-stu-id="850d2-112">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="850d2-113">La diferencia siguiente está relacionada con el uso de memoria.</span><span class="sxs-lookup"><span data-stu-id="850d2-113">The next difference is related to memory usage.</span></span> <span data-ttu-id="850d2-114">Los tipos de valor se aplican a la conversión boxing cuando se convierten a un tipo de referencia o a una de las interfaces que implementan.</span><span class="sxs-lookup"><span data-stu-id="850d2-114">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="850d2-115">Se les aplica la conversión unboxing cuando se convierten de nuevo al tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="850d2-115">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="850d2-116">Dado que los cuadros son objetos que se asignan en el montón y se recolectan como elementos no utilizados, demasiadas conversiones boxing y unboxing pueden tener un impacto negativo en el montón, el recolector de elementos no utilizados y, en última instancia, el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="850d2-116">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="850d2-117">Por el contrario, no se produce ninguna conversión boxing cuando se convierten tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="850d2-117">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="850d2-118">(Para obtener más información, vea [conversión boxing y conversión unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="850d2-118">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="850d2-119">A continuación, las asignaciones de tipos de referencia copian la referencia, mientras que las asignaciones de tipos de valor copian el valor completo.</span><span class="sxs-lookup"><span data-stu-id="850d2-119">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="850d2-120">Por lo tanto, las asignaciones de tipos de referencia grandes son más baratas que las asignaciones de tipos de valores grandes.</span><span class="sxs-lookup"><span data-stu-id="850d2-120">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="850d2-121">Por último, los tipos de referencia se pasan por referencia, mientras que los tipos de valor se pasan por valor.</span><span class="sxs-lookup"><span data-stu-id="850d2-121">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="850d2-122">Los cambios en una instancia de un tipo de referencia afectan a todas las referencias que señalan a la instancia.</span><span class="sxs-lookup"><span data-stu-id="850d2-122">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="850d2-123">Las instancias de tipo de valor se copian cuando se pasan por valor.</span><span class="sxs-lookup"><span data-stu-id="850d2-123">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="850d2-124">Cuando se cambia una instancia de un tipo de valor, no afecta a ninguna de sus copias.</span><span class="sxs-lookup"><span data-stu-id="850d2-124">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="850d2-125">Dado que el usuario no crea las copias explícitamente, pero se crean implícitamente cuando se pasan argumentos o se devuelven valores, los tipos de valor que se pueden cambiar pueden resultar confusos para muchos usuarios.</span><span class="sxs-lookup"><span data-stu-id="850d2-125">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="850d2-126">Por lo tanto, los tipos de valor deben ser inmutables.</span><span class="sxs-lookup"><span data-stu-id="850d2-126">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="850d2-127">Como regla general, la mayoría de los tipos de un marco de trabajo deben ser clases.</span><span class="sxs-lookup"><span data-stu-id="850d2-127">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="850d2-128">Sin embargo, hay algunas situaciones en las que las características de un tipo de valor hacen que sea más apropiado usar estructuras.</span><span class="sxs-lookup"><span data-stu-id="850d2-128">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="850d2-129">✔️ considere la posibilidad de definir un struct en lugar de una clase si las instancias del tipo son pequeñas y suelen ser de corta duración o se incrustan normalmente en otros objetos.</span><span class="sxs-lookup"><span data-stu-id="850d2-129">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="850d2-130">❌ Evite definir un struct a menos que el tipo tenga todas las características siguientes:</span><span class="sxs-lookup"><span data-stu-id="850d2-130">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="850d2-131">Representa lógicamente un valor único, similar a los tipos primitivos ( `int` , `double` , etc.).</span><span class="sxs-lookup"><span data-stu-id="850d2-131">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="850d2-132">Tiene un tamaño de instancia inferior a 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="850d2-132">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="850d2-133">Es inmutable.</span><span class="sxs-lookup"><span data-stu-id="850d2-133">It is immutable.</span></span>

- <span data-ttu-id="850d2-134">No será necesario aplicar la conversión boxing a menudo.</span><span class="sxs-lookup"><span data-stu-id="850d2-134">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="850d2-135">En todos los demás casos, debe definir los tipos como clases.</span><span class="sxs-lookup"><span data-stu-id="850d2-135">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="850d2-136">*Partes © 2005, 2009 Microsoft Corporation. Todos los derechos reservados.*</span><span class="sxs-lookup"><span data-stu-id="850d2-136">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="850d2-137">*Material reimpreso con el consentimiento de Pearson Education, Inc. y extraído de [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) (Instrucciones de diseño de .NET Framework: convenciones, expresiones y patrones para bibliotecas .NET reutilizables, 2.ª edición), de Krzysztof Cwalina y Brad Abrams, publicado el 22 de octubre de 2008 por Addison-Wesley Professional como parte de la serie Microsoft Windows Development.*</span><span class="sxs-lookup"><span data-stu-id="850d2-137">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="850d2-138">Consulte también</span><span class="sxs-lookup"><span data-stu-id="850d2-138">See also</span></span>

- [<span data-ttu-id="850d2-139">Instrucciones de diseño de tipos</span><span class="sxs-lookup"><span data-stu-id="850d2-139">Type Design Guidelines</span></span>](type.md)
- [<span data-ttu-id="850d2-140">Directrices de diseño de marco</span><span class="sxs-lookup"><span data-stu-id="850d2-140">Framework Design Guidelines</span></span>](index.md)
