---
title: Semaphore y SemaphoreSlim
description: Descubra Semaphore y SemaphoreSlim. La clase Semaphore es un contenedor fino alrededor del objeto Semaphore de Win32. La clase SemaphoreSlim es un semáforo rápido y ligero.
ms.date: 03/30/2017
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: bda88012fde60481d8870f701e98924acdeeb5a2
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94817150"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="d414c-105">Semaphore y SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="d414c-105">Semaphore and SemaphoreSlim</span></span>

<span data-ttu-id="d414c-106">La clase <xref:System.Threading.Semaphore?displayProperty=nameWithType> representa un semáforo local o con nombre (para todo el sistema).</span><span class="sxs-lookup"><span data-stu-id="d414c-106">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="d414c-107">Se trata de un contenedor fino alrededor del objeto semáforo de Win32.</span><span class="sxs-lookup"><span data-stu-id="d414c-107">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="d414c-108">Los semáforos de Win32 son semáforos de recuento, que se pueden utilizar para controlar el acceso a un grupo de recursos.</span><span class="sxs-lookup"><span data-stu-id="d414c-108">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="d414c-109">La clase <xref:System.Threading.SemaphoreSlim> representa un semáforo ligero y rápido que se puede usar para esperar en un único proceso cuando se supone que los tiempos de espera serán muy cortos.</span><span class="sxs-lookup"><span data-stu-id="d414c-109">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="d414c-110"><xref:System.Threading.SemaphoreSlim> se basa en la medida de lo posible en las primitivas de sincronización proporcionadas por Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="d414c-110"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="d414c-111">Sin embargo, también proporciona identificadores de espera basados en kernel e inicializados de forma diferida a fin permitir la espera en varios semáforos.</span><span class="sxs-lookup"><span data-stu-id="d414c-111">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="d414c-112"><xref:System.Threading.SemaphoreSlim> también admite el uso de tokens de cancelación, pero no los semáforos con nombre ni el uso de un identificador de espera para sincronización.</span><span class="sxs-lookup"><span data-stu-id="d414c-112"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="d414c-113">Administrar un recurso limitado</span><span class="sxs-lookup"><span data-stu-id="d414c-113">Managing a Limited Resource</span></span>  
 <span data-ttu-id="d414c-114">Los subprocesos entran en el semáforo mediante la llamada al método <xref:System.Threading.WaitHandle.WaitOne%2A>, heredado de la clase <xref:System.Threading.WaitHandle>, si se trata de un objeto <xref:System.Threading.Semaphore?displayProperty=nameWithType>, o al método <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType>, si se trata de un objeto <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="d414c-114">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="d414c-115">Cuando se devuelve la llamada, disminuye el recuento en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="d414c-115">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="d414c-116">Cuando un subproceso solicita la entrada y el recuento es cero, el subproceso se bloquea.</span><span class="sxs-lookup"><span data-stu-id="d414c-116">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="d414c-117">Cuando los subprocesos liberan el semáforo mediante la llamada al método <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>, los subprocesos bloqueados pueden entrar.</span><span class="sxs-lookup"><span data-stu-id="d414c-117">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="d414c-118">No hay ningún orden garantizado, como “primero en entrar, primero en salir” (FIFO) o “último en entrar, primero en salir” (LIFO), para que los subprocesos bloqueados entren en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="d414c-118">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="d414c-119">Un subproceso puede entrar varias veces en el semáforo mediante la llamada al método <xref:System.Threading.Semaphore?displayProperty=nameWithType> del objeto <xref:System.Threading.WaitHandle.WaitOne%2A> o al método <xref:System.Threading.SemaphoreSlim> del objeto <xref:System.Threading.SemaphoreSlim.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d414c-119">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="d414c-120">Para liberar el semáforo, el subproceso puede llamar el mismo número de veces a la sobrecarga de un método <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType>, o llamar a la sobrecarga del método <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> y especificar el número de entradas que se liberan.</span><span class="sxs-lookup"><span data-stu-id="d414c-120">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="d414c-121">Los semáforos y la identidad del subproceso</span><span class="sxs-lookup"><span data-stu-id="d414c-121">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="d414c-122">Los dos tipos de semáforo no exigen la identidad del subproceso en las llamadas a los métodos <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A> y <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d414c-122">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="d414c-123">Por ejemplo, un escenario de uso común para semáforos implica un subproceso productor y un subproceso consumidor; uno de esos subprocesos siempre incrementa el recuento del semáforo y el otro siempre lo reduce.</span><span class="sxs-lookup"><span data-stu-id="d414c-123">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="d414c-124">Es responsabilidad del programador garantizar que un subproceso no libere el semáforo demasiadas veces.</span><span class="sxs-lookup"><span data-stu-id="d414c-124">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="d414c-125">Por ejemplo, supongamos que un semáforo tiene un recuento máximo de dos y que los subprocesos A y B entran el semáforo.</span><span class="sxs-lookup"><span data-stu-id="d414c-125">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="d414c-126">Si un error de programación en el subproceso B hace que llame a `Release` dos veces, ambas llamadas tendrán éxito.</span><span class="sxs-lookup"><span data-stu-id="d414c-126">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="d414c-127">El recuento del semáforo está lleno y cuando el subproceso A finalmente llama a `Release`, se genera <xref:System.Threading.SemaphoreFullException>.</span><span class="sxs-lookup"><span data-stu-id="d414c-127">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="d414c-128">Semáforos con nombre</span><span class="sxs-lookup"><span data-stu-id="d414c-128">Named Semaphores</span></span>  
 <span data-ttu-id="d414c-129">El sistema operativo Windows permite que los semáforos tengan nombres.</span><span class="sxs-lookup"><span data-stu-id="d414c-129">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="d414c-130">Un semáforo con nombre abarca todo el sistema.</span><span class="sxs-lookup"><span data-stu-id="d414c-130">A named semaphore is system wide.</span></span> <span data-ttu-id="d414c-131">Es decir, una vez creado el semáforo con nombre, es visible para todos los subprocesos de todos los procesos.</span><span class="sxs-lookup"><span data-stu-id="d414c-131">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="d414c-132">Por lo tanto, el semáforo con nombre puede utilizarse para sincronizar tanto las actividades de procesos como las de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d414c-132">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="d414c-133">Puede crear un objeto <xref:System.Threading.Semaphore> que represente un semáforo de sistema con nombre mediante el uso de uno de los constructores que especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="d414c-133">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d414c-134">Dado que los semáforos con nombre abarcan todo el sistema, es posible tener varios objetos <xref:System.Threading.Semaphore> que representan el mismo semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="d414c-134">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="d414c-135">Cada vez que llama a un constructor o al método <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>, se crea un nuevo objeto <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="d414c-135">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="d414c-136">Si se especifica el mismo nombre repetidamente, se crean varios objetos que representan el mismo semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="d414c-136">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="d414c-137">Tenga cuidado al utilizar los semáforos con nombre.</span><span class="sxs-lookup"><span data-stu-id="d414c-137">Be careful when you use named semaphores.</span></span> <span data-ttu-id="d414c-138">Dado que abarcan todo el sistema, otro proceso que utilice el mismo nombre puede entrar en el semáforo inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="d414c-138">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="d414c-139">Si hubiera código malintencionado ejecutándose en el mismo equipo, dicho código podría utilizar esto como base de un ataque de denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="d414c-139">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="d414c-140">Utilice la seguridad de control de acceso para proteger un objeto <xref:System.Threading.Semaphore> que representa un semáforo con nombre, a poder ser mediante un constructor que especifique un objeto <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d414c-140">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="d414c-141">También puede aplicar la seguridad de control de acceso mediante el método <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>, pero esto deja una ventana de vulnerabilidad entre el momento en que se crea el semáforo y el momento en que se protege.</span><span class="sxs-lookup"><span data-stu-id="d414c-141">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="d414c-142">Proteger los semáforos con seguridad de control de acceso ayuda a evitar ataques malintencionados, pero no soluciona el problema de conflictos involuntarios de nombres.</span><span class="sxs-lookup"><span data-stu-id="d414c-142">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d414c-143">Vea también</span><span class="sxs-lookup"><span data-stu-id="d414c-143">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="d414c-144">Objetos y características de subprocesos</span><span class="sxs-lookup"><span data-stu-id="d414c-144">Threading Objects and Features</span></span>](threading-objects-and-features.md)
