---
title: Información general sobre las primitivas de sincronización
description: Obtenga información sobre las primitivas de sincronización de subprocesos .NET utilizadas para sincronizar el acceso a un recurso compartido o controlar la interacción de subprocesos
ms.date: 10/01/2018
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 9dfaaa6050cc6e9a6b86f991aa6d2ce2a815959a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819661"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="e3382-103">Información general sobre las primitivas de sincronización</span><span class="sxs-lookup"><span data-stu-id="e3382-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="e3382-104">.NET proporciona una variedad de tipos que puede usar para sincronizar el acceso a un recurso compartido o coordinar la interacción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e3382-105">Use la misma instancia primitiva de sincronización para proteger el acceso de un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="e3382-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="e3382-106">Si usa instancias primitivas de sincronización distintas para proteger el mismo recurso, se evitará la protección proporcionada por una primitiva de sincronización.</span><span class="sxs-lookup"><span data-stu-id="e3382-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="e3382-107">Clase WaitHandle y tipos de sincronización ligeros</span><span class="sxs-lookup"><span data-stu-id="e3382-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="e3382-108">Varias primitivas de sincronización de .NET derivan de la clase <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, que encapsula un controlador de sincronización del sistema operativo nativo y usa un mecanismo de señalización para la interacción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="e3382-109">Esas clases incluyen:</span><span class="sxs-lookup"><span data-stu-id="e3382-109">Those classes include:</span></span>

- <span data-ttu-id="e3382-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, que concede acceso exclusivo a un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="e3382-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="e3382-111">El estado de una exclusión mutua se señala si no es propiedad de ningún subproceso.</span><span class="sxs-lookup"><span data-stu-id="e3382-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="e3382-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, que limita el número de subprocesos que pueden tener acceso a un recurso compartido o grupo de recursos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="e3382-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="e3382-113">El estado de un semáforo se establece como señalizado cuando su recuento es mayor que cero y como no señalizado cuando su recuento es cero.</span><span class="sxs-lookup"><span data-stu-id="e3382-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="e3382-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, que representa un evento de sincronización de subprocesos y puede estar en un estado señalizado o no señalizado.</span><span class="sxs-lookup"><span data-stu-id="e3382-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="e3382-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que se deriva de <xref:System.Threading.EventWaitHandle> y, cuando está señalizada, se restablece automáticamente a un estado no señalizado después de liberar un subproceso en espera único.</span><span class="sxs-lookup"><span data-stu-id="e3382-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="e3382-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que se deriva de <xref:System.Threading.EventWaitHandle> y, cuando está señalizado, permanece en un estado señalizado hasta que se llama al método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3382-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="e3382-117">En .NET Framework, como <xref:System.Threading.WaitHandle> deriva de <xref:System.MarshalByRefObject?displayProperty=nameWithType>, estos tipos se pueden usar para sincronizar las actividades de subprocesos entre los límites del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="e3382-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="e3382-118">En .NET Framework, y .NET Core y .NET 5 y versiones posteriores, algunos de estos tipos pueden representar controladores de sincronización del sistema con nombre, que son visibles en todo el sistema operativo y se pueden usar para la sincronización entre procesos:</span><span class="sxs-lookup"><span data-stu-id="e3382-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="e3382-119"><xref:System.Threading.Semaphore> (en Windows)</span><span class="sxs-lookup"><span data-stu-id="e3382-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="e3382-120"><xref:System.Threading.EventWaitHandle> (en Windows)</span><span class="sxs-lookup"><span data-stu-id="e3382-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="e3382-121">Para más información, vea la referencia de API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="e3382-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="e3382-122">Los tipos de sincronización ligeros no se basan en los controladores del sistema operativo subyacentes y suelen proporcionar un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="e3382-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="e3382-123">Sin embargo, no se pueden usar para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="e3382-124">Utilice esos tipos para la sincronización de subprocesos dentro de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="e3382-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="e3382-125">Algunos de esos tipos son alternativas a los tipos derivados de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="e3382-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e3382-126">Por ejemplo, <xref:System.Threading.SemaphoreSlim> es una alternativa ligera a <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="e3382-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="e3382-127">Sincronización del acceso a un recurso compartido</span><span class="sxs-lookup"><span data-stu-id="e3382-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="e3382-128">.NET proporciona un intervalo de primitivas de sincronización para controlar el acceso a un recurso compartido por varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="e3382-129">Monitor (clase)</span><span class="sxs-lookup"><span data-stu-id="e3382-129">Monitor class</span></span>

<span data-ttu-id="e3382-130">La clase <xref:System.Threading.Monitor?displayProperty=nameWithType> concede acceso mutuamente exclusivo a un recurso compartido mediante la adquisición o liberación de un bloqueo en el objeto que identifica el recurso.</span><span class="sxs-lookup"><span data-stu-id="e3382-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="e3382-131">Mientras se mantiene un bloqueo, el subproceso que lo mantiene puede volver a adquirir y liberar dicho bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="e3382-132">Ningún otro subproceso puede adquirir el bloqueo y el método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> espera hasta que el bloqueo se libera.</span><span class="sxs-lookup"><span data-stu-id="e3382-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="e3382-133">El método <xref:System.Threading.Monitor.Enter%2A> adquiere un bloqueo liberado.</span><span class="sxs-lookup"><span data-stu-id="e3382-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="e3382-134">También puede usar el método <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> para especificar la cantidad de tiempo durante el cual un subproceso intenta adquirir un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="e3382-135">Dado que la clase <xref:System.Threading.Monitor> tiene afinidad de subproceso, el subproceso que adquirió un bloqueo debe liberarlo mediante una llamada al método <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3382-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="e3382-136">Puede coordinar la interacción de subprocesos que adquieren un bloqueo en el mismo objeto mediante los métodos <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> y <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3382-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="e3382-137">Para más información, vea la referencia de API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="e3382-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="e3382-138">Use la instrucción [lock](../../csharp/language-reference/keywords/lock-statement.md) en C# y la instrucción [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) en Visual Basic para sincronizar el acceso a un recurso compartido en lugar de usar la clase <xref:System.Threading.Monitor> directamente.</span><span class="sxs-lookup"><span data-stu-id="e3382-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="e3382-139">Esas instrucciones se implementan mediante los métodos <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, y usa un bloqueo `try…finally` para asegurarse de que se libere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="e3382-140">Mutex (clase)</span><span class="sxs-lookup"><span data-stu-id="e3382-140">Mutex class</span></span>

<span data-ttu-id="e3382-141">La clase <xref:System.Threading.Mutex?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acceso exclusivo a un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="e3382-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="e3382-142">Utilice una de las sobrecargas del método [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) para solicitar la propiedad de una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="e3382-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="e3382-143">Al igual que <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> tiene afinidad de subproceso y el subproceso que adquirió una exclusión mutua debe liberarlo llamando al método <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3382-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="e3382-144">A diferencia de <xref:System.Threading.Monitor>, la clase <xref:System.Threading.Mutex> puede usarse para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="e3382-145">Para ello, use una exclusión mutua con nombre, que es visible en todo el sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="e3382-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="e3382-146">Para crear una instancia de la exclusión mutua con nombre, use un [constructor de exclusión mutua](<xref:System.Threading.Mutex.%23ctor%2A>) que especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="e3382-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="e3382-147">También se puede llamar al método <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> para abrir una exclusión mutua del sistema existente.</span><span class="sxs-lookup"><span data-stu-id="e3382-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="e3382-148">Para más información, vea el artículo [Mutexes](mutexes.md) y la referencia de API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="e3382-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="e3382-149">SpinLock (estructura)</span><span class="sxs-lookup"><span data-stu-id="e3382-149">SpinLock structure</span></span>

<span data-ttu-id="e3382-150">La estructura <xref:System.Threading.SpinLock?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acceso exclusivo a un recurso compartido en función de la disponibilidad de un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="e3382-151">Cuando <xref:System.Threading.SpinLock> intenta adquirir un bloqueo que no está disponible, espera en un bucle, y realiza comprobaciones repetidamente hasta que dicho bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="e3382-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="e3382-152">Para más información sobre las ventajas e inconvenientes del uso de un bloqueo de giro, vea el artículo [SpinLock](spinlock.md) y la referencia de API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="e3382-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="e3382-153">ReaderWriterLockSlim (clase)</span><span class="sxs-lookup"><span data-stu-id="e3382-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="e3382-154">La clase <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> concede acceso exclusivo a un recurso compartido para escritura y permite que varios subprocesos accedan al recurso simultáneamente para lectura.</span><span class="sxs-lookup"><span data-stu-id="e3382-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="e3382-155">Es posible que desee utilizar <xref:System.Threading.ReaderWriterLockSlim> para sincronizar el acceso a una estructura de datos compartida que admita operaciones de lectura seguras para subprocesos, pero que requiera acceso exclusivo para realizar la operación de escritura.</span><span class="sxs-lookup"><span data-stu-id="e3382-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="e3382-156">Cuando un subproceso solicita acceso exclusivo (por ejemplo, llamando al método <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), las solicitudes posteriores del lector y el escritor se bloquean hasta que todos los lectores existentes han salido del bloqueo y el escritor ha entrado y salido de dicho bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="e3382-157">Para más información, vea la referencia de API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="e3382-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="e3382-158">Semaphore y SemaphoreSlim (clases)</span><span class="sxs-lookup"><span data-stu-id="e3382-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="e3382-159">Las clases <xref:System.Threading.Semaphore?displayProperty=nameWithType> y <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> limitan el número de subprocesos que pueden tener acceso a un recurso compartido o grupo de recursos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="e3382-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="e3382-160">Los demás subprocesos que soliciten el recurso esperarán hasta que un subproceso libere el semáforo.</span><span class="sxs-lookup"><span data-stu-id="e3382-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="e3382-161">Dado que el semáforo no tiene afinidad de subproceso, un subproceso puede adquirir el semáforo y otro puede liberarlo.</span><span class="sxs-lookup"><span data-stu-id="e3382-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="e3382-162"><xref:System.Threading.SemaphoreSlim> es una alternativa ligera a <xref:System.Threading.Semaphore> y solo se puede usar para la sincronización dentro de un límite de un único proceso.</span><span class="sxs-lookup"><span data-stu-id="e3382-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="e3382-163">En Windows, puede usar <xref:System.Threading.Semaphore> para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="e3382-164">Para hacerlo, cree una instancia de <xref:System.Threading.Semaphore> que represente un semáforo de sistema con nombre mediante el uso de uno de los [constructores Semaphore](<xref:System.Threading.Semaphore.%23ctor%2A>) que especifica un nombre o el método <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3382-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e3382-165"><xref:System.Threading.SemaphoreSlim> no es compatible con los semáforos con nombre del sistema.</span><span class="sxs-lookup"><span data-stu-id="e3382-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="e3382-166">Para más información, consulte el artículo [Semaphore y SemaphoreSlim](semaphore-and-semaphoreslim.md) y la referencia de API <xref:System.Threading.Semaphore> o <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="e3382-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="e3382-167">Interacción de subprocesos o señalización</span><span class="sxs-lookup"><span data-stu-id="e3382-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="e3382-168">Interacción de subprocesos (o señalización de subprocesos) significa que un subproceso debe esperar la notificación o una señal de uno o varios subprocesos para poder continuar.</span><span class="sxs-lookup"><span data-stu-id="e3382-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="e3382-169">Por ejemplo, si un subproceso A llama al método <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> del subproceso B, un subproceso A se bloquea hasta que el subproceso B finaliza.</span><span class="sxs-lookup"><span data-stu-id="e3382-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="e3382-170">Las primitivas de sincronización descritas en la sección anterior proporcionan un mecanismo diferente para la señalización: al liberar un bloqueo, un subproceso notifica a otro subproceso que puede continuar adquiriendo el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="e3382-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="e3382-171">En esta sección se describen construcciones adicionales de señalización proporcionados por. NET.</span><span class="sxs-lookup"><span data-stu-id="e3382-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="e3382-172">EventWaitHandle, AutoResetEvent, ManualResetEvent y ManualResetEventSlim (clases)</span><span class="sxs-lookup"><span data-stu-id="e3382-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="e3382-173">La clase <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> representa un evento de sincronización de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="e3382-174">Un evento de sincronización puede estar en un estado de no señalizado o señalizado.</span><span class="sxs-lookup"><span data-stu-id="e3382-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="e3382-175">Cuando el estado de un evento es señalizado, un subproceso que llama a la sobrecarga <xref:System.Threading.WaitHandle.WaitOne%2A?> del evento se bloquea hasta que un evento se señaliza.</span><span class="sxs-lookup"><span data-stu-id="e3382-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="e3382-176">El método <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> establece el estado de un evento en señalizado.</span><span class="sxs-lookup"><span data-stu-id="e3382-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="e3382-177">El comportamiento de una clase <xref:System.Threading.EventWaitHandle> que se haya señalizado depende de su modo de restablecimiento:</span><span class="sxs-lookup"><span data-stu-id="e3382-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="e3382-178">Una clase <xref:System.Threading.EventWaitHandle> creada con la marca <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> se restablece automáticamente después de liberar un subproceso en espera único.</span><span class="sxs-lookup"><span data-stu-id="e3382-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="e3382-179">Es como un torniquete que permite solo un subproceso cada vez que se señaliza.</span><span class="sxs-lookup"><span data-stu-id="e3382-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="e3382-180">La clase <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa ese comportamiento.</span><span class="sxs-lookup"><span data-stu-id="e3382-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="e3382-181">Una clase <xref:System.Threading.EventWaitHandle> creada con la marca <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> permanece señalizada hasta que se llama a su método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3382-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="e3382-182">Es como una puerta que está cerrada hasta que se señaliza y a partir de entonces permanece abierta hasta que alguien la cierra.</span><span class="sxs-lookup"><span data-stu-id="e3382-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="e3382-183">La clase <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa ese comportamiento.</span><span class="sxs-lookup"><span data-stu-id="e3382-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="e3382-184">La clase <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> es una alternativa ligera a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="e3382-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="e3382-185">En Windows, puede usar <xref:System.Threading.EventWaitHandle> para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="e3382-186">Para hacerlo, cree una instancia de <xref:System.Threading.EventWaitHandle> que represente un semáforo de sincronización del sistema con nombre mediante el uso de uno de los [constructores EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) que especifica un nombre o el método <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3382-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="e3382-187">Para obtener más información, consulte el artículo [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="e3382-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="e3382-188">Para la referencia de API, consulte <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> y <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="e3382-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="e3382-189">Clase CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="e3382-189">CountdownEvent class</span></span>

<span data-ttu-id="e3382-190">La clase <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> representa un evento que se establece cuando su recuento es cero.</span><span class="sxs-lookup"><span data-stu-id="e3382-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="e3382-191">Mientras <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> sea mayor que cero, un subproceso que llama a <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> está bloqueado.</span><span class="sxs-lookup"><span data-stu-id="e3382-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="e3382-192">Llame a <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> para reducir el recuento de un evento.</span><span class="sxs-lookup"><span data-stu-id="e3382-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="e3382-193">En contraposición a <xref:System.Threading.ManualResetEvent> o <xref:System.Threading.ManualResetEventSlim>, que puede usar para desbloquear varios subprocesos con una señal de un subproceso, puede usar <xref:System.Threading.CountdownEvent> para desbloquear uno o varios subprocesos con las señales de varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="e3382-194">Para más información, vea el artículo [CountdownEvent](countdownevent.md) y la referencia de API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="e3382-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="e3382-195">Barrier (clase)</span><span class="sxs-lookup"><span data-stu-id="e3382-195">Barrier class</span></span>

<span data-ttu-id="e3382-196">La clase <xref:System.Threading.Barrier?displayProperty=nameWithType> representa una barrera de ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e3382-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="e3382-197">Un subproceso que llama al método <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> indica que ha alcanzado la barrera y espera hasta que otros subprocesos participantes alcancen la barrera.</span><span class="sxs-lookup"><span data-stu-id="e3382-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="e3382-198">Cuando todos los subprocesos participantes alcancen la barrera, continúan y la barrera se restablece y se puede volver a usar.</span><span class="sxs-lookup"><span data-stu-id="e3382-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="e3382-199">Puede usar <xref:System.Threading.Barrier> cuando uno o más subprocesos requieren los resultados de otros subprocesos antes de continuar con la siguiente fase del cálculo.</span><span class="sxs-lookup"><span data-stu-id="e3382-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="e3382-200">Para más información, vea el artículo [Barrier](barrier.md) y la referencia de API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="e3382-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="e3382-201">Interlocked (clase)</span><span class="sxs-lookup"><span data-stu-id="e3382-201">Interlocked class</span></span>

<span data-ttu-id="e3382-202">La clase <xref:System.Threading.Interlocked?displayProperty=nameWithType> proporciona métodos estáticos que realizan operaciones atómicas simples en una variable.</span><span class="sxs-lookup"><span data-stu-id="e3382-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="e3382-203">Esas operaciones atómicas incluyen la adición, el incremento y el decremento, el intercambio y el intercambio condicional que depende de una comparación, y la operación de lectura de un valor entero de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="e3382-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="e3382-204">Para más información, vea la referencia de API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="e3382-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="e3382-205">SpinWait (estructura)</span><span class="sxs-lookup"><span data-stu-id="e3382-205">SpinWait structure</span></span>

<span data-ttu-id="e3382-206">La estructura <xref:System.Threading.SpinWait?displayProperty=nameWithType> proporciona compatibilidad para la espera basada en ciclos.</span><span class="sxs-lookup"><span data-stu-id="e3382-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="e3382-207">Puede que le interese utilizarla cuando un subproceso tiene que esperar a que se señalice un evento o se cumpla una condición, pero cuando el tiempo de espera real deba ser menor que el tiempo de espera necesario usando un identificador de espera o bloqueando de otro modo el subproceso.</span><span class="sxs-lookup"><span data-stu-id="e3382-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="e3382-208">Si usa <xref:System.Threading.SpinWait>, puede especificar un breve período de tiempo para girar durante la espera y después ceder (por ejemplo, esperando o entrando en modo de suspensión) solo si la condición no se cumplió en el tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="e3382-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="e3382-209">Para más información, vea el artículo [SpinWait](spinwait.md) y la referencia de API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="e3382-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="e3382-210">Vea también</span><span class="sxs-lookup"><span data-stu-id="e3382-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="e3382-211">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="e3382-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="e3382-212">Objetos y características de subprocesos</span><span class="sxs-lookup"><span data-stu-id="e3382-212">Threading objects and features</span></span>](threading-objects-and-features.md)
