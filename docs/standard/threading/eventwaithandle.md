---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723789"
---
# <a name="eventwaithandle"></a><span data-ttu-id="0e49a-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="0e49a-102">EventWaitHandle</span></span>

<span data-ttu-id="0e49a-103">La clase <xref:System.Threading.EventWaitHandle> permite que los subprocesos se comuniquen entre sí mediante señalización y espera de señales.</span><span class="sxs-lookup"><span data-stu-id="0e49a-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="0e49a-104">Los identificadores de espera de eventos (también denominados simplemente como eventos) son identificadores de espera que se pueden señalar con el fin de liberar uno o varios subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="0e49a-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="0e49a-105">Cuando se envía una señal, se restablece un identificador de espera de evento de forma manual o automática.</span><span class="sxs-lookup"><span data-stu-id="0e49a-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="0e49a-106">La clase <xref:System.Threading.EventWaitHandle> puede representar cualquier identificador de espera de evento local (evento local) o identificador de espera de evento del sistema con nombre (denominado evento o evento del sistema y visible para todos los procesos).</span><span class="sxs-lookup"><span data-stu-id="0e49a-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e49a-107">Los identificadores de espera de evento no son [eventos](../events/index.md) de .NET.</span><span class="sxs-lookup"><span data-stu-id="0e49a-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="0e49a-108">No existen delegados ni controladores de eventos implicados.</span><span class="sxs-lookup"><span data-stu-id="0e49a-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="0e49a-109">Se utiliza el término "evento" para describirlos porque tradicionalmente se ha hecho referencia a ellos como eventos del sistema operativo y porque el acto de señalar el indicador de espera indica a los subprocesos en espera que se ha producido un evento.</span><span class="sxs-lookup"><span data-stu-id="0e49a-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="0e49a-110">Ambos identificadores de espera de evento local y con nombre usan objetos de sincronización del sistema, protegidos por contenedores <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> para garantizar la liberación de los recursos.</span><span class="sxs-lookup"><span data-stu-id="0e49a-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="0e49a-111">Puede usar el método <xref:System.Threading.WaitHandle.Dispose%2A> para liberar los recursos inmediatamente cuando haya terminado de utilizar el objeto.</span><span class="sxs-lookup"><span data-stu-id="0e49a-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="0e49a-112">Identificadores de espera de evento que se restablecen automáticamente</span><span class="sxs-lookup"><span data-stu-id="0e49a-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="0e49a-113">Cree un evento de restablecimiento automático definiendo <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> al crear el objeto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="0e49a-114">Como su nombre implica, este evento de sincronización se restablece automáticamente cuando se señala, después de liberar un único subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="0e49a-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="0e49a-115">Señale el evento mediante una llamada a su método <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="0e49a-116">Los eventos de restablecimiento automático se utilizan normalmente para proporcionar acceso exclusivo a un recurso a un único subproceso cada vez.</span><span class="sxs-lookup"><span data-stu-id="0e49a-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="0e49a-117">Un subproceso solicita el recurso mediante una llamada al método <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="0e49a-118">Si ningún otro subproceso contiene el identificador de espera, el método devuelve `true` y el subproceso que realiza la llamada tiene el control del recurso.</span><span class="sxs-lookup"><span data-stu-id="0e49a-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="0e49a-119">Al igual que con todos los mecanismos de sincronización, debe asegurarse de que todas las rutas de acceso de código esperen al identificador de espera adecuado antes de obtener acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="0e49a-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="0e49a-120">La sincronización de subprocesos es cooperativa.</span><span class="sxs-lookup"><span data-stu-id="0e49a-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="0e49a-121">Si un evento de restablecimiento automático se señaliza cuando no hay ningún subproceso en espera, permanece señalado hasta que un subproceso intenta esperar en él.</span><span class="sxs-lookup"><span data-stu-id="0e49a-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="0e49a-122">El evento libera el subproceso y lo restablece inmediatamente, bloqueando los subprocesos subsiguientes.</span><span class="sxs-lookup"><span data-stu-id="0e49a-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="0e49a-123">Identificadores de espera de evento que se restablecen manualmente</span><span class="sxs-lookup"><span data-stu-id="0e49a-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="0e49a-124">Cree un evento de restablecimiento manual definiendo <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> al crear el objeto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="0e49a-125">Como su nombre implica, este evento de sincronización debe restablecerse manualmente después de que se haya señalado.</span><span class="sxs-lookup"><span data-stu-id="0e49a-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="0e49a-126">Hasta que se restablezca, mediante una llamada a su método <xref:System.Threading.EventWaitHandle.Reset%2A>, los subprocesos que esperan en el identificador de evento se ejecutarán inmediatamente, sin bloquearse.</span><span class="sxs-lookup"><span data-stu-id="0e49a-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="0e49a-127">Un evento de restablecimiento manual funciona como la puerta de un establo.</span><span class="sxs-lookup"><span data-stu-id="0e49a-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="0e49a-128">Si no se señala un evento, los subprocesos que esperan en él se bloquean, como los caballos de un establo.</span><span class="sxs-lookup"><span data-stu-id="0e49a-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="0e49a-129">Cuando se señala el evento, mediante una llamada a su método <xref:System.Threading.EventWaitHandle.Set%2A>, todos los subprocesos en espera pueden continuar libremente.</span><span class="sxs-lookup"><span data-stu-id="0e49a-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="0e49a-130">El evento permanece señalado hasta que se llama a su método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="0e49a-131">Esto hace que el evento de restablecimiento manual sea una forma ideal de retener subprocesos que necesitan esperar hasta que un subproceso finaliza una tarea.</span><span class="sxs-lookup"><span data-stu-id="0e49a-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="0e49a-132">Como los caballos cuando dejan un establo, lleva tiempo que el sistema operativo programe los subprocesos liberados y reanudar su ejecución.</span><span class="sxs-lookup"><span data-stu-id="0e49a-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="0e49a-133">Si se llama al método <xref:System.Threading.EventWaitHandle.Reset%2A> antes de que se reanude la ejecución de los subprocesos, los subprocesos restantes se vuelven a bloquear.</span><span class="sxs-lookup"><span data-stu-id="0e49a-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="0e49a-134">Los subprocesos que se reanudan y los subprocesos que se bloquean es una cuestión que depende de factores aleatorios, como la carga del sistema, el número de subprocesos que esperan al programador, etc.</span><span class="sxs-lookup"><span data-stu-id="0e49a-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="0e49a-135">Esto no plantea ningún problema si el subproceso que señala el evento termina después de la señalización, que es el patrón de uso más común.</span><span class="sxs-lookup"><span data-stu-id="0e49a-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="0e49a-136">Si desea que el subproceso que señaló el evento inicie una nueva tarea después de que todos los subprocesos en espera se hayan reanudado, debe bloquearlo hasta que todos los subprocesos en espera se hayan reanudado.</span><span class="sxs-lookup"><span data-stu-id="0e49a-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="0e49a-137">En caso contrario, se produce una condición de carrera y el comportamiento del código es imprevisible.</span><span class="sxs-lookup"><span data-stu-id="0e49a-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="0e49a-138">Características comunes de eventos automáticos y manuales</span><span class="sxs-lookup"><span data-stu-id="0e49a-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="0e49a-139">Normalmente, uno o varios subprocesos se bloquean en <xref:System.Threading.EventWaitHandle> hasta que un subproceso desbloqueado llama al método <xref:System.Threading.EventWaitHandle.Set%2A>, lo que libera uno de los subprocesos en espera (en el caso de los eventos de restablecimiento automático) o todos ellos (en el caso de eventos de restablecimiento manual).</span><span class="sxs-lookup"><span data-stu-id="0e49a-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="0e49a-140">Un subproceso puede señalar <xref:System.Threading.EventWaitHandle> y, a continuación, bloquearse ahí, como una operación atómica, mediante una llamada al método estático <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0e49a-141">Los objetos <xref:System.Threading.EventWaitHandle> pueden usarse con los métodos estáticos <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="0e49a-142">Dado que las clases <xref:System.Threading.EventWaitHandle> y <xref:System.Threading.Mutex> se derivan de <xref:System.Threading.WaitHandle>, puede usar las dos con estos métodos.</span><span class="sxs-lookup"><span data-stu-id="0e49a-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="0e49a-143">Eventos con nombre</span><span class="sxs-lookup"><span data-stu-id="0e49a-143">Named Events</span></span>  

 <span data-ttu-id="0e49a-144">El sistema operativo Windows permite que los identificadores de espera de evento tengan nombres.</span><span class="sxs-lookup"><span data-stu-id="0e49a-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="0e49a-145">Un evento con nombre abarca todo el sistema.</span><span class="sxs-lookup"><span data-stu-id="0e49a-145">A named event is system wide.</span></span> <span data-ttu-id="0e49a-146">Es decir, una vez creado el evento con nombre, es visible para todos los subprocesos de todos los procesos.</span><span class="sxs-lookup"><span data-stu-id="0e49a-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="0e49a-147">Por lo tanto, los eventos con nombre pueden utilizarse para sincronizar tanto las actividades de procesos como las de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="0e49a-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="0e49a-148">Puede crear un objeto <xref:System.Threading.EventWaitHandle> que represente un evento de sistema con nombre mediante el uso de uno de los constructores que especifica un nombre de evento.</span><span class="sxs-lookup"><span data-stu-id="0e49a-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e49a-149">Dado que los eventos con nombre abarcan todo el sistema, es posible tener varios objetos <xref:System.Threading.EventWaitHandle> que representan el mismo evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="0e49a-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="0e49a-150">Cada vez que llama a un constructor o al método <xref:System.Threading.EventWaitHandle.OpenExisting%2A>, se crea un objeto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="0e49a-151">Si se especifica el mismo nombre repetidamente, se crean varios objetos que representan el mismo evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="0e49a-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="0e49a-152">Se recomienda actuar con precaución en el uso de los eventos con nombre.</span><span class="sxs-lookup"><span data-stu-id="0e49a-152">Caution is advised in using named events.</span></span> <span data-ttu-id="0e49a-153">Dado que abarcan todo el sistema, otro proceso que utilice el mismo nombre puede bloquear los subprocesos inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="0e49a-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="0e49a-154">Si hubiera código malintencionado ejecutándose en el mismo equipo, dicho código podría utilizar esto como base de un ataque de denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="0e49a-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="0e49a-155">Utilice la seguridad de control de acceso para proteger un objeto <xref:System.Threading.EventWaitHandle> que representa un evento con nombre, a poder ser mediante un constructor que especifique un objeto <xref:System.Security.AccessControl.EventWaitHandleSecurity>.</span><span class="sxs-lookup"><span data-stu-id="0e49a-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="0e49a-156">También puede aplicar la seguridad de control de acceso mediante el método <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>, pero esto deja una ventana de vulnerabilidad entre el momento en que se crea el identificador de espera de evento y el momento en que se protege.</span><span class="sxs-lookup"><span data-stu-id="0e49a-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="0e49a-157">Proteger los eventos con seguridad de control de acceso ayuda a evitar ataques malintencionados, pero no soluciona el problema de conflictos involuntarios de nombres.</span><span class="sxs-lookup"><span data-stu-id="0e49a-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e49a-158">A diferencia de la clase <xref:System.Threading.EventWaitHandle>, las clases derivadas <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent> pueden representar solo identificadores de espera locales.</span><span class="sxs-lookup"><span data-stu-id="0e49a-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="0e49a-159">No pueden representar eventos del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="0e49a-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0e49a-160">Vea también</span><span class="sxs-lookup"><span data-stu-id="0e49a-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
